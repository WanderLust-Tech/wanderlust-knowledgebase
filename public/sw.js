// Wanderlust Knowledge Base Service Worker
const CACHE_NAME = 'wanderlust-kb-v1';
const RUNTIME_CACHE = 'wanderlust-runtime-v1';
const SEARCH_INDEX_CACHE = 'wanderlust-search-v1';

// Files to cache immediately (shell files)
const STATIC_CACHE_URLS = [
  '/',
  '/index.html',
  '/manifest.json',
  '/search-index.json',
  // Add your built CSS and JS files here - they'll be generated by Vite
];

// Content files that should be cached when accessed
const CONTENT_CACHE_PATTERNS = [
  /^\/content\/.+\.md$/,
  /^\/img\/.+\.(png|jpg|jpeg|svg|webp)$/,
  /^\/introduction\//,
  /^\/getting-started\//,
  /^\/architecture\//,
  /^\/modules\//,
  /^\/security\//,
  /^\/debugging\//,
  /^\/contributing\//
];

// Install event - cache static resources
self.addEventListener('install', (event) => {
  console.log('Service Worker: Install event');
  
  event.waitUntil(
    (async () => {
      try {
        const cache = await caches.open(CACHE_NAME);
        console.log('Service Worker: Caching static files');
        await cache.addAll(STATIC_CACHE_URLS);
        
        // Cache the search index separately
        const searchCache = await caches.open(SEARCH_INDEX_CACHE);
        await searchCache.add('/search-index.json');
        
        // Skip waiting to activate immediately
        self.skipWaiting();
      } catch (error) {
        console.error('Service Worker: Install failed', error);
      }
    })()
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', (event) => {
  console.log('Service Worker: Activate event');
  
  event.waitUntil(
    (async () => {
      try {
        const cacheNames = await caches.keys();
        const validCaches = [CACHE_NAME, RUNTIME_CACHE, SEARCH_INDEX_CACHE];
        
        // Delete old caches
        await Promise.all(
          cacheNames
            .filter(cacheName => !validCaches.includes(cacheName))
            .map(cacheName => {
              console.log('Service Worker: Deleting old cache', cacheName);
              return caches.delete(cacheName);
            })
        );
        
        // Take control of all clients
        self.clients.claim();
      } catch (error) {
        console.error('Service Worker: Activate failed', error);
      }
    })()
  );
});

// Fetch event - serve from cache or network
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Only handle same-origin requests
  if (url.origin !== location.origin) {
    return;
  }
  
  // Handle different types of requests
  if (isContentRequest(request)) {
    event.respondWith(handleContentRequest(request));
  } else if (isSearchIndexRequest(request)) {
    event.respondWith(handleSearchIndexRequest(request));
  } else if (isNavigationRequest(request)) {
    event.respondWith(handleNavigationRequest(request));
  } else {
    event.respondWith(handleStaticRequest(request));
  }
});

// Check if request is for content files
function isContentRequest(request) {
  return CONTENT_CACHE_PATTERNS.some(pattern => 
    pattern.test(new URL(request.url).pathname)
  );
}

// Check if request is for search index
function isSearchIndexRequest(request) {
  return new URL(request.url).pathname === '/search-index.json';
}

// Check if request is navigation (HTML pages)
function isNavigationRequest(request) {
  return request.mode === 'navigate' || 
         (request.method === 'GET' && request.headers.get('accept').includes('text/html'));
}

// Handle content requests (markdown files, images)
async function handleContentRequest(request) {
  try {
    const cache = await caches.open(RUNTIME_CACHE);
    
    // Try cache first
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      console.log('Service Worker: Serving from cache', request.url);
      return cachedResponse;
    }
    
    // Fetch from network and cache
    const response = await fetch(request);
    if (response.ok) {
      console.log('Service Worker: Caching content', request.url);
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.error('Service Worker: Content request failed', error);
    return new Response('Content unavailable offline', { 
      status: 503, 
      statusText: 'Service Unavailable' 
    });
  }
}

// Handle search index requests
async function handleSearchIndexRequest(request) {
  try {
    const cache = await caches.open(SEARCH_INDEX_CACHE);
    
    // Always try network first for search index to get latest
    try {
      const response = await fetch(request);
      if (response.ok) {
        cache.put(request, response.clone());
        return response;
      }
    } catch (networkError) {
      console.log('Service Worker: Network failed, trying cache');
    }
    
    // Fallback to cache
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    throw new Error('Search index not available');
  } catch (error) {
    console.error('Service Worker: Search index request failed', error);
    return new Response('{"error": "Search unavailable offline"}', {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    });
  }
}

// Handle navigation requests (SPA routes)
async function handleNavigationRequest(request) {
  try {
    const cache = await caches.open(CACHE_NAME);
    
    // Always try network first for navigation
    try {
      const response = await fetch(request);
      if (response.ok) {
        return response;
      }
    } catch (networkError) {
      console.log('Service Worker: Navigation network failed, trying cache');
    }
    
    // Fallback to cached index.html for SPA routing
    const cachedResponse = await cache.match('/index.html');
    if (cachedResponse) {
      return cachedResponse;
    }
    
    throw new Error('App shell not available');
  } catch (error) {
    console.error('Service Worker: Navigation request failed', error);
    return new Response('App unavailable offline', { 
      status: 503, 
      statusText: 'Service Unavailable' 
    });
  }
}

// Handle static requests (CSS, JS, etc.)
async function handleStaticRequest(request) {
  try {
    const cache = await caches.open(CACHE_NAME);
    
    // Try cache first for static resources
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // Fetch from network
    const response = await fetch(request);
    if (response.ok) {
      // Cache static resources
      cache.put(request, response.clone());
    }
    
    return response;
  } catch (error) {
    console.error('Service Worker: Static request failed', error);
    return new Response('Resource unavailable offline', { 
      status: 503, 
      statusText: 'Service Unavailable' 
    });
  }
}

// Handle background sync for potential future features
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    console.log('Service Worker: Background sync event');
    // Add background sync logic here if needed
  }
});

// Handle push notifications (if needed in the future)
self.addEventListener('push', (event) => {
  console.log('Service Worker: Push event received');
  // Add push notification logic here if needed
});

// Log service worker updates
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});
