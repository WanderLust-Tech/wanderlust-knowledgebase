# Contributing to C### 1.1. System### 1.1. System Requirements

**Minimum Requirements for v134+:**
- **Python**: 3.8+ (3.11+ recommended for Bazel builds)
- **Git**: 2.35+ with LFS support
- **Memory**: 32GB RAM minimum (64GB for full builds)
- **Storage**: 200GB+ available space (SSD strongly recommended)
- **OS Support**: 
  - Windows 11 with WSL2 or na### 3.2. Component Prefixes (Updated for v134)

**Core Components:**
- `[base]` - Base library changes
- `[content]` - Content layer (renderer, browser processes)
- `[chrome]` - Chrome browser UI and features
- `[net]` - Network stack
- `[security]` - Security-related changes
- `[gpu]` - Graphics and GPU acceleration
- `[mojo]` - IPC and service interfaces

**New v134+ Components:**
- `[rust]` - Rust integration and components
- `[bazel]` - Build system migration
- `[fuchsia]` - Fuchsia OS support
- `[webgpu]` - WebGPU implementation
- `[origin-trial]` - Origin trial features

### 3.3. Security-Sensitive Changes

For security-related commits, additional requirements apply:

```
[security] Fix XSS vulnerability in URL parsing

This change addresses a cross-site scripting vulnerability where
malicious URLs could bypass sanitization in the omnibox.

The fix implements stricter URL validation using a allowlist
approach rather than blocklist to prevent future bypasses.

Bug: chromium:1234567
Security-Review: security-team@chromium.org
Security-Severity: high
Security-Bug: 1234567
Test: security_tests --gtest_filter=UrlSanitizer.*
Change-Id: I1234567890abcdef1234567890abcdef12345678
```

### 3.4. Performance-Sensitive Changes

For changes affecting performance:

```
[base] Optimize string concatenation in base::StrCat

Replace repeated string allocations with a single pre-sized
buffer allocation, reducing memory pressure and improving
performance for common string operations.

Benchmark results:
- 25% reduction in allocations
- 15% improvement in wall-clock time
- No regression in peak memory usage

Bug: chromium:1234567
Performance-Impact: medium
Benchmark: base_perftests --gtest_filter=StringConcatBenchmark
Test: base_unittests --gtest_filter=StrCat*
Change-Id: I1234567890abcdef1234567890abcdef12345678
```

### 3.5. Required Footer Tags

**Mandatory for all commits:**
- `Change-Id:` - Generated by git-cl
- `Test:` - How the change was tested
- `Bug:` - Associated bug (use "none" if no bug)

**Conditional tags:**
- `Security-Review:` - Required for security-sensitive changes
- `Performance-Impact:` - Required for performance-affecting changes
- `Breaking-Change:` - Required for API/behavior changes
- `Security-Severity:` - For security fixes (low|medium|high|critical)
- `Rust-Component:` - For Rust integration changes
- `Origin-Trial:` - For experimental web platform features

## 4. Testing & ValidationwerShell 7+
  - macOS 12+ (Intel/Apple Silicon)
  - Ubuntu 20.04+ or equivalent Linux distribution

**Required Accounts & Agreements:**
- Google account with [Chromium CLA][cla] signed
- GitHub account (for security scanning integration)
- Access to [chromium-security mailing list][security-list] (for security-sensitive contributions)irements

**Minimum Requirements for v134+:**
- **Python**: 3.8+ (3.11+ recommended for Bazel builds)
- **Git**: 2.35+ with LFS support
- **Memory**: 32GB RAM minimum (64GB for full builds)
- **Storage**: 200GB+ available space (SSD strongly recommended)
- **OS Support**: 
  - Windows 11 with WSL2 or native PowerShell 7+
  - macOS 12+ (Intel/Apple Silicon)
  - Ubuntu 20.04+ or equivalent Linux distribution

**Required Accounts & Agreements:**
- Google account with [Chromium CLA][cla] signed
- GitHub account (for security scanning integration)
- Access to [chromium-security mailing list][security-list] (for security-sensitive contributions)um

Welcome to the Chromium project! This comprehensive guide will walk you through contributing to Chromium v134+, covering everything from initial setup to landing your first security-reviewed patch.

## What's New in v134+

Chromium v134+ introduces significant architectural improvements:
- **Bazel Build Migration**: Gradual transition from GN to Bazel for improved build performance
- **Enhanced Security Model**: Mandatory security reviews for sensitive components
- **C++23 Support**: Modern language features for improved safety and performance
- **Rust Integration**: Selected components now use Rust for memory safety
- **Advanced Testing**: Enhanced fuzzing and automated security scanning

Whether you're fixing a bug, implementing a feature, or improving performance, this guide ensures your contribution meets our v134+ standards for security, performance, and maintainability.

---

## 1. Prerequisites & Environment Setup

### 1.1. Prerequisites

- You’ve [set up and built Chromium][setup-build].  
- You have a Google account and have signed the [Chromium Contributor License Agreement (CLA)][cla].  
- On Linux/macOS you have Python 3 and Git installed; on Windows you’re using PowerShell with Depot Tools in your `PATH`.

### 1.2. Development Environment Options

#### Option A: Native Development (Recommended)

1. **Install Depot Tools**
   ```bash
   # Linux/macOS
   git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
   export PATH="$PATH:/path/to/depot_tools"
   
   # Windows (PowerShell as Administrator)
   git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git C:\depot_tools
   $env:PATH += ";C:\depot_tools"
   ```

2. **Clone Chromium with v134+ Support**
   ```bash
   mkdir chromium && cd chromium
   fetch --nohooks chromium
   cd src
   
   # Enable Bazel builds (experimental in v134)
   echo "use_bazel = true" >> .gclient
   gclient sync --with_branch_heads --with_tags --jobs=16
   ```

#### Option B: Container Development (Security Isolation)

For security-sensitive development, use our official container:

```bash
# Pull the v134+ development container
docker pull gcr.io/chromium-container-dev/chromium:v134

# Run with proper mounts and security
docker run -it --security-opt seccomp=unconfined \
  -v $PWD:/workspace \
  gcr.io/chromium-container-dev/chromium:v134
```

### 1.3. Git Configuration

```bash
# Set your identity (must match CLA)
git config --global user.name "Your Full Name"
git config --global user.email "your.email@domain.com"

# Enable security features
git config --global commit.gpgsign true
git config --global tag.forceSignAnnotated true
git config --global pull.rebase true

# Configure for large repositories
git config --global core.preloadindex true
git config --global core.fscache true
git config --global gc.auto 256
```

### 1.4. Authentication Setup

1. **Gerrit SSH Access**
   ```bash
   # Generate Ed25519 key (more secure than RSA)
   ssh-keygen -t ed25519 -C "your.email@domain.com"
   
   # Upload public key to Gerrit settings
   # Test connection
   ssh -p 29418 chromium-review.googlesource.com
   ```

2. **Enable 2FA** (Required for security contributions)
   - Enable 2FA on your Google account
   - Configure app-specific passwords for depot_tools

### 1.5. Build Configuration

Create your build configuration for v134+:

```bash
# Generate build files with security hardening
gn gen out/Default --args='
  is_debug = true
  is_component_build = true
  enable_nacl = false
  use_goma = true
  symbol_level = 1
  blink_symbol_level = 0
  enable_security_hardening = true
  use_sanitizer_coverage = true
'

# For Bazel builds (experimental)
bazel build --config=chromium_dev //chrome:chrome
```

## 2. Coding Conventions & Style

Chromium v134+ follows modern, security-first coding practices across multiple languages. Our style guides have been updated to leverage the latest language features while maintaining performance and security.

### 2.1. C++ Guidelines (C++23)

**Modern C++ Features in v134+:**
```cpp
// Use concepts for better template constraints
template<std::integral T>
class SafeInteger {
  T value_;
public:
  constexpr explicit SafeInteger(T val) : value_(val) {}
  
  // Use designated initializers
  struct Config {
    bool enable_bounds_check = true;
    size_t max_value = std::numeric_limits<size_t>::max();
  };
};

// Prefer ranges and views
auto ProcessItems(const std::vector<Item>& items) {
  return items 
    | std::views::filter([](const Item& item) { return item.IsValid(); })
    | std::views::transform([](const Item& item) { return item.Process(); });
}
```

**Security-First Patterns:**
```cpp
// Always use smart pointers for memory management
std::unique_ptr<NetworkHandler> CreateHandler() {
  return std::make_unique<NetworkHandler>();
}

// Use base::span for safe array access
void ProcessData(base::span<const uint8_t> data) {
  // Bounds-checked access automatically
  for (auto byte : data) {
    // Process safely
  }
}

// Prefer std::optional over null pointers
std::optional<UserSession> GetCurrentSession() {
  if (auto* session = session_manager_->current_session()) {
    return UserSession(*session);
  }
  return std::nullopt;
}
```

### 2.2. Rust Integration Guidelines

For components migrated to Rust in v134+:

```rust
// Use strict clippy lints
#![deny(clippy::all)]
#![deny(unsafe_code)]
#![warn(clippy::pedantic)]

// Prefer explicit error handling
pub fn parse_config(data: &[u8]) -> Result<Config, ConfigError> {
    serde_json::from_slice(data)
        .map_err(ConfigError::ParseError)
}

// Use strong typing for security
#[derive(Debug, Clone)]
pub struct SanitizedUrl(String);

impl SanitizedUrl {
    pub fn new(url: &str) -> Result<Self, UrlError> {
        // Validation logic
        if is_safe_url(url) {
            Ok(Self(url.to_string()))
        } else {
            Err(UrlError::Unsafe)
        }
    }
}
```

### 2.3. JavaScript/TypeScript Guidelines

**Modern TypeScript Patterns:**
```typescript
// Use strict mode and modern features
interface SecurityPolicy {
  readonly cspDirectives: ReadonlyArray<string>;
  readonly allowedOrigins: Set<string>;
}

// Prefer const assertions and template literals
const API_ENDPOINTS = {
  users: '/api/v2/users',
  sessions: '/api/v2/sessions',
} as const;

// Use discriminated unions for type safety
type ApiResponse<T> = 
  | { success: true; data: T }
  | { success: false; error: string };

async function fetchUserData(id: string): Promise<ApiResponse<User>> {
  try {
    const response = await fetch(`${API_ENDPOINTS.users}/${id}`);
    const data = await response.json();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error.message };
  }
}
```

### 2.4. Style Requirements

**Formatting & Structure:**
- **Indentation**: 2 spaces (no tabs) for all languages
- **Line Length**: 
  - C++/Rust: 80 characters for code, 100 for comments
  - JavaScript/TypeScript: 100 characters
- **File Organization**: Group includes/imports by type (system, third-party, local)

**Naming Conventions:**
```cpp
// C++ Examples
class NetworkRequestHandler {};        // PascalCase for types
void ProcessHttpRequest();             // PascalCase for functions
const int kMaxRetryCount = 3;          // k prefix for constants
bool is_secure_connection_ = false;    // snake_case for members
```

```rust
// Rust Examples
struct HttpClient {}                   // PascalCase for types
fn process_request() {}               // snake_case for functions
const MAX_RETRY_COUNT: i32 = 3;       // SCREAMING_SNAKE_CASE for constants
```

### 2.5. Code Quality Tools

**Mandatory Pre-submission Checks:**
```bash
# C++ formatting and linting
git cl presubmit --upload
tools/clang/scripts/run-clang-format.py --style=chromium
tools/clang/scripts/run-clang-tidy.py

# Rust checks (for Rust components)
cargo clippy --all-targets --all-features -- -D warnings
cargo fmt --check

# JavaScript/TypeScript
npm run lint
npm run type-check
```

**Security Analysis:**
```bash
# Run security scanners before upload
tools/security/run-security-checks.py
tools/fuzz/check-fuzz-targets.py

# Memory safety validation
tools/valgrind/chrome_tests.py
tools/asan/run-tests.py
```

### 2.6. Documentation Standards

**Required Documentation:**
```cpp
// Header documentation with security considerations
/**
 * Handles secure network communication for browser processes.
 * 
 * SECURITY: All input must be validated before processing.
 * This class handles sensitive network data and must not
 * leak information across security boundaries.
 * 
 * @thread_safety This class is not thread-safe. Use from
 * the main thread only.
 */
class SecureNetworkHandler {
 public:
  // Document security-relevant parameters
  bool ProcessRequest(const std::string& url,  // Must be validated URL
                     const Headers& headers);   // Trusted headers only
};
```

## 3. Commit Message Format

Chromium v134+ uses structured commit messages for automated processing, security tracking, and release management. Follow this format precisely:

### 3.1. Standard Format

```
[component] Brief summary (50 chars max)

Detailed description of your change:
- What problem this solves
- Implementation approach
- Performance/security implications
- Breaking changes (if any)

Bug: chromium:1234567
Change-Id: I1234567890abcdef1234567890abcdef12345678
Test: unit_tests --gtest_filter=MyTest.*
Security-Review: security-team@ (if security-sensitive)
Performance-Impact: none|low|medium|high
```
Prefix each message with [area], e.g. [content], [net], [ui].

Include a Bug: link if you’re fixing or closing an issue.

Mention tests in the Test: line.

## 4. Testing & Validation

Chromium v134+ requires comprehensive testing across multiple dimensions: functionality, security, performance, and compatibility. All changes must pass automated validation before review.

### 4.1. Pre-Upload Validation

**Mandatory Checks (All Changes):**
```bash
# Format and lint checks
git cl presubmit --upload
tools/clang/scripts/run-clang-format.py --style=chromium --in-place
tools/clang/scripts/run-clang-tidy.py --checks=-*,readability-*,security-*

# Build verification (multiple configurations)
autoninja -C out/Default chrome
autoninja -C out/Release chrome
autoninja -C out/Debug chrome

# Basic functionality tests
out/Default/unit_tests --gtest_filter=*YourComponent*
out/Default/browser_tests --gtest_filter=*YourFeature*
```

**Security-Sensitive Changes:**
```bash
# Security-specific validation
tools/security/run-security-checks.py --component=your_component
tools/fuzz/check-fuzz-targets.py --validate-new-targets

# Memory safety verification
autoninja -C out/ASan chrome  # AddressSanitizer build
autoninja -C out/MSan chrome  # MemorySanitizer build
out/ASan/unit_tests --gtest_filter=*YourComponent*

# Fuzzing validation (if adding new attack surfaces)
tools/fuzz/run-fuzz-tests.py --component=your_component --duration=60s
```

### 4.2. Test Framework Requirements

**Unit Testing (Required for all code changes):**
```cpp
// Modern C++ testing with security focus
#include "testing/gtest/include/gtest/gtest.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "base/test/scoped_feature_list.h"

class SecureUrlParserTest : public testing::Test {
 protected:
  void SetUp() override {
    feature_list_.InitAndEnableFeature(features::kSecureUrlParsing);
  }

  base::test::ScopedFeatureList feature_list_;
};

TEST_F(SecureUrlParserTest, RejectsInvalidUrls) {
  // Test security boundary conditions
  EXPECT_FALSE(parser_.IsValid("javascript:alert(1)"));
  EXPECT_FALSE(parser_.IsValid("data:text/html,<script>"));
  
  // Test edge cases that previously caused issues
  EXPECT_FALSE(parser_.IsValid(std::string(10000, 'a')));  // Length attack
  EXPECT_FALSE(parser_.IsValid("http://\x00.example.com"));  // Null byte injection
}

TEST_F(SecureUrlParserTest, HandlesValidUrlsCorrectly) {
  EXPECT_TRUE(parser_.IsValid("https://example.com/path"));
  EXPECT_TRUE(parser_.IsValid("chrome://settings/"));
}
```

**Integration Testing (Required for UI/API changes):**
```cpp
// Browser test with real Chrome instances
#include "chrome/test/base/in_process_browser_test.h"
#include "chrome/test/base/ui_test_utils.h"

class PasswordManagerSecurityTest : public InProcessBrowserTest {
 public:
  void SetUpOnMainThread() override {
    // Set up secure test environment
    EnableSecurityFeatures();
  }
};

IN_PROC_BROWSER_TEST_F(PasswordManagerSecurityTest, BiometricAuthRequired) {
  // Navigate to password manager
  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), 
    GURL("chrome://settings/passwords")));
  
  // Verify biometric prompt appears
  EXPECT_TRUE(WaitForBiometricPrompt());
  
  // Test successful authentication
  SimulateBiometricAuth(true);
  EXPECT_TRUE(PasswordListVisible());
}
```

### 4.3. Rust Component Testing

For Rust components in v134+:

```rust
// Comprehensive Rust testing
#[cfg(test)]
mod tests {
    use super::*;
    use std::panic;
    
    #[test]
    fn test_secure_url_parsing() {
        let parser = SecureUrlParser::new();
        
        // Test valid URLs
        assert!(parser.parse("https://example.com").is_ok());
        
        // Test security boundary conditions
        assert!(parser.parse("javascript:alert(1)").is_err());
        assert!(parser.parse(&"a".repeat(100_000)).is_err());
    }
    
    #[test]
    fn test_memory_safety() {
        // Rust automatically provides memory safety, but test edge cases
        let large_input = "x".repeat(1_000_000);
        let result = panic::catch_unwind(|| {
            SecureUrlParser::new().parse(&large_input)
        });
        assert!(result.is_ok(), "Parser should handle large inputs gracefully");
    }
}

// Property-based testing for security
#[cfg(test)]
mod property_tests {
    use proptest::prelude::*;
    
    proptest! {
        #[test]
        fn url_parser_never_panics(s in "\\PC*") {
            let parser = SecureUrlParser::new();
            let _ = parser.parse(&s); // Should never panic
        }
        
        #[test]
        fn valid_urls_stay_valid(url in valid_url_strategy()) {
            let parser = SecureUrlParser::new();
            prop_assert!(parser.parse(&url).is_ok());
        }
    }
}
```

### 4.4. Performance Testing

**Mandatory for performance-sensitive changes:**
```bash
# Performance regression testing
tools/perf/run_benchmark.py --browser=release \
  --benchmark=loading.desktop \
  --story-filter="*your_feature*"

# Memory usage validation
tools/memory/run_memory_test.py --test-filter="*YourComponent*"

# Startup time verification (critical for browser changes)
tools/perf/run_benchmark.py --browser=release \
  --benchmark=start_with_url.cold.startup_pages

# Custom performance tests
out/Release/performance_tests --gtest_filter=*YourFeature*
```

### 4.5. Cross-Platform Testing

**Required test matrix for v134+:**
```bash
# Windows (multiple versions)
python tools/autotest/run_tests.py --platform=win10_x64
python tools/autotest/run_tests.py --platform=win11_x64

# macOS (Intel and Apple Silicon)
python tools/autotest/run_tests.py --platform=mac_x64
python tools/autotest/run_tests.py --platform=mac_arm64

# Linux (multiple distributions)
python tools/autotest/run_tests.py --platform=linux_x64
python tools/autotest/run_tests.py --platform=linux_arm64

# ChromeOS
python tools/autotest/run_tests.py --platform=chromeos_x64
```

### 4.6. Security Testing Requirements

**Fuzzing (Required for new attack surfaces):**
```bash
# Create fuzzing target for new components
cat > fuzz_your_component.cc << 'EOF'
#include "base/logging.h"
#include "your_component/your_component.h"

extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {
  if (size < 1) return 0;
  
  std::string input(reinterpret_cast<const char*>(data), size);
  YourComponent component;
  
  // Fuzz all public methods safely
  component.ProcessInput(input);
  return 0;
}
EOF

# Build and run fuzzer
autoninja -C out/Fuzzer your_component_fuzzer
out/Fuzzer/your_component_fuzzer -max_total_time=300
```

**Security Boundary Testing:**
```cpp
// Test process isolation boundaries
TEST_F(SecurityTest, ProcessIsolationMaintained) {
  // Ensure renderer cannot access browser memory
  EXPECT_FALSE(CanAccessBrowserMemory());
  
  // Test IPC validation
  EXPECT_FALSE(SendInvalidIPC());
}

// Test against known attack patterns
TEST_F(SecurityTest, ResistantToKnownAttacks) {
  // Test against XXS attempts
  EXPECT_FALSE(ExecutesArbitraryScript("javascript:alert(1)"));
  
  // Test against buffer overflow attempts
  std::string overflow_attempt(10000, 'A');
  EXPECT_FALSE(CausesBufferOverflow(overflow_attempt));
}
```

### 4.7. Manual Testing Checklist

**Smoke Testing (All Changes):**
- [ ] Browser starts without crashes
- [ ] Basic navigation works (loading pages, back/forward)
- [ ] No obvious visual regressions
- [ ] Feature works as designed
- [ ] No new console errors or warnings

**Security-Sensitive Changes:**
- [ ] No information leakage across security boundaries
- [ ] Authentication/authorization works correctly  
- [ ] Input validation rejects malicious inputs
- [ ] No new attack surfaces introduced

**Performance-Sensitive Changes:**
- [ ] No significant startup time regression
- [ ] Memory usage remains stable
- [ ] No new performance cliffs or bottlenecks
- [ ] Benchmark numbers meet expectations

### 4.8. Automated Testing Integration

**CI/CD Pipeline Integration:**
```yaml
# Example .gn configuration for automated testing
test_targets = [
  "//your_component:unit_tests",
  "//your_component:integration_tests", 
  "//your_component:security_tests",
  "//your_component:performance_tests",
]

# Security-specific CI requirements
security_tests = [
  "//security:url_sanitizer_tests",
  "//security:xss_prevention_tests",
  "//security:csrf_protection_tests",
]
```

## 5. Code Review Process
Commit & Upload

bash
Copy
Edit
git checkout -b my-feature-branch
git commit -a
git cl upload
Reviewer Feedback

Address comments by amending your commit:

bash
Copy
Edit
git commit --amend
git cl upload --replace
Getting LGTM
Once two reviewers give LGTM and CQ+1 passes, your change will land automatically.

6. Working with Gerrit
View your changes:
https://chromium-review.googlesource.com/q/status:open+owner:self

Cherry-picking / rebasing:

bash
Copy
Edit
git fetch https://chromium.googlesource.com/chromium/src refs/changes/54/12354/2 && git cherry-pick FETCH_HEAD
Undoing a landed CL:
Upload a revert by clicking “Revert Change” in the Gerrit UI.

7. Troubleshooting & Common Pitfalls
Presubmit failures

Check the Buildbucket logs for style or test errors.

Merge conflicts

Rebase onto main:

bash
Copy
Edit
git fetch origin main && git rebase origin/main
Slow builds

Use autoninja -j<N> matching your CPU cores.

8. Beyond Code
Design Documents

For large features, submit a design doc under docs/ and get early feedback.

Localization

UI strings live in chrome/app/resources/; use l10n tools to extract/update translations.

Documentation

Keep inline /README.md files up to date in each directory you touch.

9. Getting Help & Community
Mailing Lists: chromium-dev@chromium.org

IRC/Slack: channels listed on the Chromium Community wiki

Weekly Office Hours: check the Chromium Calendar

10. Next Steps
Read Getting Started → Project Layout to orient yourself in the tree.

Pick a Good First Issue and try submitting a small fix.

Celebrate landing your first commit—welcome to the Chromium community!

Happy coding!

arduino
Copy
Edit

This guide will give newcomers a clear path: set up their environment, follow style and commit guidelines, run tests, and navigate Chromium’s Gerrit-based review process. Let me know if you’d like any tweaks or additions!