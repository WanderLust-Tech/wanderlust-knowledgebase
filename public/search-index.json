[
  {
    "path": "security/security-model",
    "title": "Security Model",
    "content": "# Security Model\r\n\r\nChromium’s security architecture is layered to protect users from malicious content, compromised sites, and browser vulnerabilities. This article breaks down the key pieces of that model—from sandboxing to origin isolation to transport security—and points you to the source files where each is implemented.\r\n\r\n---\r\n\r\n## 1. Threat Model & Goals\r\n\r\n- **Threats Addressed**  \r\n  - Arbitrary code execution via renderer or plugin bugs  \r\n  - Cross-site data leakage (XSS, CSRF)  \r\n  - Network eavesdropping or man-in-the-middle attacks  \r\n- **Security Goals**  \r\n  1. **Isolation**: ensure that untrusted web content cannot read or write user data outside its scope.  \r\n  2. **Least Privilege**: run each component with minimal OS privileges.  \r\n  3. **Defense in Depth**: multiple overlapping safeguards (sandbox, site isolation, CSP).  \r\n\r\n---\r\n\r\n## 2. Origin & Same-Origin Policy\r\n\r\n- **Origin Definition**  \r\n  - A tuple of (scheme, host, port). Two pages may interact only if all three match.  \r\n- **Enforcement**  \r\n  - Implemented in Blink’s DOM bindings under `third_party/blink/renderer/bindings/`.  \r\n  - Checked in navigation, XHR/fetch, iframe embedding, `document.cookie`.  \r\n- **Key Files**  \r\n  - `security_origin.cc` (defines `SecurityOrigin` and policy checks)  \r\n  - `script_security.cc` (enforces JS‐level checks)\r\n\r\n---\r\n\r\n## 3. Site Isolation & Process-Per-Site\r\n\r\n- **Site-Per-Process**  \r\n  - By default, Chromium maps each “site” (origin) into its own renderer process.  \r\n  - Prevents a compromised renderer from poking into other sites’ memory.  \r\n- **Implementation**  \r\n  - Controlled by GN flag `site_per_process` in `content/browser/site_isolation/`.  \r\n  - `SiteIsolationPolicy` and `SiteInstance` classes coordinate process mapping.  \r\n- **Crash Containment**  \r\n  - Renderer crash shows only that tab’s error page; other tabs unaffected.\r\n\r\n---\r\n\r\n## 4. OS-Level Sandboxing\r\n\r\nChromium runs its renderers and helper processes in strict OS sandboxes:\r\n\r\n| Platform | Mechanism                                          | Source Location                           |\r\n|----------|----------------------------------------------------|-------------------------------------------|\r\n| **Windows** | Job objects + restricted tokens                 | `sandbox/win/`                            |\r\n| **Linux**   | setuid “chrome-sandbox” or seccomp‐bpf filters  | `sandbox/linux/`                          |\r\n| **macOS**   | Seatbelt profiles                                | `sandbox/mac/`                            |\r\n\r\n- **Sandbox Brokers**  \r\n  - A minimal “broker” process handles syscalls (e.g. DNS, font enumeration) on behalf of the sandboxed child.  \r\n- **Key Files**  \r\n  - `sandbox_init.cc`  \r\n  - Platform‐specific policy headers under `sandbox/{win,linux,mac}/`.\r\n\r\n---\r\n\r\n## 5. Permissions & Feature Policy\r\n\r\n- **Permissions API**  \r\n  - JS interfaces for `geolocation`, `notifications`, `camera`, etc.  \r\n  - Backed by `PermissionController` in `content/browser/permissions/`.  \r\n- **Feature Policy / Permissions Policy**  \r\n  - Page‐level opt-in/opt-out controls which APIs iframes can use.  \r\n  - Defined via `FeaturePolicy` in Blink (`third_party/blink/renderer/core/feature_policy/`).  \r\n- **UI Prompt**  \r\n  - Browser UI for granting/denying lives in `chrome/browser/ui/permission_bubble/`.\r\n\r\n---\r\n\r\n## 6. Content Security Policy (CSP)\r\n\r\n- **CSP Headers**  \r\n  - Enforced by Blink’s `CSPContext` in `third_party/blink/renderer/core/loader/`.  \r\n  - Prevents inline script, remote code, or framing per site’s policy.  \r\n- **Reporting**  \r\n  - Violation reports sent via `ReportSender` to configured endpoints.  \r\n\r\n---\r\n\r\n## 7. Transport Security & Certificate Validation\r\n\r\n- **Trust Store**  \r\n  - Uses OS‐provided roots on Windows/macOS; Mozilla’s on Linux.  \r\n  - Managed in `net/cert/` (`cert_verifier.cc`, `root_store.cc`).  \r\n- **HSTS / HPKP**  \r\n  - HSTS enforced by `TransportSecurityState`.  \r\n  - HPKP deprecated but still present in some code paths.  \r\n- **OCSP & CRL Sets**  \r\n  - Stapled OCSP responses validated in `net/ocsp/`.  \r\n  - Chrome uses “CRLSet” updates via Safe Browsing service.\r\n\r\n---\r\n\r\n## 8. Safe Browsing & Malware Protection\r\n\r\n- **Phishing & Malware Lists**  \r\n  - Maintained by Google; downloaded to browser periodically.  \r\n  - Checks happen in `safe_browsing/` under `chrome/browser/`.  \r\n- **Interstitial UI**  \r\n  - Block pages with clear warnings.  \r\n  - Code in `chrome/browser/safe_browsing/`.  \r\n\r\n---\r\n\r\n## 9. Extension Security\r\n\r\n- **Isolated Worlds**  \r\n  - Content scripts run in separate V8 contexts with limited DOM access.  \r\n- **Permission Model**  \r\n  - Declared in `manifest.json`, enforced by `ExtensionPermission` classes.  \r\n- **Native Messaging**  \r\n  - Host apps communicate via a JSON‐over‐stdin bridge with strict path restrictions.\r\n\r\n---\r\n\r\n## 10. Developer Tools & Auditing\r\n\r\n- **chrome://security** (future) and `chrome://sandbox` pages  \r\n- **chrome://webrtc-internals** for inspecting WebRTC security parameters  \r\n- **Auditing Tools**  \r\n  - `chrome://policy` for Enterprise policy enforcement  \r\n  - Tracing categories: `SECURITY`, `NETWORK_SECURITY` in `chrome://tracing`\r\n\r\n---\r\n\r\n## 11. Testing & Hardening\r\n\r\n- **Unit & Integration Tests**  \r\n  - `content/browser/site_isolation_browsertest`  \r\n  - `security_interstitial_browsertest`  \r\n  - `sandbox_browsertest`  \r\n- **Fuzzing**  \r\n  - OSS-Fuzz integration for renderer, V8, PDFium, libogg, etc.  \r\n\r\n---\r\n\r\n## 12. Next Steps\r\n\r\n1. Read **Debugging → Debugging Tools** to learn how to trace sandbox violations.  \r\n2. Explore **Modules → Networking (HTTP)** for TLS handshake internals.  \r\n3. Dive into **Architecture → Process Model** to see how sandboxed processes communicate.  \r\n\r\n---\r\n"
  },
  {
    "path": "modules/storage-cache",
    "title": "Storage & Cache",
    "content": "# Storage & Cache\r\n\r\nEfficient storage and caching are critical to Chromium’s performance and user experience. This article covers both the low-level HTTP cache and higher-level web storage APIs, how they interact, and where to look in the source for each.\r\n\r\n---\r\n\r\n## 1. Overview\r\n\r\n- **Scope**  \r\n  - **HTTP Cache**: response caching for network requests  \r\n  - **In-Memory Cache**: fast lookup for small resources  \r\n  - **Web Storage**: LocalStorage, SessionStorage, IndexedDB, Cache API  \r\n  - **Quota & Storage Partitions**: per-origin isolation and limits  \r\n- **Goals**  \r\n  - **Performance**: avoid unnecessary network trips, disk I/O  \r\n  - **Correctness**: respect cache validation (ETags, freshness)  \r\n  - **Security**: isolate origin data, enforce quotas  \r\n\r\n---\r\n\r\n## 2. HTTP Cache (`net/disk_cache/` & `net/http/http_cache_*`)\r\n\r\n### 2.1 Architecture\r\n\r\n```text\r\nRenderer        Browser        Network Service\r\n   │               │                  │\r\n   └─URLLoader───▶│                  │\r\n           │      └──▶HttpCache───▶HttpNetworkTransaction──▶Socket\r\nHttpCache sits in between URLRequest and HttpNetworkTransaction.\r\n\r\nDisk Cache (LRU) implemented in net/disk_cache/simple/simple_entry_impl.cc.\r\n\r\nMemory Cache keeps small objects in RAM (SimpleBackend, MemBackendImpl).\r\n\r\n2.2 Key Files\r\nnet/http/http_cache.cc / .h\r\n\r\nnet/disk_cache/simple/simple_backend_impl.cc\r\n\r\nnet/disk_cache/backend_factory.h\r\n\r\n2.3 Eviction & Validation\r\nLRU eviction when size limit (default ~300 MB) is reached.\r\n\r\nCache-Control headers drive freshness; revalidate with ETag/Last-Modified.\r\n\r\nConditional Requests: 304 responses update stored entry metadata.\r\n\r\n3. Quota & Storage Partitions\r\n3.1 Storage Partitioning\r\nEach BrowserContext (Profile) has one or more StoragePartitions.\r\n\r\nPartitions isolate data by origin and by mode (e.g. default, incognito).\r\n\r\nDefined in content/browser/storage_partition_impl.cc.\r\n\r\n3.2 Quota Management\r\nQuotaManager (content/browser/quota/quota_manager_impl.cc)\r\n\r\nTracks usage per origin.\r\n\r\nEnforces soft/hard limits (default ~6 GB per origin on desktop).\r\n\r\nQuotaClient interfaces for each storage type (IndexedDB, FileSystem, Cache API).\r\n\r\n4. Web Storage APIs\r\n4.1 LocalStorage & SessionStorage\r\nLocalStorage stored in SQLite under Local Storage/ directory.\r\n\r\nSessionStorage tied to single top-level browsing context.\r\n\r\nCode lives in content/browser/dom_storage/ and content/renderer/dom_storage/.\r\n\r\n4.2 IndexedDB\r\nHigh-level object store, transactional.\r\n\r\nBacked by LevelDB in third_party/blink/renderer/modules/indexeddb/.\r\n\r\nQuota interactions via IndexedDBQuotaClient.\r\n\r\n4.3 Cache API (Service Workers)\r\nProgrammatic cache of Request/Response pairs.\r\n\r\nImplemented in service_worker/ under cache_storage/.\r\n\r\nUses the same DiskCache backend under the hood.\r\n\r\n5. Interaction with Network Stack\r\nCache-Control Overrides\r\n\r\nHTTP fetch in Service Workers can bypass the HTTP cache.\r\n\r\nStale-while-revalidate\r\n\r\nCustomizable via headers and Cache API strategies.\r\n\r\n6. Debugging & Instrumentation\r\nchrome://cache (legacy) or chrome://net-export for HTTP cache traces.\r\n\r\nchrome://quota-internals shows per-origin usage and limits.\r\n\r\nchrome://indexeddb-internals inspects IndexedDB databases.\r\n\r\nLogging flags:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --enable-logging=stderr --v=1 --log-net-log=netlog.json\r\n7. Testing & Tools\r\nUnit tests in net/disk_cache/ and content/browser/quota/.\r\n\r\nnet/tools/quic_client/ can test cache behavior over HTTP/3.\r\n\r\nUse storage_browsertest (in content/test/) to automate web storage scenarios.\r\n\r\n8. Best Practices & Extensions\r\nCache only what you can revalidate: avoid caching sensitive data.\r\n\r\nClean up on unload for SessionStorage in embedded contexts.\r\n\r\nCustom URLRequestJob to layer additional caching logic:\r\n\r\ncpp\r\nCopy\r\nEdit\r\nURLRequestFilter::GetInstance()->AddUrlInterceptor(\r\n    \"https://example.com/\", std::make_unique<MyCacheInterceptor>());\r\n9. Next Steps\r\nDive into Security → Security Model to see how origin isolation is enforced.\r\n\r\nExplore Modules → Networking (HTTP) to understand how HTTP caching hooks in.\r\n\r\nRead Debugging → Debugging Tools for end-to-end cache debugging patterns."
  },
  {
    "path": "modules/networking-http",
    "title": "Networking (HTTP)",
    "content": "# Networking (HTTP)\r\n\r\nChromium’s HTTP stack underpins all web communication. In this article we’ll trace an HTTP request from the browser down to the network, cover caching, QUIC, and show you where to hook in or inspect traffic.\r\n\r\n---\r\n\r\n## 1. Overview\r\n\r\n- **Components**  \r\n  - **Network Service** (`services/network/`)  \r\n  - **URLLoader / URLRequest** abstractions  \r\n  - **HTTP Cache** (`net/http/http_cache_*.cc`)  \r\n  - **QUIC & HTTP/2** via `net/quic/` and `net/spdy/`  \r\n- **Goals**  \r\n  - Performance: multiplexing, caching, prioritization  \r\n  - Security: TLS validation, safe headers  \r\n  - Flexibility: pluggable protocols, proxy support\r\n\r\n---\r\n\r\n## 2. The Network Service\r\n\r\nChromium runs its network stack in a separate process by default:\r\n\r\n```text\r\nBrowser Process  ←───Mojo───→  Network Service Process\r\nEntrypoint: services/network/network_service.cc\r\n\r\nIPC Interface: network_service.mojom\r\n\r\nManages global resources (DNS cache, socket pools, proxy config).\r\n\r\n3. URLLoader / URLRequest Lifecycle\r\nURLLoaderFactory\r\n\r\nCreated in the browser, sent over Mojo to Renderers.\r\n\r\nRenderer calls CreateLoaderAndStart().\r\n\r\nURLLoader\r\n\r\nImplements network::mojom::URLLoader.\r\n\r\nWraps a URLRequest (non-Mojo) or directly uses UrlLoader on non-NetworkService builds.\r\n\r\nURLRequest (net/url_request/url_request.cc)\r\n\r\nCore state machine: redirect handling, auth, retries.\r\n\r\nDelegates to HttpStreamFactory for transport.\r\n\r\ntext\r\nCopy\r\nEdit\r\nRenderer → URLLoader → URLRequest → HttpNetworkTransaction → Socket\r\n4. HTTP Transport\r\nHttpNetworkTransaction (net/http/http_network_transaction.cc)\r\n\r\nSerializes headers and body, parses responses.\r\n\r\nHonors HttpRequestHeaders, HttpResponseHeaders.\r\n\r\nConnection Pool (net/http/http_stream_factory.cc)\r\n\r\nReuses idle connections (keep-alive).\r\n\r\nCategorizes by host:port, proxy, SSL.\r\n\r\n5. HTTP/2 & QUIC\r\nChromium supports modern protocols for speed:\r\n\r\nHTTP/2 (SPDY)\r\n\r\nMultiplexed streams over a single TCP connection.\r\n\r\nImplementation under net/spdy/.\r\n\r\nQUIC (HTTP/3)\r\n\r\nRuns atop UDP.\r\n\r\nImplemented in net/quic/.\r\n\r\nHandshake, stream abstraction, congestion control.\r\n\r\nEnable via GN args:\r\n\r\ngn\r\nCopy\r\nEdit\r\nenable_http2=true\r\nenable_quic=true\r\n6. Caching Layer\r\nDisk Cache (net/disk_cache/)\r\n\r\nStores responses keyed by URL, vary headers.\r\n\r\nLRU eviction.\r\n\r\nMemory Cache\r\n\r\nFast cache of small responses.\r\n\r\nCache API Hooks\r\n\r\nHttpCache sits between URLRequest and HttpNetworkTransaction.\r\n\r\ntext\r\nCopy\r\nEdit\r\nURLRequest → HttpCache → (hit: serve; miss: HttpNetworkTransaction)\r\n7. Proxy & DNS Resolution\r\nProxy Configuration\r\n\r\nRead from system or PAC scripts (proxy_config_service.cc).\r\n\r\nDNS\r\n\r\nHostResolver API with built-in DNS cache.\r\n\r\nAsync lookups via dns_client.cc.\r\n\r\n8. Prioritization & Throttling\r\nResourceScheduler (net/http/resource_scheduler.cc)\r\n\r\nAssigns priorities (e.g. script > image).\r\n\r\nLimits max concurrent requests per host.\r\n\r\n9. Security & Certificate Validation\r\nCertVerifier (net/cert/cert_verifier.cc)\r\n\r\nValidates TLS certificates, OCSP stapling.\r\n\r\nTransportSecurityState\r\n\r\nHSTS, HPKP policies.\r\n\r\nSandbox\r\n\r\nSocket operations restricted by sandbox policy.\r\n\r\n10. Debugging & Instrumentation\r\nLogging\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --enable-logging=stderr --v=1\r\nchrome://net-internals (legacy) or chrome://net-export\r\n\r\nTracing\r\n\r\nNET_LOG category in chrome://tracing.\r\n\r\nUnit Tests\r\n\r\nUnder net/http/ and net/tools/quic_client/.\r\n\r\n11. Extensions & Hooks\r\nIf you want to inject custom behavior:\r\n\r\nURLRequestJob\r\n\r\nCreate a factory via URLRequestFilter::RegisterProtocolHandler.\r\n\r\nNetworkDelegate\r\n\r\nIntercept headers, auth events in NetworkService.\r\n\r\n12. Next Steps\r\nDeep dive: Modules → Storage & Cache to see how responses are stored.\r\n\r\nExplore Security → Security Model for TLS sandbox details.\r\n\r\nExperiment: build with enable_quic=true and capture QUIC frames with Wireshark."
  },
  {
    "path": "modules/javascript-v8",
    "title": "JavaScript (V8)",
    "content": "# JavaScript (V8)\r\n\r\nChromium embeds Google’s high-performance V8 JavaScript engine to power all script execution in web pages and browser internals. This article explores how V8 fits into Chromium’s architecture, its compilation & execution pipeline, memory management, embedding APIs, and debugging tools.\r\n\r\n---\r\n\r\n## 1. Role of V8 in Chromium\r\n\r\n- **Where it lives**  \r\n  - In the **renderer process**, under `src/third_party/v8/`  \r\n  - Blink calls into V8 via the **V8 embedder APIs** in `content/renderer/v8_*`  \r\n- **What it does**  \r\n  - Parses, compiles, and executes all JavaScript on web pages  \r\n  - Runs extension & internal scripts (e.g. DevTools, PDF viewer)  \r\n\r\n---\r\n\r\n## 2. V8 Engine Architecture\r\n\r\n```text\r\nJavaScript Source\r\n      ↓\r\n LEXING / PARSING\r\n      ↓           ↘\r\n  AST           ↘  BYTECODE (Ignition)\r\n      ↓              ↓\r\n  TURBOFan IR ← OPTIMIZING COMPILER\r\n      ↓\r\nNATIVE MACHINE CODE\r\nParser & AST\r\n\r\nparser.cc builds the Abstract Syntax Tree.\r\n\r\nUses “pre-parsing” to quickly skip heavy functions.\r\n\r\nIgnition Interpreter\r\n\r\nBytecode generator (bytecode-generator.cc) produces compact bytecodes.\r\n\r\nInterpreter (interpreter.cc) executes without initial machine-code compile.\r\n\r\nTurbofan Optimizing Compiler\r\n\r\nHot functions are profiled, then passed through Turbofan (turbofan/)\r\n\r\nGenerates highly optimized machine code.\r\n\r\nDeoptimization & On-Stack Replacement\r\n\r\nIf assumptions break (e.g. type change), deopt back to baseline.\r\n\r\n3. Memory Management & Garbage Collection\r\nHeaps & Spaces\r\n\r\nYoung Generation (Scavenge, Semi-Spaces)\r\n\r\nOld Generation (Mark-Sweep, Mark-Compact)\r\n\r\nLarge Object Space\r\n\r\nIncremental & Concurrent GC\r\n\r\nScavenges small heaps quickly\r\n\r\nMarks & compacts old generation on background threads\r\n\r\nHandles & LocalHandles\r\n\r\nC++ wrappers ensuring safe pointer movement across GCs\r\n\r\n4. V8 Embedding in Chromium\r\nIsolates (v8::Isolate)\r\n\r\nOne per renderer process by default; isolates encapsulate heaps & contexts.\r\n\r\nContexts (v8::Context)\r\n\r\nExecute code in separate global object environments (e.g. <iframe>).\r\n\r\nBindings & Templates\r\n\r\nNative classes/functions exposed to JS via FunctionTemplate and ObjectTemplate.\r\n\r\nBlink defines DOM APIs by wiring its C++ implementations to V8.\r\n\r\nMicrotasks & Promise Hooks\r\n\r\nChromium pumps the microtask queue between tasks to implement Promises.\r\n\r\n5. Compilation & Startup\r\nSnapshotting\r\n\r\nStartup snapshot captures pre-compiled builtins & standard library for faster cold starts.\r\n\r\nBuild Flags\r\n\r\nControlled via GN args:\r\n\r\ngn\r\nCopy\r\nEdit\r\nv8_enable_pointer_compression = true\r\nv8_enable_slow_dchecks = false\r\nv8_static_rooting = true\r\nDebug vs Release\r\n\r\nDebug builds include extra checks, slower GC; release builds optimize for speed.\r\n\r\n6. Debugging & Profiling\r\nDevTools Protocol\r\n\r\nV8 exposes the Debugger, Profiler, and Heap domains.\r\n\r\nConnect via chrome://inspect or embed custom tools.\r\n\r\nCPU & Memory Profiles\r\n\r\nCapture JS call stacks, optimize hotspots in Turbofan.\r\n\r\nHeap snapshots to find leaks.\r\n\r\nLogging & Flags\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --js-flags=\"--trace-gc --trace-opt --prof\"\r\nExternal Tools\r\n\r\nHeap Inspector, d8 shell for iterative testing.\r\n\r\n7. Web Workers & Service Workers\r\nWorker Contexts\r\n\r\nEach worker spawns its own V8 isolate & event loop.\r\n\r\nShared ArrayBuffer & Atomics\r\n\r\nEnables parallel JS with shared memory.\r\n\r\n8. Compatibility & Standards\r\nECMAScript Versions\r\n\r\nV8 keeps pace with ES6+ features: modules, async/await, proxies, BigInt.\r\n\r\nWebAssembly\r\n\r\nIntegrated via wasm.cc modules; both interpreter and tier-up compilation.\r\n\r\n9. Extending & Hooking In\r\nCustom Builtins\r\n\r\nAdd new functions by extending V8’s builtins in src/third_party/v8/src/builtins.\r\n\r\nInspector API\r\n\r\nEmbed the Inspector protocol in other tools or integrations.\r\n\r\nFlags & Experiments\r\n\r\nFeature-flag new JS proposals before standardization.\r\n\r\n10. Next Steps\r\nRead Modules → Storage & Cache to see how JS resources (scripts, modules) are cached.\r\n\r\nExplore Debugging → Debugging Tools for end-to-end JS debugging setups.\r\n\r\nClone and play with the d8 shell in third_party/v8/tools/d8 for hands-on experimentation.\r\n\r\n"
  },
  {
    "path": "modules/storage-cache/disk-cache-design-principles",
    "title": "Disk Cache Design Principles",
    "content": "# Disk Cache Design Principles\r\n\r\nThis deep-dive covers Chromium’s on-disk cache: its goals, on-disk format, key interfaces, and implementation notes.\r\n\r\n---\r\n\r\n## 1. Overview\r\n\r\nThe disk cache stores web-fetched resources for fast later access. Key characteristics:\r\n\r\n- **Size Bound**  \r\n  The cache must not grow without limit; an eviction algorithm decides when to remove old entries.\r\n- **Crash Resilience**  \r\n  Survives application crashes by discarding only entries in use at crash time. A full system crash may still wipe the entire cache.\r\n- **Efficient Access**  \r\n  Supports both synchronous and asynchronous operations with low latency.\r\n- **Conflict Avoidance**  \r\n  Layout prevents simultaneous-store conflicts (cache thrashing).\r\n- **Entry Removal**  \r\n  Individual entries can be removed; existing handles continue to function, and new opens fail as if the entry never existed.\r\n- **Single-threaded Assumption**  \r\n  Callers share one thread; callbacks are posted on the thread’s message loop to avoid reentrancy.\r\n\r\n---\r\n\r\n## 2. External Interfaces\r\n\r\nChromium’s cache API (in `src/net/disk_cache/disk_cache.h`) exposes:\r\n\r\n- **`disk_cache::Backend`**  \r\n  Enumerate entries, open existing or create new entries.\r\n- **`disk_cache::Entry`**  \r\n  Read/write data streams for a single resource.\r\n\r\nEach entry has a unique key (e.g., `http://example.com/favicon.ico`). Data is stored in separate streams (HTTP headers vs. payload), indexed by stream ID in `Entry::ReadData`/`WriteData`.\r\n\r\n---\r\n\r\n## 3. On-Disk Format\r\n\r\nAll cache files live under a `cache/` directory. Chromium uses at least:\r\n\r\n- **1 Index File**  \r\n  Contains a memory-mapped hash table mapping keys to addresses.\r\n- **≥4 Block-Files** (`data_n`)  \r\n  Store fixed-size blocks (e.g., 256 B). Each file grows by 1 KB-aligned increments and chains to same-size files via headers.\r\n- **Separate Files** (`f_xx`)  \r\n  Resources > 16 KB bypass block-files and live in standalone files.\r\n\r\n### 3.1 Cache Address\r\n\r\nA 32-bit value directing to:\r\n\r\n- A block-file (file number, start block, block count, block type)\r\n- A separate file (hex identifier)\r\n\r\nDefined in `disk_cache/addr.h`, it enables unified handling of diverse data.\r\n\r\n### 3.2 Index File Structure\r\n\r\nDefined in `disk_cache/disk_format.h`:\r\n\r\n```text\r\nIndexHeader\r\nHashTable (size ≥ kIndexTableSize, actual length in header.table_len)\r\n```\r\n\r\n- Memory-mapped for rapid key→address lookup (using low-order hash bits).\r\n- Header includes magic number + major/minor version; a major bump is incompatible.\r\n\r\n### 3.3 Block-File Structure\r\n\r\nAlso in `disk_cache/disk_format.h`:\r\n\r\n- **Header (8 KB)**: memory-mapped bitmap tracks up to ~64K blocks.\r\n- **Data blocks**: fixed size (e.g., 256 B). Files grow by 1 024 blocks until full, then link to a new file of same block size via `next_file`.\r\n\r\nBlocks align on 4-block boundaries to simplify allocation:\r\n\r\n1. A record uses 1–4 contiguous blocks.  \r\n2. Allocations jump to the next aligned region if needed.  \r\n\r\nHeader fields `empty_slots` and `hints` optimize allocation and detect crashes mid-update.\r\n\r\n### 3.4 Cache Entry Layout\r\n\r\nEach entry splits into two structures:\r\n\r\n- **`EntryStore`** (1–4 blocks of 256 B)  \r\n  Stores key hash, stream addresses, pointer to next collision, and optional out-of-line key pointer.\r\n- **`RankingsNode`** (36 B, its own block-files)  \r\n  Tracks eviction metadata; marked in-use while open.\r\n\r\n### 3.5 The Big Picture\r\n\r\nA typical cache has:\r\n\r\n1. One index file  \r\n2. Multiple block-files (256 B, 1 KB, 4 KB) chained by size  \r\n3. Separate files for large payloads\r\n\r\nEntries link across streams and files via cache addresses.  \r\n![](../../../img/modules/the-big-picture.png)\r\n\r\n---\r\n\r\n## 4. Implementation Notes\r\n\r\n### 4.1 Two Backends\r\n\r\n- **Disk-based** (`disk_cache/backend_impl.cc`, `entry_impl.cc`)  \r\n- **In-memory** (`disk_cache/mem_backend_impl.cc`) for Incognito mode\r\n\r\nCache types (media, AppCache, general) share APIs but may differ in eviction.\r\n\r\n### 4.2 Lower-Level I/O\r\n\r\nOS abstractions in `disk_cache/file.h` & `mapped_file.h`.  \r\n`disk_cache::BlockFiles` manages block-file access.  \r\n`StorageBlock<T>` template handles loading/storing of `EntryStore` or `RankingsNode`.\r\n\r\n### 4.3 Eviction\r\n\r\n- **Ranking lists**: `disk_cache/rankings` (and `mem_rankings`).  \r\n- **Eviction logic**: `disk_cache/eviction` implements LRU and reuse/age-aware variants.  \r\n- **Transactions**: ensure consistency across crashes.  \r\n- **Multiple lists** by reuse frequency plus a “recently evicted” list.\r\n\r\n### 4.4 Buffering\r\n\r\n- Buffers up to 16 KB per stream before first disk write.  \r\n- Grows to 1 MB or a global cap.  \r\n- Minimizes disk I/O for small entries and computes record size for address allocation.\r\n\r\n### 4.5 Deleting Entries\r\n\r\n- `Doom*()` methods mark entries for deferred deletion after all handles close.  \r\n- Doomed entries removed from index; new opens create fresh entries.\r\n\r\n### 4.6 Enumeration\r\n\r\n- Example: `URLRequestViewCacheJob` iterates entries (order not guaranteed, can be slow).\r\n\r\n### 4.7 Sparse Data\r\n\r\n- Supports two streams: regular + sparse.  \r\n- Sparse data split into child entries linked from a parent (`disk_cache/sparse_control`).\r\n\r\n### 4.8 Dedicated Cache Thread\r\n\r\n- A background cache thread handles file I/O, offloading the browser I/O thread (IPC/UI).  \r\n- Uses task posting (`in_flight_io` / `in_flight_backend_io`).  \r\n- No locking: some calls (e.g. `GetDataSize`) may race with writes.\r\n\r\n---\r\n\r\n## 5. Data Integrity\r\n\r\nBalancing performance vs. crash resilience:\r\n\r\n- Leverages OS file-cache; no journaling to avoid complexity.  \r\n- Memory-mapped headers flush latest state on crash.  \r\n- On system crash, eviction lists may corrupt; the fallback is to discard the cache rather than risk inconsistency.\r\n\r\n*End of Disk Cache Design Principles Deep Dive*\r\n\r\n"
  },
  {
    "path": "introduction/overview",
    "title": "Chromium Knowledge Base Overview",
    "content": "# Chromium Knowledge Base Overview\r\n\r\nWelcome to the Chromium Knowledge Base! This site is designed to help you navigate, understand, and contribute to Chromium’s massive open-source codebase.\r\n\r\n---\r\n\r\n## 1. What Is Chromium?\r\n\r\n- **Definition**  \r\n  A brief description: “Chromium is the open-source browser project that forms the basis for Google Chrome, Microsoft Edge, and others.”\r\n- **Goals**  \r\n  – Speed & performance  \r\n  – Security & sandboxing  \r\n  – Cross-platform support  \r\n- **History & Community**  \r\n  – Origin (started by Google in 2008)  \r\n  – How the community contributes (monorail, Gerrit, mailing lists)  \r\n\r\n---\r\n\r\n## 2. Why Explore the Source?\r\n\r\n- **Learning**  \r\n  – Modern C++ best practices  \r\n  – Multi-process architecture  \r\n- **Debugging & Tuning**  \r\n  – Custom builds & profiling  \r\n- **Contributing**  \r\n  – Filing bugs  \r\n  – Submitting patches  \r\n\r\n---\r\n\r\n## 3. High-Level Architecture\r\n\r\nAn at-a-glance map:  \r\n- **Browser process**  \r\n- **Renderer processes**  \r\n- **GPU process**  \r\n- **Utility processes**  \r\n\r\n_(Link to detailed sections on Process Model, Render Pipeline, etc.)_\r\n\r\n---\r\n\r\n## 4. Directory Layout\r\n\r\nA quick tour of the top-level folders in `src/`:  \r\n```text\r\nsrc/\r\n├── chrome/               # Browser‐specific UI and glue\r\n├── content/              # Common browser/renderer logic\r\n├── third_party/          # External libraries (Blink, V8, Skia…)\r\n├── net/                  # Networking layer (HTTP, QUIC…)\r\n├── ui/                   # Cross-platform UI toolkit\r\n└── tools/                # Build, lint, codegen, docs…\r\n"
  },
  {
    "path": "getting-started/setup-build",
    "title": "Setup & Build",
    "content": "# Setup & Build\r\n\r\nThis guide shows you how to fetch, build, and run Chromium from source on **Linux**, **macOS**, or **Windows**.\r\n\r\n---\r\n\r\n## 1. Prerequisites\r\n\r\nBefore you begin, make sure you have:\r\n\r\n- A supported OS:\r\n  - **Linux**: Ubuntu 20.04+ or equivalent\r\n  - **macOS**: 10.15+ (Intel or Apple Silicon)\r\n  - **Windows**: 10 (x64)\r\n- **Disk space**: At least 30 GB free\r\n- **RAM**: ≥ 8 GB (16 GB+ recommended)\r\n- **Tools**:\r\n  - **Python 3.8+** (for build scripts)\r\n  - **Git** (2.25+)\r\n  - **Depot Tools** (Google’s repo of Chromium helper scripts)\r\n\r\n### 1.1 Installing Depot Tools\r\n\r\n```bash\r\n# Clone Depot Tools somewhere in your PATH:\r\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git ~/depot_tools\r\nexport PATH=\"$PATH:$HOME/depot_tools\"\r\n# (Add the export line to your shell rc: ~/.bashrc, ~/.zshrc, or PowerShell profile)\r\n```\r\n\r\n## 2. Fetching the Source\r\n\r\n### 2.1 Create a working directory:\r\n\r\n```bash\r\nmkdir -p ~/chromium && cd ~/chromium\r\n```\r\n\r\n### 2.2 Fetch the code:\r\n\r\n```bash\r\nfetch --nohooks chromium\r\ncd src\r\n```\r\n\r\n### 2.3 Install additional hooks:\r\n\r\n```bash\r\ngclient sync --with_branch_heads --with_tags\r\n```\r\n\r\n## 3. Configuring Your Build\r\n\r\nChromium uses GN for meta-build configuration and Ninja as the build engine.\r\n\r\n### 3.1 Generate build files:\r\n\r\n```bash\r\ngn gen out/Default --args='\r\n  is_debug=false            # or true for a debug build\r\n  symbol_level=1            # 0=no symbols, 1=debug symbols only\r\n  is_component_build=true   # modules are built as shared libs\r\n'\r\n```\r\n\r\n### 3.2 Common args:\r\n\r\n```text\r\nis_debug=true               # Debug build (with assertions & logging)\r\nis_official_build=false     # Disable Google-branded splash screens\r\nenable_nacl=false           # Disable Native Client (optional)\r\nremove_webcore_debug_symbols=true  # Strip extra symbols\r\n```\r\n\r\n### 4. Building\r\n\r\nFrom the src/ directory:\r\n\r\n```bash\r\nninja -C out/Default chrome\r\n```\r\n\r\n- -C out/Default tells Ninja where your build files live.\r\n- chrome is the target; you can also build content_shell, browser_tests, etc.\r\n\r\nTip: On multi-core machines you can speed up builds:\r\n\r\n```bash\r\nninja -C out/Default -j8\r\n```\r\n\r\n(where 8 ≈ number of CPU cores)\r\n\r\n## 5. Running Your Build\r\n\r\n- Linux & macOS:\r\n\r\n```bash\r\nout/Default/chrome        # Launches your custom build\r\n```\r\n\r\n- Windows (PowerShell):\r\n\r\n```powershell\r\n.\\out\\Default\\chrome.exe\r\n```\r\n\r\nYou can pass any Chromium CLI flags, for example:\r\n\r\n```bash\r\nout/Default/chrome --enable-logging --v=1\r\n```\r\n\r\n## 6. Iterating & Incremental Builds\r\n\r\nAfter code changes, simply rerun:\r\n\r\n```bash\r\nninja -C out/Default\r\n```\r\n\r\nNinja only rebuilds what’s necessary, so incremental iterations are fast.\r\n\r\n## 7. Common Issues & Troubleshooting\r\n\r\nSymptom\tPossible Fix\r\nfetch is not found\tEnsure depot_tools is in your PATH\r\ngclient sync errors out\tDelete src/.gclient_entries and retry\r\nGN complains about bad args\tRun gn args out/Default --list to verify flags\r\nOut-of-memory during build\tLower -j jobs or increase swap space\r\n\r\n## 8. Next Steps\r\n\r\n- Dive into Project Layout: see how src/ is organized\r\n- Explore Architecture → Process Model: understand multi-process design\r\n- Try a Debug Build and play with logging flags\r\n\r\n"
  },
  {
    "path": "getting-started/project-layout",
    "title": "Project Layout",
    "content": "# Project Layout\r\n\r\nChromium’s source tree is vast. This guide gives you a high-level tour of the most important directories and files so you know where to look for specific functionality.\r\n\r\n---\r\n\r\n## 1. Top-Level Structure\r\n\r\n```text\r\n<repo-root>/\r\n├── .gclient                 # gclient configuration\r\n├── .gitignore               # files to ignore in Git\r\n├── DEPS                      # external dependencies manifest\r\n├── LICENSE                  # project license\r\n├── README.md                # high-level overview & links\r\n├── chrome/                  # browser UI, Chrome‐specific code\r\n├── content/                 # core browser/renderer logic\r\n├── build/                   # build scaffolding & CI scripts\r\n├── tools/                   # code generators, formatters, linting\r\n├── third_party/             # bundled external libraries\r\n├── ui/                      # cross‐platform UI toolkit\r\n└── src/                     # actual Chromium source (see §2)\r\n.gclient / DEPS\r\nDefine how to fetch submodules (including src/), and pin versions of third-party dependencies.\r\n\r\nchrome/ & content/\r\nchrome/ holds Chrome‐flavored UI and high-level glue; content/ is the shared browser/renderer engine.\r\n\r\nbuild/\r\nGN/Ninja helper files, presubmit scripts, and CI definitions.\r\n\r\ntools/\r\nCode generators (e.g. protobuf), formatters (e.g. clang‐format), and various scripts.\r\n\r\nthird_party/\r\nPrebuilt or source-checked libraries like V8, Skia, ICU, etc.\r\n\r\n2. The src/ Directory\r\nAfter running fetch chromium, most of the code lives in src/. Its top‐level layout:\r\n\r\ntext\r\nCopy\r\nEdit\r\nsrc/\r\n├── chrome/            # Chrome browser shell & UI centric code\r\n├── cc/                # Compositor & layered rendering\r\n├── content/           # Blink/V8 embedder & shared browser logic\r\n├── gpu/               # GPU process, drivers, and command buffer\r\n├── net/               # Networking stack (HTTP, QUIC, proxies)\r\n├── ui/                # Cross-platform abstraction for windows, events\r\n├── third_party/       # Mirrors of upstream projects (Chromium‐specific)\r\n├── tools/             # Build‐time codegen & helper scripts\r\n└── components/        # Reusable modules (e.g. feed, payments)\r\nchrome/\r\nEntry points, Chrome UI (tabs, omnibox, menus), and platform‐specific glue.\r\n\r\ncontent/\r\nIntegrates Blink (rendering) and V8 (JS), plus IPC, navigation, and resource loading.\r\n\r\ncc/ & gpu/\r\nHandle compositing layers and talking to the GPU process/drivers respectively.\r\n\r\nnet/\r\nImplements HTTP(S), QUIC, SPDY, caching, cookies, proxy resolution, etc.\r\n\r\nui/\r\nAbstracts windowing, input events, and vector graphics across platforms.\r\n\r\ncomponents/\r\nHigher-level features decoupled from Chrome (e.g. autofill, payments, feed).\r\n\r\n3. Build Outputs & Intermediates\r\ntext\r\nCopy\r\nEdit\r\nout/\r\n└── Default/           # Your default build directory\r\n    ├── obj/           # Intermediate object files\r\n    ├── chrome         # Built executable (or .exe on Windows)\r\n    ├── lib*.so/.dll   # Shared libraries if component build enabled\r\n    └── *.ninja_log    # Build logs\r\nYou generate this with gn gen out/Default.\r\n\r\nNinja writes objects under obj/ and outputs binaries at the top level.\r\n\r\n4. Configuration & Metadata\r\nBUILD.gn files\r\nScattered throughout the tree, define targets (libraries, executables).\r\n\r\n.gn files\r\nTemplates for code formatting, license headers, or tooling.\r\n\r\ngn args\r\nControls build flags (debug vs. release, component vs. monolithic).\r\n\r\nPRESUBMIT.py\r\nHooks run before uploading patches to catch style/build errors.\r\n\r\n5. Writing & Finding Docs\r\nInline README.md\r\nMany subdirectories have their own README.md explaining local conventions.\r\n\r\ndocs/ folder\r\nLonger design docs and architecture overviews (e.g. process model, sandbox).\r\n\r\nAmber-style comments\r\nLook for //-style comments at the tops of files or functions for quick context.\r\n\r\n6. How to Navigate\r\nDirectory ↔ Feature\r\n\r\nNeed networking? Start in src/net/.\r\n\r\nWant to tweak the UI widget? Look under src/ui/gtk/ or src/ui/views/.\r\n\r\nBUILD.gn ↔ Source\r\n\r\nUse find . -name BUILD.gn | xargs grep <target> to locate the definition.\r\n\r\nCode Search\r\n\r\nUse https://source.chromium.org for full-text search of identifiers, commits, and reviews.\r\n\r\nWith this map in hand, you’ll know exactly where to dive for the next deep-dive in our KB.\r\n\r\nyaml\r\nCopy\r\nEdit\r\n\r\n---\r\n\r\n**Usage tips:**\r\n- Link each directory name in this doc to its detailed KB article (once written).\r\n- Update the examples when folder names change (Chromium reorganizes periodically).\r\n- Encourage readers to bookmark the online code search for rapid lookup."
  },
  {
    "path": "getting-started/code-directory-structure",
    "title": "Code Directory Structure",
    "content": "# Code Directory Structure\r\n\r\nThis page expands on *Project Layout* with a directory-by-directory tour of Chromium’s `src/` tree.\r\n\r\n## Top-Level Folders\r\n\r\n- `chrome/` – UI shell, platform glue  \r\n- `content/` – embedder for Blink/V8  \r\n- `third_party/` – bundled libraries (V8, Skia…)  \r\n- `build/` & `tools/` – build scripts, codegen, lint  \r\n- `net/` – networking stack  \r\n- `ui/` – cross-platform toolkit  \r\n- …\r\n\r\n_…and so on, pulling in the detailed breakdown from the article…_\r\n\r\n**See also:**  \r\n- [Project Layout](project-layout.md) for high-level context  \r\n- [Architecture → Browser Components](../architecture/browser-components.md) for how these pieces fit at runtime"
  },
  {
    "path": "debugging/debugging-tools",
    "title": "Debugging Tools",
    "content": "# Debugging Tools\r\n\r\nWhen working on Chromium you’ll rely on a variety of built-in tools and flags to inspect, profile, and diagnose both browser and renderer behavior. This guide surveys the most useful techniques, commands, and UIs for catching bugs, measuring performance, and analyzing crashes.\r\n\r\n---\r\n\r\n## 1. Logging & Verbose Flags\r\n\r\nChromium uses VLOG and `--v` logging levels throughout. To enable:\r\n\r\n```bash\r\nout/Default/chrome \\\r\n  --enable-logging=stderr \\\r\n  --v=1             # basic INFO-level logs\r\n  --vmodule=\"*.cc=2\"  # more verbose logging for specific source files\r\nLevels\r\n\r\n--v=0 (WARN & above)\r\n\r\n--v=1 (INFO)\r\n\r\n--v=2..5 (DEBUG with increasing detail)\r\n\r\nRedirecting\r\n\r\n--log-net-log=netlog.json to capture network internals\r\n\r\n--log-file=chrome.log to write all logs to a file\r\n\r\n2. Crash Reporting & Breakpad\r\nChromium’s built-in crash handler (Crashpad on Windows/macOS):\r\n\r\nCrash dumps are written under out/Default/crashes/ by default.\r\n\r\nSymbolization:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/format_symbolized_stacktrace \\\r\n  --symbols-dir=./out/Default \\\r\n  crashes/<dump>.dmp\r\nIntegration\r\n\r\nUnder Git workflows you can upload to a Breakpad server or run locally with minidump_stackwalk.\r\n\r\n3. Chrome Developer Tools\r\nAccessible via F12 or chrome://inspect, DevTools offers:\r\n\r\nElements & Styles\r\n\r\nLive DOM/CSS inspection and editing\r\n\r\nConsole\r\n\r\nRuntime errors, logging APIs, and JS REPL\r\n\r\nSources\r\n\r\nSet breakpoints in JS, step through V8 bytecode/native code\r\n\r\nPerformance\r\n\r\nRecord CPU & heap profiles; “flamethrower” view of main-thread tasks\r\n\r\nNetwork\r\n\r\nInspect HTTP headers, payloads, timing breakdowns\r\n\r\n4. Tracing & Flame Charts\r\n4.1 chrome://tracing\r\nRecord IPC, rendering, and thread-level events.\r\n\r\nFilter by categories (--trace-startup, --trace-mem).\r\n\r\nExport to JSON and view in the Trace Event Profiling Tool.\r\n\r\n4.2 Perfetto (Android & Desktop)\r\n--enable-perfetto and chrome://perfetto for system-wide tracing.\r\n\r\nCaptures kernel, GPU, and user-space events together.\r\n\r\n5. Memory & Heap Analysis\r\n5.1 Heap Profiling\r\nJS heap: use DevTools’ Memory tab → Heap snapshots.\r\n\r\nNative heap:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --enable-heap-checking --heap-profiler\r\ngenerates .heap files, viewable with pprof or Chrome’s heap profiler UI.\r\n\r\n5.2 Address Sanitizer (ASan)\r\nEnable with GN args:\r\n\r\ngn\r\nCopy\r\nEdit\r\nis_asan = true\r\nDetects use-after-free, buffer-overflow errors at runtime.\r\n\r\n5.3 Leak Sanitizer (LSan) & Thread Sanitizer (TSan)\r\nSimilar flags (is_lsan, is_tsan) to catch leaks and data races.\r\n\r\n6. CPU Profiling\r\nSampling profiler via DevTools Performance → CPU.\r\n\r\nIn-process profiler:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --prof\r\nwrites isolate-0x*.log for V8 CPU sampling.\r\n\r\nExternal tools\r\n\r\nLinux: perf record -g -- out/Default/chrome\r\n\r\nmacOS: Instruments → Time Profiler\r\n\r\n7. GDB & Native Debugging\r\nLaunch Chrome under GDB:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngdb --args out/Default/chrome --enable-logging=stderr\r\nSet breakpoints in C++ (content/browser/..., render_process_main.cc).\r\n\r\nUse thread apply all bt to get stacks from all threads.\r\n\r\n8. Network & Protocol Inspection\r\nchrome://net-export to record HTTP/QUIC traces; then view in NetLog Viewer.\r\n\r\nchrome://webrtc-internals for WebRTC peer-connection stats.\r\n\r\nWireshark: enable --log-net-log and import the JSON trace.\r\n\r\n9. Automated Tests & Debug Builds\r\nDebug Builds (is_debug=true) include assertions and symbol info.\r\n\r\nUnit / Browser Tests:\r\n\r\nbash\r\nCopy\r\nEdit\r\nautoninja -C out/Default content_unittests\r\nout/Default/content_unittests --gtest_filter=YourTest.*\r\nInstrumentation Tests run via run_local_tests.py (Android).\r\n\r\n10. Remote & Headless Debugging\r\nRemote Debugging\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --remote-debugging-port=9222\r\nthen connect DevTools to localhost:9222.\r\n\r\nHeadless Mode\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --headless --dump-dom https://example.com\r\n11. Common Pitfalls & Tips\r\nStale binaries: remember to gn gen after changing args.\r\n\r\nCache issues: use --disable-application-cache or --user-data-dir=<tmp> to avoid profile interference.\r\n\r\nDevTools hooks: use --remote-debugging-allow-hosts=* when debugging CI environments.\r\n\r\n12. Next Steps\r\nPair Traces → Flame Charts with CPU profiles to correlate jank.\r\n\r\nUse ASan/TSan in your CI builds to catch low-level bugs early.\r\n\r\nIntegrate --enable-heap-checking into nightly runs for memory leak detection."
  },
  {
    "path": "debugging/crash-reports",
    "title": "Crash Reports in Chromium",
    "content": "# Crash Reports in Chromium\r\n\r\nCrash reports are an essential part of debugging and maintaining Chromium. They provide detailed information about crashes, helping developers identify and resolve issues efficiently.\r\n\r\n---\r\n\r\n## Generating a Crash Report\r\n\r\nTo generate a crash report in Chromium:\r\n\r\n1. Open Chromium and access the URL `http://crash/` to trigger the generation of a crash report.\r\n2. The crash report will be saved in the following locations:\r\n   - **Linux**: `~/.config/google-chrome/Crash Reports/`\r\n   - **Windows/Mac**: `/path/to/profile/Crash Reports`\r\n\r\n### Preventing Crash Reports from Being Sent (Linux)\r\n\r\nOn Linux platforms, you can prevent crash reports from being sent to the server by setting the `CHROME_HEADLESS` environment variable. For example:\r\n\r\n```bash\r\n$ env CHROME_HEADLESS=1 ./out/Debug/chrome-wrapper\r\n```\r\n\r\nThis ensures that crash reports are generated locally without being uploaded to the server.\r\n\r\n## Parsing a Crash Report\r\nCrash reports in Chromium can be parsed using the minidump_stackwalk tool. This tool processes the .dmp files generated during a crash and provides a readable stack trace.\r\n\r\nSteps to Parse a Crash Report:\r\nUse the following command to parse a crash report:\r\n```bash\r\n$ minidump_stackwalk <report-name>.dmp\r\n```\r\nFor crash reports generated on Linux, you may need to remove the file header before parsing. To do this:\r\nOpen the .dmp file in a text editor.\r\nSearch for the MDMP character sequence.\r\nDelete the header before the MDMP sequence.\r\n\r\n## References\r\nFor more information on decoding and handling crash reports in Chromium, refer to the following resources:\r\n\r\n![Decoding Crash Dumps](https://www.chromium.org/developers/decoding-crash-dumps)\r\n![Linux Crash Dumping](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/linux_crash_dumping.md)\r\n\r\n## Additional Notes\r\nCrash Report Locations:\r\nEnsure you have the correct permissions to access the crash report directories.\r\nLicensing:\r\nThe original content referenced in this document is licensed under ![CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/)."
  },
  {
    "path": "debugging/chrome-internals-urls",
    "title": "Chrome Internal URLs (Pseudo-URLs)",
    "content": "# Chrome Internal URLs (Pseudo-URLs)\r\n\r\nChrome provides a set of internal URLs (pseudo-URLs) that allow developers and advanced users to access various debugging, configuration, and diagnostic tools. These URLs are accessible by typing them into the Chrome address bar.\r\n\r\n---\r\n\r\n## Common Chrome Internal URLs\r\n\r\n### 1. Accessibility\r\n- **URL**: `chrome://accessibility/`\r\n- **Description**: Displays accessibility analysis tools. By default, accessibility is off. Clicking \"Show Accessibility Tree\" displays the analysis tree.\r\n\r\n---\r\n\r\n### 2. Application Cache\r\n- **URL**: `chrome://appcache-internals/`\r\n- **Description**: Displays a list of all application cache paths.\r\n\r\n---\r\n\r\n### 3. Installed Apps\r\n- **URL**: `chrome://apps/`\r\n- **Description**: Lists all currently installed Chrome apps.\r\n\r\n---\r\n\r\n### 4. Blob Files\r\n- **URL**: `chrome://blob-internals/`\r\n- **Description**: Displays the current list of internal blob files.\r\n\r\n---\r\n\r\n### 5. Bookmarks\r\n- **URL**: `chrome://bookmarks/`\r\n- **Description**: Opens the Bookmark Manager.\r\n\r\n---\r\n\r\n### 6. Cache\r\n- **URL**: `chrome://cache/`\r\n- **Description**: Displays a list of cached URLs. Clicking a URL shows detailed information about the cache file, including type, encoding, expiration time, and binary content.\r\n\r\n---\r\n\r\n### 7. Chrome About Page\r\n- **URL**: `chrome://chrome/`\r\n- **Description**: Displays the current Chrome version information.\r\n\r\n---\r\n\r\n### 8. Chrome URL List\r\n- **URL**: `chrome://chrome-urls/`\r\n- **Description**: Displays a list of all available Chrome pseudo-URLs.\r\n\r\n---\r\n\r\n### 9. Components\r\n- **URL**: `chrome://components/`\r\n- **Description**: Lists Chrome components. You can check for updates and download new versions if available.\r\n\r\n---\r\n\r\n### 10. Crashes\r\n- **URL**: `chrome://crashes/`\r\n- **Description**: Displays the current Chrome crash reports. Crash reporting must be enabled for this to work. Refer to [Google Support](https://support.google.com/chrome/answer/96817) for enabling crash reporting.\r\n\r\n---\r\n\r\n### 11. Device Logs\r\n- **URL**: `chrome://device-log/`\r\n- **Description**: Displays device logs. Use `chrome://device-log/?refresh=seconds` to enable automatic refresh.\r\n\r\n---\r\n\r\n### 12. Discards\r\n- **URL**: `chrome://discards/`\r\n- **Description**: Displays discarded tab pages, sorted by priority. Tabs with the lowest priority may be discarded if memory usage exceeds available resources.\r\n\r\n---\r\n\r\n### 13. DNS\r\n- **URL**: `chrome://dns/`\r\n- **Description**: Displays DNS pre-resolution and TCP pre-connection data. If disabled, you can enable \"Pre-fetch resources for faster loading of web pages\" in settings.\r\n\r\n---\r\n\r\n### 14. Downloads\r\n- **URL**: `chrome://downloads/`\r\n- **Description**: Opens the Downloads page.\r\n\r\n---\r\n\r\n### 15. Extensions\r\n- **URL**: `chrome://extensions/`\r\n- **Description**: Lists all installed extensions.\r\n\r\n---\r\n\r\n### 16. Experimental Features\r\n- **URL**: `chrome://flags/`\r\n- **Description**: Displays a list of experimental features that can be enabled or disabled.\r\n\r\n---\r\n\r\n### 17. GPU Information\r\n- **URL**: `chrome://gpu/`\r\n- **Description**: Displays GPU information, including hardware acceleration status and GPU memory buffer details.\r\n\r\n---\r\n\r\n### 18. Histograms\r\n- **URL**: `chrome://histograms/`\r\n- **Description**: Displays histogram data for browser performance metrics.\r\n\r\n---\r\n\r\n### 19. IndexedDB Internals\r\n- **URL**: `chrome://indexeddb-internals/`\r\n- **Description**: Displays a list of internal IndexedDB instances, including paths, modification times, and database sizes.\r\n\r\n---\r\n\r\n### 20. Inspect Devices\r\n- **URL**: `chrome://inspect/`\r\n- **Description**: Detects devices, pages, extensions, and apps. Displays all currently open tabs under the \"Pages\" tab, with an option to inspect them using developer tools.\r\n\r\n---\r\n\r\n### 21. Memory Usage\r\n- **URL**: `chrome://memory/`\r\n- **Description**: Redirects to `chrome://memory-redirect/`, showing memory usage for each process, including private, shared, and total memory.\r\n\r\n---\r\n\r\n### 22. Network Internals\r\n- **URL**: `chrome://net-internals/`\r\n- **Description**: Displays network-related information, including proxy settings, DNS cache, and timing data.\r\n\r\n---\r\n\r\n### 23. Plugins\r\n- **URL**: `chrome://plugins/`\r\n- **Description**: Displays information about installed plugins. (Note: This URL is deprecated in newer versions of Chrome.)\r\n\r\n---\r\n\r\n### 24. Print\r\n- **URL**: `chrome://print/`\r\n- **Description**: Opens the browser's print dialog.\r\n\r\n---\r\n\r\n### 25. Sync Internals\r\n- **URL**: `chrome://sync-internals/`\r\n- **Description**: Displays synchronization information for Chrome accounts, including last sync time, token requests, and event logs.\r\n\r\n---\r\n\r\n### 26. System Information\r\n- **URL**: `chrome://system/`\r\n- **Description**: Displays diagnostic data, including Chrome version, OS version, memory usage, and USB device information.\r\n\r\n---\r\n\r\n### 27. Tracing\r\n- **URL**: `chrome://tracing/`\r\n- **Description**: Allows recording and monitoring of Chrome's performance data.\r\n\r\n---\r\n\r\n### 28. User Actions\r\n- **URL**: `chrome://user-actions/`\r\n- **Description**: Displays a list of user actions, including the type of operation and when it occurred.\r\n\r\n---\r\n\r\n### 29. Version Information\r\n- **URL**: `chrome://version/`\r\n- **Description**: Displays detailed version information for Chrome, including the JavaScript engine version, Flash plugin version, and user agent string.\r\n\r\n---\r\n\r\n## References\r\n\r\nFor a complete list of Chrome internal URLs, visit `chrome://chrome-urls/` in your browser.\r\n\r\n---\r\n\r\n*This document consolidates information from various sources, including the Chromium documentation and external references.*"
  },
  {
    "path": "contributing/contributing",
    "title": "Test# Contributing Guide",
    "content": "# Test# Contributing Guide\r\n\r\nThank you for your interest in contributing to Chromium! This guide walks you through our workflow, from cloning the repo to landing your first patch.\r\n\r\n---\r\n\r\n## 1. Getting Ready\r\n\r\n### 1.1. Prerequisites\r\n\r\n- You’ve [set up and built Chromium][setup-build].  \r\n- You have a Google account and have signed the [Chromium Contributor License Agreement (CLA)][cla].  \r\n- On Linux/macOS you have Python 3 and Git installed; on Windows you’re using PowerShell with Depot Tools in your `PATH`.\r\n\r\n### 1.2. Configure Your Environment\r\n\r\n1. **Clone with Depot Tools**  \r\n   ```bash\r\n   mkdir -p ~/chromium && cd ~/chromium\r\n   fetch --nohooks chromium\r\n   cd src\r\n   gclient sync --with_branch_heads --with_tags\r\nSet your Git identity\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit config --global user.name \"Your Name\"\r\ngit config --global user.email \"you@example.com\"\r\nEnable Gerrit SSH\r\n\r\nUpload your SSH public key in the Gerrit UI.\r\n\r\nTest: ssh -p 29418 chromium-review.googlesource.com\r\n\r\n2. Coding Conventions\r\nWe follow the Chromium C++ Style Guide and JavaScript Style Guide. Key points:\r\n\r\nIndent with 2 spaces (no tabs).\r\n\r\nLine length ≤ 80 chars for code, ≤ 100 for comments.\r\n\r\nBrace placement:\r\n\r\ncpp\r\nCopy\r\nEdit\r\nif (condition) {\r\n  // …\r\n} else {\r\n  // …\r\n}\r\nNaming:\r\n\r\nClasses & structs: CamelCase\r\n\r\nVariables & functions: lower_case_with_underscores\r\n\r\nComments: use // for short notes, /* … */ for longer blocks.\r\n\r\nRun clang-format before submitting.\r\n\r\n3. Commit Message Format\r\nA good commit message looks like:\r\n\r\nbash\r\nCopy\r\nEdit\r\n[component] Brief summary (50 chars or less)\r\n\r\nMore detailed description of your change:\r\n- What problem it solves\r\n- How you tested it\r\n- Any known limitations\r\n\r\nBug: https://bugs.chromium.org/p/chromium/issues/detail?id=123456\r\nReviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/987654\r\nTest: manual steps or automated test name\r\nPrefix each message with [area], e.g. [content], [net], [ui].\r\n\r\nInclude a Bug: link if you’re fixing or closing an issue.\r\n\r\nMention tests in the Test: line.\r\n\r\n4. Presubmit & Tests\r\nBefore uploading:\r\n\r\nRun presubmit checks\r\n\r\nbash\r\nCopy\r\nEdit\r\ntools/lint/lint.py\r\ntools/clang/scripts/run-clang-format.py --shrink-to-fit\r\nRun unit and browser tests relevant to your change:\r\n\r\nbash\r\nCopy\r\nEdit\r\nautoninja -C out/Default my_test_target\r\nout/Default/my_test_target --gtest_filter=MyTestSuite.*\r\nManual smoke test\r\n\r\nLaunch with your change: out/Default/chrome\r\n\r\nVerify basic browser startup, navigation, and any feature you touched.\r\n\r\n5. Code Review Workflow\r\nCommit & Upload\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit checkout -b my-feature-branch\r\ngit commit -a\r\ngit cl upload\r\nReviewer Feedback\r\n\r\nAddress comments by amending your commit:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit commit --amend\r\ngit cl upload --replace\r\nGetting LGTM\r\nOnce two reviewers give LGTM and CQ+1 passes, your change will land automatically.\r\n\r\n6. Working with Gerrit\r\nView your changes:\r\nhttps://chromium-review.googlesource.com/q/status:open+owner:self\r\n\r\nCherry-picking / rebasing:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit fetch https://chromium.googlesource.com/chromium/src refs/changes/54/12354/2 && git cherry-pick FETCH_HEAD\r\nUndoing a landed CL:\r\nUpload a revert by clicking “Revert Change” in the Gerrit UI.\r\n\r\n7. Troubleshooting & Common Pitfalls\r\nPresubmit failures\r\n\r\nCheck the Buildbucket logs for style or test errors.\r\n\r\nMerge conflicts\r\n\r\nRebase onto main:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit fetch origin main && git rebase origin/main\r\nSlow builds\r\n\r\nUse autoninja -j<N> matching your CPU cores.\r\n\r\n8. Beyond Code\r\nDesign Documents\r\n\r\nFor large features, submit a design doc under docs/ and get early feedback.\r\n\r\nLocalization\r\n\r\nUI strings live in chrome/app/resources/; use l10n tools to extract/update translations.\r\n\r\nDocumentation\r\n\r\nKeep inline /README.md files up to date in each directory you touch.\r\n\r\n9. Getting Help & Community\r\nMailing Lists: chromium-dev@chromium.org\r\n\r\nIRC/Slack: channels listed on the Chromium Community wiki\r\n\r\nWeekly Office Hours: check the Chromium Calendar\r\n\r\n10. Next Steps\r\nRead Getting Started → Project Layout to orient yourself in the tree.\r\n\r\nPick a Good First Issue and try submitting a small fix.\r\n\r\nCelebrate landing your first commit—welcome to the Chromium community!\r\n\r\nHappy coding!\r\n\r\narduino\r\nCopy\r\nEdit\r\n\r\nThis guide will give newcomers a clear path: set up their environment, follow style and commit guidelines, run tests, and navigate Chromium’s Gerrit-based review process. Let me know if you’d like any tweaks or additions!"
  },
  {
    "path": "architecture/render-pipeline",
    "title": "Render Pipeline",
    "content": "# Render Pipeline\r\n\r\nChromium’s render pipeline transforms HTML, CSS and JS into pixels on your screen. In this article we’ll cover each major stage, the threads involved, and how Chromium optimizes for smooth, high-performance rendering.\r\n\r\n---\r\n\r\n## 1. Overview & Motivation\r\n\r\n- **Goals**  \r\n  - **Speed**: keep 60 FPS (or higher) on modern devices  \r\n  - **Smoothness**: avoid jank by minimizing main-thread work per frame  \r\n  - **Efficiency**: only repaint and composite what changed  \r\n- **Key Processes**  \r\n  - **Browser Process**: coordinates navigation & input  \r\n  - **Renderer Process**: does parsing, style, layout, paint  \r\n  - **GPU Process**: handles compositing & rasterization\r\n\r\n*(Link back to [Architecture → Process Model](../process-model.md) for IPC & sandbox context.)*\r\n\r\n---\r\n\r\n## 2. Stage 1 – Document Parsing & DOM Construction\r\n\r\n1. **HTML Tokenizer**  \r\n   - Splits raw bytes into tokens  \r\n2. **DOM Tree Builder**  \r\n   - Builds a tree of `Node` objects  \r\n   - Handles `<script>` tags: may pause parsing for execution  \r\n3. **Incremental Loading**  \r\n   - Streaming parser allows progressive rendering  \r\n\r\n```text\r\nHTML → [Tokenizer] → Tokens → [Parser] → DOM Tree\r\n3. Stage 2 – CSS Style Resolution\r\nCSSOM Build\r\n\r\nParses stylesheets into a CSSOM tree\r\n\r\nStyle Matching\r\n\r\nMatches selectors against DOM nodes\r\n\r\nComputes ResolvedStyle for each node\r\n\r\nInheritance & Computed Values\r\n\r\nPropagate font, color, etc.\r\n\r\nCalculate final numeric values (px, em, rem)\r\n\r\ntext\r\nCopy\r\nEdit\r\nCSS → [Tokenizer] → CSSOM → [Style Resolver] + DOM → Styled Tree\r\n4. Stage 3 – Layout (Reflow)\r\nBox Tree Construction\r\n\r\nWraps styled nodes into layout boxes (block, inline, etc.)\r\n\r\nFlow & Positioning\r\n\r\nComputes sizes & positions based on box model, floats, flex, grid\r\n\r\nFragmentation\r\n\r\nSplits content across lines, pages, columns\r\n\r\nThread: main thread\r\n\r\nOutput: LayoutObject tree with geometry\r\n\r\n5. Stage 4 – Paint Preparation\r\nPaint Record Generation\r\n\r\nTranslates LayoutObject into paint commands (drawRect, drawText, etc.)\r\n\r\nDisplay List Creation\r\n\r\nSerializes paint commands into a “display list” per layer\r\n\r\nLayerization\r\n\r\nDecides which elements should live on separate compositing layers\r\n(e.g. fixed position, CSS transforms, video)\r\n\r\nKey Class: DisplayItemList\r\n\r\n6. Stage 5 – Rasterization\r\nRaster Threads\r\n\r\nA thread pool converts display lists into GPU/uploadable bitmaps\r\n\r\nTile-Based Raster\r\n\r\nSplits large layers into tiles for incremental updates\r\n\r\nCaching\r\n\r\nRetain raster results when content hasn’t changed\r\n\r\nArtifacts: SkBitmap or Skia GPU textures\r\n\r\n7. Stage 6 – Compositing & Presentation\r\nGPU Process\r\n\r\nReceives layer trees via Mojo\r\n\r\nBuilds a scene graph\r\n\r\nMerge Passes\r\n\r\nCombines layers, applies opacity, transforms\r\n\r\nFrame Submission\r\n\r\nSubmits via GPU APIs (OpenGL, Vulkan, Metal) to the OS\r\n\r\nVSync Sync\r\n\r\nTies frame submission to display refresh\r\n\r\nOutcome: smooth on-screen frame\r\n\r\n8. Threading & Pipelining\r\n\r\nThread\tWork\r\nMain\tDOM, CSSOM, style, layout, paint commands\r\nCompositor\tLayer tree updates, IPC to GPU process\r\nRaster\tDisplay list → bitmaps\r\nGPU\tTexture uploads, draw calls to GPU driver\r\nWorker\tJS Web Workers (if used by page scripts)\r\nChromium overlaps raster & GPU work across frames to maximize throughput.\r\n\r\n9. Optimizations & Techniques\r\nPartial Dirty-Rect: only repaint changed tiles\r\n\r\nDeferred Paint: skip painting layers not in viewport\r\n\r\nZero-Copy Video: direct GPU texture for video frames\r\n\r\nSmooth Scrolling: compositor-only scroll without main thread\r\n\r\n10. Debugging & Instrumentation\r\nchrome://tracing\r\n\r\nVisualize pipeline stages & thread timelines\r\n\r\nLayer Borders\r\n\r\n--show-composited-layer-borders flag\r\n\r\nPaint Flashing\r\n\r\n--show-paint-rects to highlight repaints\r\n\r\nDevTools Performance Tab\r\n\r\nFlamethrower view of scripting & rendering\r\n\r\n11. Next Steps\r\nRead Architecture → Browser Components for cross-process services.\r\n\r\nDeep dive into Modules → Storage & Cache for how caching interacts with painting.\r\n\r\nExperiment: enable --enable-gpu-rasterization and measure FPS via chrome://gpu.\r\n\r\nEnd of Render Pipeline deep-dive.\r\n\r\npgsql\r\nCopy\r\nEdit\r\n\r\n**Notes on usage:**\r\n\r\n- Each stage can link out to more granular articles (e.g. “CSS Style Resolution” → a CSS pipeline deep-dive).  \r\n- Diagrams (SVG/PNG) are highly recommended between sections to visualize the hand-off points.  \r\n- Adjust flags and artifacts to reflect any upstream changes in Chromium’s codebase."
  },
  {
    "path": "architecture/process-model",
    "title": "Process Model",
    "content": "# Process Model\r\n\r\nChromium is built on a multi-process architecture designed to improve stability, security, and performance by isolating different browser components into separate OS processes. In this article, we’ll explore each process type, how they communicate, and the sandboxing model that keeps them in check.\r\n\r\n![](../../img/architecture/multiprocess-architecture.png)\r\n\r\n---\r\n\r\n## 1. Why Multi-Process?\r\n\r\n- **Isolation**  \r\n  Crashes in one renderer don’t take down the whole browser.  \r\n- **Security**  \r\n  Sandboxing limits the damage compromised or malicious code can do.  \r\n- **Performance**  \r\n  Parallelism across CPU cores; background tabs can be deprioritized.\r\n\r\n---\r\n\r\n## 2. Browser Process\r\n\r\nThe **Browser Process** manages most of Chrome's day-to-day operations, including UI, navigation, and launching child processes. It is the main process responsible for coordinating all other processes.\r\n\r\n- **Responsibilities**  \r\n  - UI (address bar, tabs, menus)  \r\n  - Navigation coordination  \r\n  - Disk I/O (cache, cookies, history)  \r\n  - Launching and monitoring child processes  \r\n\r\n- **Key Components**  \r\n  - `BrowserMain` (entry point)  \r\n  - `Profile` (user data, settings)  \r\n  - `TabManager` and `TabStripModel`\r\n\r\nThe browser process communicates with renderer processes via **IPC (Inter-Process Communication)** channels, ensuring isolation and stability.\r\n\r\n---\r\n\r\n## 3. Renderer Processes\r\n\r\nThe **Renderer Processes** are responsible for rendering web pages, executing JavaScript, and managing the DOM. Each renderer process is isolated to a single site-instance, ensuring security and stability.\r\n\r\n- **Role**  \r\n  Hosts Blink (HTML/CSS layout & paint) and V8 (JavaScript) engines.  \r\n\r\n- **Isolation**  \r\n  - One renderer per site-instance (site-per-process by default).  \r\n  - Sandboxed so file system and system calls are restricted.  \r\n\r\n- **Threads**  \r\n  - **Main thread**: layout, painting, scripting.  \r\n  - **Worker threads**: web workers, compositor, IO.  \r\n\r\n- **Crash Recovery**  \r\n  If a renderer crashes, only its tab shows a “Sad Tab” error; others continue.\r\n\r\nThe following diagram illustrates the multi-process architecture:\r\n\r\n![](../../img/architecture/chromium-process-model.png)\r\n\r\n---\r\n\r\n## 4. GPU Process\r\n\r\nThe **GPU Process** offloads compositing and GPU-accelerated drawing to a separate process, ensuring smooth rendering and preventing GPU driver crashes from affecting the browser.\r\n\r\n- **Responsibilities**  \r\n  - Managing GL contexts and command buffers.  \r\n  - Providing sandboxed access to graphics APIs.  \r\n\r\n---\r\n\r\n## 5. Utility & Service Processes\r\n\r\nChromium factors out specialized functionality into additional processes:\r\n\r\n| Process Type        | Examples                                    | Why                                |\r\n| ------------------- | ------------------------------------------- | ---------------------------------- |\r\n| **Network Service** | DNS resolution, HTTP/QUIC stack            | Runs as a separate service for better security and easier updates |\r\n| **Audio Service**   | Audio decoding and playback                 | Prevents audio bugs from halting the renderer |\r\n| **PPAPI Plugin Host** | Flash, PDF, etc.                           | Legacy plugin support in a sandbox  |\r\n| **Utility**         | Codecs, encryption helpers, DevTools port   | Miscellaneous helpers outside of renderers |\r\n\r\n---\r\n\r\n## 6. Inter-Process Communication (IPC)\r\n\r\nChromium uses **Mojo RPC**, a message-passing framework built on top of message pipes, for communication between processes.\r\n\r\n- **Patterns**  \r\n  - **Request/Response**: e.g., “Load this URL.”  \r\n  - **Publish/Subscribe**: e.g., GPU context lost events.  \r\n\r\n- **Channels**  \r\n  Each child process has a dedicated channel to the browser process.\r\n\r\n---\r\n\r\n## 7. Process Lifecycle\r\n\r\n1. **Launch**  \r\n   - `BrowserMain` forks a new process via `base::LaunchProcess`.  \r\n2. **Initialization**  \r\n   - Child runs its own `main` (e.g., `RenderProcessMain`).  \r\n   - Sets up Mojo, initializes sandbox.  \r\n3. **Work**  \r\n   - Receives tasks via IPC.  \r\n   - Does rendering, network, or utility work.  \r\n4. **Shutdown**  \r\n   - Clean teardown on browser exit or crash.  \r\n   - Crash dumps reported via `breakpad`.\r\n\r\n---\r\n\r\n## 8. Sandboxing & Security\r\n\r\nChromium employs platform-specific sandboxes to restrict process access and enhance security:\r\n\r\n- **Platform-specific sandboxes**  \r\n  - **Windows**: Job objects + seccomp-like restrictions.  \r\n  - **Linux**: setuid sandbox or seccomp-bpf.  \r\n  - **macOS**: seatbelt profiles.  \r\n\r\n- **Privilege Separation**  \r\n  Renderer processes cannot open arbitrary files or sockets.  \r\n\r\n- **Exploit Mitigations**  \r\n  Address space layout randomization, control-flow integrity, etc.\r\n\r\n---\r\n\r\n## 9. Diagrams\r\n\r\nThe following diagram illustrates the conceptual application layering in Chromium's multi-process architecture:\r\n\r\n![](../../img/architecture/multiprocess-architecture-detailed.png)\r\n\r\n![](../../img/architecture/multiprocess-architecture-simplified.png)\r\n\r\n---\r\n\r\n## 10. Next Steps\r\n\r\n- Read **Architecture → Render Pipeline** for frame construction.  \r\n- See **Modules → Networking (HTTP)** for details on the network service.  \r\n- Dive into **Security → Security Model** to learn more about sandbox internals.  \r\n\r\n---\r\n\r\n*End of Process Model deep-dive.*"
  },
  {
    "path": "architecture/overview",
    "title": "",
    "content": "Any good architecture requires high cohesion, low coupling between modules, and conforms to the design principles of SOLID (single function, open-shut principle, Rickers substitution, interface isolation, and dependency inversion). Chromium as an excellent open source project, let's take a look at the main features of its architecture.\r\n\r\nAs an excellent open source project, Chromium's architectural features are most obvious module layering and adopt a multi-process model, so that module dependencies can be solved, and highly cohesive, low-coupling levels and components can be continuously developed, and deps ([code management tools](https://cloud.tencent.com/product/coding-cr?from=10680)) are used for guarantee. The basic design principle is that the underlying modules cannot depend on the higher modules, but can call their interface APIs."
  },
  {
    "path": "architecture/module-layering",
    "title": "",
    "content": "## **1 Module layering**\r\n\r\nChromium is divided into three parts: Browser, Renderer, and Webkit. Where Browser is the main process, representing all UI and I/O. Renderer is the child process of each tab in the browser. Renderer embeds Webkit for rendering and layout. (The process model can be found in Section 1.2 and the official Chromium documentation.)\r\n\r\nThe following figure is the official module hierarchy diagram:\r\n\r\n![](../../img/architecture/official-module-hierarchy.png)\r\n\r\nThe following diagram is a simplified version of the module hierarchy:\r\n\r\n![](../../img/architecture/simplified-module-hierarchy.png)\r\n\r\nAmong them, Content is only responsible for loading the core code of the web page to provide WebPlatformFeatures (the ability to parse and render the page under multiple processes. The other is HTML/HTML5/CSS3), on which a complete browser application can be constructed. Chrome is the application layer, which provides ApplicationFeatures (application-like requirements). For example, the Extensions extension, ChromeFrame (chrome's client box UI), Pre-render preloading, SpellCheck spell checking, Autofill autofill and other features.\r\n\r\nDifferent applications have different needs for different user scenarios. In addition to the typical browser, there are other built-in page browsing features such as help, preview, and even games. They will all have different application class requirements (ApplicationFeatures).\r\n\r\nThe Chromium Embedded Framework (CEF) is an open source Webbrowser control based on the Google Chromium project, which supports Windows, Linux, and Mac platforms. CEF is based on the better layering of Chromium, no unreasonable dependencies and other factors, based on the Content API implementation.\r\n\r\nFor module layering, please refer to the official chromium documentation:\r\n\r\n[https://www.chromium.org/developers/content-module](https://www.chromium.org/developers/content-module)"
  },
  {
    "path": "architecture/ipc-internals",
    "title": "Chromium IPC Internals",
    "content": "# Chromium IPC Internals\r\n\r\nChromium's Inter-Process Communication (IPC) mechanism is a critical part of its multi-process architecture. It allows processes with different trust levels (e.g., browser and renderer processes) to communicate securely and efficiently. This document provides an overview of Chromium's IPC implementation, key components, and platform-specific details.\r\n\r\n---\r\n\r\n## Overview of Chromium IPC\r\n\r\nChromium's IPC mechanism enables communication between processes by splitting code into different trust levels. This separation improves security and stability by isolating sensitive operations.\r\n\r\n### Key Features:\r\n1. **Main Communication Mechanisms**:\r\n   - **PIPE** (Windows)\r\n   - **Socketpair** (POSIX)\r\n\r\n2. **Platform-Specific Implementations**:\r\n   - **Windows**: Named pipes are used for communication.\r\n   - **POSIX**: Socketpair or UNIX domain sockets are used.\r\n\r\n3. **Named Channels**:\r\n   - On Windows, channels are named by default and accessible from other processes.\r\n   - On POSIX, channels are anonymous by default and not accessible from other processes.\r\n\r\n---\r\n\r\n## Key Components of Chromium IPC\r\n\r\n### 1. **IPC::Channel**\r\n- Handles communication between the client and server.\r\n- Platform-specific implementations:\r\n  - `ipc_channel_win.h/.cc` (Windows)\r\n  - `ipc_channel_posix.h/.cc` (POSIX)\r\n  - `ipc_channel_nacl.h/.cc` (NaCl)\r\n\r\n### 2. **IPC::ChannelProxy**\r\n- Runs an IPC channel on a background thread.\r\n- Can have an associated `IPC::ChannelProxy::MessageFilter` to handle incoming messages on the IPC channel's thread.\r\n\r\n### 3. **IPC::Message**\r\n- Represents the message being sent or received.\r\n- Inherits from `base::Pickle`, which provides binary value packing and unpacking.\r\n- Each message has a header (`IPC::Message::Header`) and a payload.\r\n\r\n### 4. **IPC::Listener**\r\n- Listens for events on the channel. Key events include:\r\n  - `OnMessageReceived()`: Triggered when a message is received.\r\n  - `OnChannelConnected()`: Triggered when the channel is connected.\r\n  - `OnChannelError()`: Triggered when an error causes the channel to close.\r\n\r\n### 5. **IPC::Sender**\r\n- A pure virtual class with a single `Send()` function for sending messages.\r\n\r\n---\r\n\r\n## Message Handling in Chromium IPC\r\n\r\n### Message Lifecycle:\r\n1. **HELLO Message**:\r\n   - The first message exchanged between processes.\r\n   - Contains the process ID (PID) and, if client validation is enabled, a shared secret.\r\n\r\n2. **Message Priority**:\r\n   - Messages can have the following priorities:\r\n     - `PRIORITY_LOW`\r\n     - `PRIORITY_NORMAL`\r\n     - `PRIORITY_HIGH`\r\n\r\n3. **Message Iteration**:\r\n   - Multiple messages can be received in a single read.\r\n   - The `payload_size` field in the message header is used to iterate over messages.\r\n\r\n4. **Message Map**:\r\n   - Use `IPC_BEGIN_MESSAGE_MAP()`, `IPC_MESSAGE_HANDLER()`, and `IPC_END_MESSAGE_MAP()` to define callbacks for different message types.\r\n   - Internally, these macros create a `switch` statement to handle various message types.\r\n\r\n---\r\n\r\n## Platform-Specific Details\r\n\r\n### Windows:\r\n- **Named Pipes**:\r\n  - Default pipe name: `\\\\.\\pipe\\chrome.<channel_name>`\r\n  - Supports client validation using a shared secret appended to the pipe name.\r\n\r\n- **Asynchronous Reads**:\r\n  - Uses `base::MessagePumpForIO::IOHandler` for asynchronous read operations.\r\n  - Reads data in `OVERLAPPED` mode and passes it to the `IPC::Listener`.\r\n\r\n### POSIX:\r\n- **Socketpair or UNIX Domain Sockets**:\r\n  - Channels are anonymous by default.\r\n  - Named channels use UNIX domain sockets.\r\n\r\n---\r\n\r\n## Advanced Features\r\n\r\n### 1. **Message Filters**:\r\n- `IPC::ChannelProxy::MessageFilter` allows filtering and processing of messages on a background thread.\r\n\r\n### 2. **Message Packing**:\r\n- `base::Pickle` provides facilities for packing and unpacking binary values in messages.\r\n\r\n### 3. **Client Validation**:\r\n- A shared secret can be used to validate clients during the connection process.\r\n\r\n---\r\n\r\n## Example: IPC Message Header Format\r\n\r\nEach message has a header defined in `IPC::Message::Header`, which inherits from `base::Pickle::Header`. The header includes metadata such as the message type, routing ID, and payload size.\r\n\r\n### Header Format:\r\n\r\n![](../../img/architecture/ipc-message-header.jpg)\r\n\r\nThe payload follows the header and contains the actual data being transmitted.\r\n\r\n---\r\n\r\n## References\r\n\r\n1. [Chromium IPC Design Document](http://www.chromium.org/developers/design-documents/inter-process-communication)\r\n2. [Chrome Sandbox Overview (Part 1)](http://blog.azimuthsecurity.com/2010/05/chrome-sandbox-part-1-of-3-overview.html)\r\n3. [Chrome Sandbox IPC (Part 2)](http://blog.azimuthsecurity.com/2010/08/chrome-sandbox-part-2-of-3-ipc.html)\r\n\r\n---\r\n\r\n## Summary\r\n\r\nChromium's IPC mechanism is a robust and flexible system that enables secure and efficient communication between processes. By leveraging platform-specific implementations and advanced features like message filters and client validation, Chromium ensures high performance and security in its multi-process architecture."
  },
  {
    "path": "architecture/browser-components",
    "title": "Browser Components",
    "content": "# Browser Components\r\n\r\nThis article walks through the major C++ components that live in the **browser process** (the “embedder” around Blink/V8). Understanding these is key to seeing how Chromium boots up, hosts tabs, and wires together UI, IPC, storage and network.\r\n\r\n---\r\n\r\n## 1. High-Level Architecture\r\n\r\n> **Browser ↔ Renderer**  \r\n> The browser process drives UI, navigation, storage, security, and launches one or more renderer processes. Renderers host the Blink/V8 engines.\r\n\r\n```text\r\n+----------------+    Mojo IPC    +-------------+\r\n| Browser        | <------------> | Renderer    |\r\n| process        |                | process     |\r\n+----------------+                +-------------+\r\nMajor browser-side modules live under src/chrome/, src/content/, src/net/, and src/components/.\r\n\r\n2. Application Startup\r\nBrowserMain\r\n\r\nEntry point (chrome/app/chrome_main.cc)\r\n\r\nInitializes logging, crash upload (Breakpad/Crashpad), feature flags\r\n\r\nProfileManager\r\n\r\nLoads user profile (preferences, bookmarks, extensions)\r\n\r\nCreates a Profile object per user data directory\r\n\r\nBrowserProcessImpl\r\n\r\nBrings up global services:\r\n\r\nPrefService (settings)\r\n\r\nDownloadService\r\n\r\nHistoryService\r\n\r\nCookieManager\r\n\r\nUI Loop\r\n\r\nCreates the BrowserWindow (NativeWindow wrapper)\r\n\r\nBegins platform event loop (RunMessageLoop)\r\n\r\n3. Tab & Window Management\r\nTabStripModel (chrome/browser/ui/tab_strip_model.cc)\r\n\r\nManages a list of WebContents (each a tab)\r\n\r\nHandles adding, removing, reordering, and session restore\r\n\r\nBrowser (chrome/browser/ui/browser.cc)\r\n\r\nHigh-level controller for a window\r\n\r\nRoutes commands (New Tab, Close Tab, Navigate) to TabStripModel\r\n\r\nWebContents\r\n\r\nRepresents the content of one “tab”\r\n\r\nOwns the RenderProcessHost, NavigationController, and attendants\r\n\r\n4. Navigation & Session\r\nNavigationController\r\n\r\nKeeps history stack and current URL\r\n\r\nImplements back/forward, reload, and session restoration\r\n\r\nNavigationRequest (content/browser/loader/navigation_request.cc)\r\n\r\nOne-per-navigation round-trip: coordinates URLLoader, history update, and commit\r\n\r\nSessionService\r\n\r\nPeriodically writes the list of open tabs/windows to disk for crash recovery\r\n\r\n5. Networking & Resource Loading\r\nNetwork Service (services/network/)\r\n\r\nRuns in its own process by default\r\n\r\nHandles all HTTP(S), QUIC, caching, proxy resolution\r\n\r\nURLLoaderFactory\r\n\r\nFactory for network requests, passed over Mojo to renderers\r\n\r\nResourceScheduler\r\n\r\nPrioritizes and throttles resource requests (CSS, images, fonts)\r\n\r\n6. Storage & State\r\nProfile (chrome/browser/profiles/profile.cc)\r\n\r\nRoot for per-profile paths (cache, cookies, local storage)\r\n\r\nCookieManager (services/network/public/cpp/cookie_manager.cc)\r\n\r\nExposes cookie APIs to renderers over Mojo\r\n\r\nStorage Partitions\r\n\r\nEach WebContents can have isolated storage for cookies, indexedDB, cache, etc.\r\n\r\n7. UI Layer\r\nBrowserView / BrowserFrame\r\n\r\nCross-platform C++ classes wrapping native windows and views\r\n\r\nOmnibox (chrome/browser/ui/omnibox/)\r\n\r\nURL/address bar, autocomplete popup, suggestion ranking\r\n\r\nToolbar & Menus\r\n\r\nActions (reload, devtools) wired to commands on Browser\r\n\r\n8. Extensions & Plugins\r\nExtension System (extensions/)\r\n\r\nManages loading, permissions, lifecycle of Chrome extensions\r\n\r\nInjects content scripts into pages via ScriptContext\r\n\r\nPlugin Host\r\n\r\nHosts NPAPI or PPAPI plugins in a sandboxed “plugin process”\r\n\r\n9. Security & Sandboxing\r\nSite Isolation\r\n\r\nBrowser enforces “site-per-process” — renderer can only talk to its own site\r\n\r\nPermission Model\r\n\r\nChrome’s permission prompts are implemented in the browser (PermissionPrompt UI)\r\n\r\nSafe Browsing\r\n\r\nChecks URLs against blacklist (SafeBrowsingDatabase), shows interstitials\r\n\r\n10. Diagnostics & Metrics\r\nPerformanceManager (chrome/browser/performance_manager/)\r\n\r\nObserves WebContents, tracks memory and CPU for background tab throttling\r\n\r\nTaskManager\r\n\r\nIn-browser UI to view per-process resource usage\r\n\r\nTracing & Metrics\r\n\r\nchrome://tracing integration, UMA histogram reporting\r\n\r\n11. Next Steps\r\nRead Architecture → Process Model to see how browser and renderer interact.\r\n\r\nExplore Modules → Networking (HTTP) for full details on the network service.\r\n\r\nDive into Security → Security Model to understand sandbox implementation.\r\n\r\nEnd of Browser Components deep-dive.\r\n\r\nmarkdown\r\nCopy\r\nEdit\r\n\r\n**Usage tips:**\r\n\r\n- Link each code-path (`chrome/browser/ui/...`, `services/network/…`) to your code‐search viewer.  \r\n- Consider adding a diagram showing major browser services and their IPC channels.  \r\n- Update paths if upstream rearranges folders."
  },
  {
    "path": "architecture/security/sandbox-architecture",
    "title": "Sandbox Architecture",
    "content": "# Sandbox Architecture\r\n\r\nSecurity is one of Chromium's most important goals. The key to security is to understand that after we have fully understood the behavior of the system under all possible input combinations, we can truly guarantee that the system is secure. For a codebase as large and diverse as Chromium, it's nearly impossible to reason about the combination of possible behaviors of its various parts. The goal of the sandbox is to provide the guarantee that no matter what is entered, what a piece of code can or cannot ultimately do.\r\n\r\nSandboxing leverages the security provided by the operating system to allow the execution of code that cannot make persistent changes to the computer or access constantly changing information. The architecture and specific guarantees provided by the sandbox depend on the operating system. This document covers the Windows implementation with a general design. Linux implementations and OSX implementations are also described here.\r\n\r\nIf you don't want to read this entire document, you can read [the Sandbox FAQ](http://yehe.isd.com/column/support-plan/article-edit/Sandbox_FAQ.md). Sandbox-protected and unprotected content can also be found in the FAQ.\r\n\r\n## Design Principles  \r\n\r\n-   **Don't reinvent the wheel: It's** tempting to extend the operating system kernel with a better security model. But don't do it. Let the operating system apply its security policy on the objects it controls. On the other hand, it is possible to create application-level objects (abstractions) with a custom security model.\r\n-   **Principle of least privilege**: This should be used both for sandbox code and code that controls the sandbox. In other words, even if used to not elevate privileges to superuser, the sandbox needs to be able to work.\r\n-   **Assume that the sandboxed code is malicious**: for threat modeling purposes, we think that once the execution path of the code in the sandbox crosses the early call of some main() function, then it is harmful (that is, it will run harmful code), which in practice can happen when the first external input is received, or before entering the main loop.\r\n-   **Sensitive**: Non-malicious code will not attempt to access resources that it cannot obtain. In this case, the performance impact of the sandbox should be close to zero. A little performance penalty is necessary when sensitive resources need to be accessed in a controlled manner. This is a common example of something that is appropriate for operating system security.\r\n-   **Emulation is not secure**: Emulation and virtual machine scenarios by themselves do not provide security. Sandboxes do not rely on code emulation, or code conversion, or code fixes for security purposes. Sandbox Windows architecture\r\n\r\nThe Windows Sandbox is a sandbox that is available only in user mode. There are no special kernel-mode drivers, and users do not need to become administrators in order for the sandbox to run correctly. Sandbox is designed with both 32-bit and 64-bit processes, and all os-operating system versions between Windows 7 and Windows 10 have been tested.\r\n\r\nSandboxes operate at the process level with granularity. Anything that needs to be sandboxed needs to be put into a separate process. There are two processes for minimizing a sandbox configuration: a permission controller that is called a broker, and one or more sandboxed processes called targets. These two words have these two precise connotations throughout the documentation and code. A sandbox is a static library that must be linked to broker and target executables.\r\n\r\n## Windows Sandbox Model  \r\n### Broker vs. Target  \r\n\r\n### Broker process\r\nIn Chromium, the broker always browses the process. Broker, broadly known, is a permission controller, an administrator of sandbox process activity. The responsibilities of the broker process are:\r\n\r\n1.  Specifies the policy in each target process\r\n2.  Build the target process\r\n3.  Maintain the Sandbox Policy Engine service\r\n4.  Maintain the Sandbox Intercept Manager\r\n5.  Maintain sandboxed IPC services (communication with target processes)\r\n6.  Performs the actions allowed by the policy on behalf of the target process.\r\n\r\nThe broker should always live longer than all the target processes it generates. A sandboxed IPC is a low-level mechanism (unlike the Chromium IPC mechanism) that is evaluated by the policy. The calls allowed by the policy are executed by the broker, and the result is returned to the target process via the same IPC. The Intercept Manager is a patch for Windows API calls that should be forwarded to brokers via IPC.\r\n\r\n### The target process\r\n\r\nIn Chromium, the renderer is always a target process, unless the browsing process is specified with the --no-sandbox command-line argument. The target process maintains all the code that will be allowed in the sandbox, as well as the clients of the sandbox infrastructure:\r\n\r\n1.  All code is sandboxed\r\n2.  Sandboxed IPC client\r\n3.  Sandbox policy engine client\r\n4.  Sandbox interception\r\n\r\nArticles 2, 3, and 4 are part of the sandbox library and are associated with code that needs to be sandboxed.\r\n\r\nInterceptors (also known as hooks) are Windows API calls that are forwarded through the sandbox. The API call is reissued by the broker and returns the result or simply terminates the call. The interceptor + IPC mechanism does not provide security; Its purpose is to provide compatibility when the code in the sandbox cannot be modified due to sandbox limitations. In order to save unnecessary IPC, the process policy in target is also evaluated before making an IPC call, although this is not used as a security guarantee, but it is only a speed optimization.\r\n\r\nExpect most of the plugin to run in the target process in the future.\r\n\r\n![](https://ask.qcloudimg.com/http-save/yehe-1137887/kkyh3qnc4b.png?imageView2/2/w/1620)\r\n\r\n### Core OS Primitives  \r\n### The target process\r\n\r\nIn Chromium, the renderer is always a target process, unless the browsing process is specified with the --no-sandbox command-line argument. The target process maintains all the code that will be allowed in the sandbox, as well as the clients of the sandbox infrastructure:\r\n\r\n1.  All code is sandboxed\r\n2.  Sandboxed IPC client\r\n3.  Sandbox policy engine client\r\n4.  Sandbox interception\r\n\r\nArticles 2, 3, and 4 are part of the sandbox library and are associated with code that needs to be sandboxed.\r\n\r\nInterceptors (also known as hooks) are Windows API calls that are forwarded through the sandbox. The API call is reissued by the broker and returns the result or simply terminates the call. The interceptor + IPC mechanism does not provide security; Its purpose is to provide compatibility when the code in the sandbox cannot be modified due to sandbox limitations. In order to save unnecessary IPC, the process policy in target is also evaluated before making an IPC call, although this is not used as a security guarantee, but it is only a speed optimization.\r\n\r\nExpect most of the plugin to run in the target process in the future.\r\n\r\n![](https://ask.qcloudimg.com/http-save/yehe-1137887/kkyh3qnc4b.png?imageView2/2/w/1620)\r\n\r\n## Sandbox limits\r\n\r\nAt its core, the sandbox relies on 4 mechanisms provided by Windows:\r\n\r\n-   A qualified token\r\n-   Windows work objects\r\n-   Windows desktop object\r\n-   Windows Vista and above: Integration layer\r\n\r\nThese mechanisms are quite efficient in protecting the operating system, the limitations of the operating system, and the data provided by the user, provided that:\r\n\r\n-   All resources that can be secured have a better security descriptor than null. In other words, there are no critical resources that would have a bad security configuration.\r\n-   The computer was not compromised by malware.\r\n-   Third-party software cannot weaken system security.\r\n\r\n\\*\\* Note: The specific measures above and the measures outside the kernel are described in the \"Process Lightweighting\" section below. \\*\\*\r\n\r\n### token\r\n\r\nOne of the problems faced by other similar sandbox projects is how restrictive they should be so that tokens and jobs remain functional. In the Chromium sandbox, the most restrictive tokens for Windows XP are as follows:\r\n\r\n**Normal group**\r\n\r\nLogin SID : Mandatory\r\n\r\nAll other SIDs: Deny only, Forced\r\n\r\n**Restrict groups**\r\n\r\nS-1-0-0 : Mandatory\r\n\r\n**privilege**\r\n\r\nnot\r\n\r\nAs mentioned above, if the operating system grants such a token, it is almost impossible to find the resource that exists. As long as the disk root directory has non-empty security, even empty safe files cannot be accessed. In Vista, the most restrictive token is also like this, but it also includes labels with lower integrity levels. Chromium renderers typically use this token, which means that most of the resources used by the renderer process are already fetched by the browser, and their handles are copied to the renderer process.\r\n\r\nNote that the token does not originate from an anonymous token or a guest token, it inherits from the user's token and is therefore associated with the user's sign-in. Therefore, any alternate audits owned by the system or [domain name](https://dnspod.cloud.tencent.com/) can still be used.\r\n\r\nBy design, sandbox tokens do not protect the following insecure resources:\r\n\r\n-   Mounted FAT or FAT32 volumes: The security descriptor on them is validly empty. Malware running in targets can read and write this disk space because the malware can guess or eject their paths.\r\n-   TCP/IP: The security of tcp/IP sockets in Windows 200 and Windows XP (but not in Vista) is valid null. This makes it possible for malicious code to send and receive network packets from any host.\r\n\r\nMore information about the Windows token object can be found in the reference \\[02\\] at the bottom.\r\n\r\n### Job object\r\n\r\nThe target process also runs a job object. Using this Windows mechanism, some interesting global restrictions that do not own traditional objects or do not associate security descriptors can be enforced:\r\n\r\n-   SystemParametersInfo() is prohibited from making system-wide modifications shared by the user, which can be used to switch mouse buttons or set screen savers to time out\r\n-   It is forbidden to create or modify desktop objects\r\n-   It is forbidden to modify user-shared display settings, such as resolution and primary display\r\n-   Read and write to the clipboard is prohibited\r\n-   Disable setting global Windows hooks (using SetWindowsHookEx())\r\n-   Disable access to global atomic tables\r\n-   Disables access to USER handles created outside the job object\r\n-   Single-active process limit (child processes are not allowed)\r\n\r\nThe Chromium renderer allows with all these restrictions activated. Each renderer runs in its own job object. With job objects, sandboxes can (but not currently) avoid:\r\n\r\n-   Overuse of CPU cycles\r\n-   Excessive use of memory\r\n-   Overuse of IO\r\n\r\nDetailed information about Windows job objects can be found in the reference \\[1\\] at the bottom.\r\n\r\n### Additional desktop objects\r\n\r\nTokens and job objects define a security boundary: that is, all processes have the same token, and all processes in the same job object are in the same security context. However. An incomprehensible fact is that applications on the same desktop that have windows are also in the same security context, because sending and receiving window messages is not subject to any security checks. Sending messages through desktop objects is not allowed. This is the source of the infamous \"shatter\" attack and the reason why services should not host windows on interactive desktops. The Windows desktop is a regular kernel object that can be created and then assigned a security descriptor.\r\n\r\nIn a standard Windows installation, at least two desktops are associated with an interactive window station, one is a regular (default) desktop and the other is a login desktop. The sandbox creates a third desktop associated with all target processes. This desktop is never visible or interactive, effectively isolating sandboxed processes so that they cannot spy on the user's interactions and send messages to Windows in more privileged environments.\r\n\r\nThe only advantage of an additional desktop object is that it uses close to 4MB of memory from an isolated pool, which may be more in Vista.\r\n\r\n### Credit rating\r\n\r\nCredit ratings are available in versions of Windows Vista and beyond. They don't define the boundaries of security in a strict way, but they do provide a kind of mandatory access control (MAC) and exist as the basis for the Microsoft IE sandbox.\r\n\r\nCredit ratings are implemented by a special set of SIDs and ACL pairs, which represent five incremental levels: untrusted, low-level, intermediate, high-level, and systematic. If an object is at a higher credit rating than the request token, access to it is restricted. Credit ratings also implement user interface permission isolation, which applies credit rating rules to exchange window messages for different processes in the same desktop.\r\n\r\nBy default, tokens can read objects with high credit ratings, but cannot write. Most desktop applications run on a low credit rating (MI), while less trusted processes like IE Protected Mode and our own sandbox run on a low credit rating (LI). A token in a low credit rating mode can only access the following shared resources:\r\n\r\n-   Read access to most files\r\n-   Write access to %USER PROFILE, AppData, LocalLow directories\r\n-   Read most of the registry\r\n-   Write access to the HKEY\\_CURRENT\\_USER\\\\Software\\\\AppDataLow directory\r\n-   Clipboard (copy and paste for some formats)\r\n-   Remote Procedure Call (RPC)\r\n-   TCP/IP Socket\r\n-   Expose window messages via ChangeWindowMessageFilter\r\n-   Share memory via LI tags\r\n-   Has the li to initiate activation permissions to access the COM interface\r\n-   Named pipes exposed by LI tags\r\n\r\nYou'll notice that the token attributes described earlier, the work objects, the additional desktop are more restrictive, and in fact hinder access to everything listed above. Therefore, the credit rating is more relaxed than other measures, but this can also be seen as a denial of defense-in-depth, and its use will not have a significant impact on performance or resource use.\r\n\r\nMore information on credit ratings can be found in the reference \\[03\\] at the bottom.\r\n\r\n### Process lightweighting strategy\r\n\r\nMost process lightweighting strategies can be applied to Targetget processes through the SetProcessMitigationPolicy method. The sandbox uses this API to set different policies for the target process to strengthen security features.\r\n\r\n**To relocate an image:**\r\n\r\n-   \\>= Win8\r\n-   Random Address Loading (ASLR) for all images in the process (must be supported by all images)\r\n\r\n**The End of the Heap:**\r\n\r\n-   \\>= Win8\r\n-   End the Windows heap occupation process\r\n\r\n**Bottom-up ASLR:**\r\n\r\n-   \\>= Win8\r\n-   Sets a random nether as the minimum user address for the process\r\n\r\n**High entropy ASLR:**\r\n\r\n-   \\>= Win8\r\n-   Add a random level to 1TB for bottom-up ASLR.\r\n\r\n**Strict handle checking:**\r\n\r\n-   \\>= Win8\r\n-   An exception is thrown immediately for malicious handle references\r\n\r\n**Win32k .sys Lock:**\r\n\r\n-   \\>= Win8\r\n-   ProcessSystemCallDisablePolicy, which allows selectively shutting down system calls available to the target process\r\n-   The renderer process now sets this feature to DiskWin32kSystemCalls, which means that win32k .sys user-mode calls are no longer allowed. This greatly reduces the available kernel attacks from the renderer. Check [out here](https://docs.google.com/document/d/1gJDlk-9xkh6_8M_awrczWCaUuyr0Zd2TKjNBCiPO_G4) for more details.\r\n\r\n**App** [**container**](https://cloud.tencent.com/product/tke?from=10680) **(Low Box Token):**\r\n\r\n-   \\>= Win8\r\n-   In Windows, this is implemented by a Low Box Token at the kernel level, which is a stripped version with restrictive priority (usually only SeChangeNotifyPrivilege and SeIncreaseWorkingSetPrivilege), running at a low credit level, and this container is also implemented by a set of \"capabilities\" that can be mapped to what the process allows/denies to do (see [MSDN](https://msdn.microsoft.com/en-us/library/windows/apps/hh464936.aspx)). Get a more detailed description). From a sandbox perspective, the most interesting capability is to veto access to the network, and if the token is a Low Box Token, INTERNET\\_CLIENT capability does not appear, a network check is performed.\r\n-   So the sandbox adds Low Box-related attributes to the existing restriction tokens, and does not grant any additional network protection such as network access without the sandboxing process.\r\n\r\n**To disable font loading:**\r\n\r\n-   \\>= Win10\r\n-   ProcessFontDisablePolicy\r\n\r\n**To disable remote device image loading:**\r\n\r\n-   \\>= Win10 TH2\r\n-   ProcessImageLoadPolicy\r\n-   Example: UNC path to a network resource\r\n\r\n**To disable \"Force Low Credit Rating\" image loading:**\r\n\r\n-   \\>= Win10 TH2\r\n-   ProcessImageLoadPolicy\r\n-   Example: Temporary Internet file\r\n\r\n**Disable additional child process creation:**\r\n\r\n-   \\>= Win10 TH2\r\n-   If the job level < = JOB\\_LIMITED\\_USER, set the PROC\\_THREAD\\_ATTRIBUTE\\_CHILD\\_PROCESS\\_POLICY to PROCESS\\_CREATION\\_CHILD\\_PROCESS\\_RESTRICTED with UpdateProcThreadAttribute().\r\n-   This is an extra layer of defense that allows the job layer to be broken from the outside. \\[Citation: [ticket](https://bugs.chromium.org/p/project-zero/issues/detail?id=213&redir=1), [Project Zero blog](http://googleprojectzero.blogspot.co.uk/2015/05/in-console-able.html).\\]\r\n\r\n### Other warnings\r\n\r\nThe operating system may have some bugs. Of interest are some bugs in the Windows API that allow routine security checks to be skipped. If such a bug exists, the malware is able to penetrate security restrictions, broker policies, and potentially compromise the computer. In a Windows environment, there is no practical way to avoid code in the sandbox calling system services.\r\n\r\nIn addition, third-party software, especially anti-virus solutions, may create new attack angles. The most troublesome thing is to inject applications into the dynamic link library in order to use some (often the system does not want to use) features. These dynamic link libraries are also injected into the sandbox process. At best, they produce failures and, in worst cases, potentially create backdoors for other processes or the file system itself, allowing carefully designed malware to escape the sandbox.\r\n\r\n\r\n## Bootstrapping & Policy Rules  \r\n## Sandbox policies\r\n\r\nApply real restrictions with target processes through policy settings. These policies are just a programming interface called by a broker, and they define restrictions and permissions. Four functions control this limitation, corresponding to four Windows mechanisms:\r\n\r\n-   TargetPolicy::SetTokenLevel()\r\n-   TargetPolicy::SetJobLevel()\r\n-   TargetPolicy::SetIntegrityLevel()\r\n-   TargetPolicy::SetDesktop()\r\n\r\nThe first three calls receive integer rank parameters from very strict to very loose, e.g. tokens have seven levels and jobs have five levels. Chromium renderers typically run the most restrictive mode of the four mechanisms. Finally, there are two desktop policies that can only be used to indicate whether a target process is running in an extra desktop object.\r\n\r\nThese limitations are coarse design because they affect all the protectable resources that the target can access, but sometimes we need finer granular resolution. The sandbox policy interface allows the broker to specify exceptions. One exception is the way to make a specific Windows API call in target, proxying it to a broker. The broker can check the parameters, reissue the call with different parameters, or reject the call altogether. In order to specify exceptions, a separate call is required: AddRule. The following rules for different Windows subsystems are now supported: _File_ Named Pipe _process creation_ Enlisted \\* Synchronization objects\r\n\r\nThe specific form of each seed system varies, but usually the rules are triggered based on string patterns. For example, one possible file rule is:\r\n\r\n```\r\nAddRule(SUBSYS_FILES, FILES_ALLOW_READONLY, L\"c:\\\\temp\\\\app_log\\\\d*.dmp\")\r\n```\r\n\r\nThis rule specifies the permissions that can be granted when a target process wants to open a file, as well as read-only permissions for files that match the string format; For example, c:\\\\temp\\\\app\\_log\\\\domino.dmp is a file that satisfies the format above. Query header files to get a list of the most recently supported objects and behaviors.\r\n\r\nRules can only be added before each process is spawned, and cannot be modified when target is running, but different targets can have different rules.\r\n\r\n## Target bootstrapping\r\n\r\nTarget does not start with the restrictions defined by the policy. They start with a token that is very close to the token owned by a regular user process. Because during process boot, the operating system loader accesses a large number of resources, most of which are unauthenticated and changeable at any time. In addition, most applications use the standard CRT provided by standard development tools, and after the process is guided, the CRT also needs to be initialized, at which point the inside of the CRT initialization becomes uncertified again.\r\n\r\nTherefore, during the boot phase, the process actually uses two kinds of tokens: a lock token, which is also a process token, and an initial token, which is set as an impersonation token for the initial thread. In fact, the true SetTokenLevel definition is:\r\n\r\n```\r\nSetTokenLevel(TokenLevel initial, TokenLevel lockdown)\r\n```\r\n\r\nAfter all initialization operations are complete, main() or WinMain() will continue execution, and two more tokens will survive, but only the initial thread can use the more powerful initial token. Target's responsibility is to destroy the initial token after the preparation is complete. This is achieved by this simple call:\r\n\r\nAfter target declares this call, the only token available is the lock token, and the full sandbox restriction takes effect. This call cannot be undone. Note that the initial token is an impersonation token, which is valid only for the main thread, and other threads created by the target process only use the lock token, so no attempt is made to obtain any system resources that require security checks.\r\n\r\nThe fact that targeting starts with a privilege token simplifies explicit policy, because anything privilege-related that needs to be done once at the time the process starts can be done before the LowerToken() call, and there is no need to set rules in the policy.\r\n\r\n> **significant**\r\n> \r\n> Make sure that any sensitive operating system handles obtained by the initial token are closed before calling LowerToken(). Any compromised handle could be exploited by malware to escape the sandbox.\r\n\r\n## References  \r\n\\[01\\] Richter, Jeffrey \"Make Your Windows 2000 Processes Play Nice Together With Job Kernel Objects\"\r\n\r\n[http://www.microsoft.com/msj/0399/jobkernelobj/jobkernelobj.aspx](http://www.microsoft.com/msj/0399/jobkernelobj/jobkernelobj.aspx)\r\n\r\n\\[02\\] Brown, Keith \"What Is a Token\" (wiki)\r\n\r\n[http://alt.pluralsight.com/wiki/default.aspx/Keith.GuideBook/WhatIsA token .htm](http://alt.pluralsight.com/wiki/default.aspx/Keith.GuideBook/WhatIsA%E4%BB%A4%E7%89%8C.htm)\r\n\r\n\\[03\\] Windows Integrity Mechanism Design (MSDN)\r\n\r\n[http://msdn.microsoft.com/en-us/library/bb625963.aspx](http://msdn.microsoft.com/en-us/library/bb625963.aspx)\r\n"
  },
  {
    "path": "architecture/design-patterns/state-pattern",
    "title": "State Pattern",
    "content": "# State Pattern\r\n\r\nThe State pattern allows an object to alter its behavior when its internal state changes. Chromium leverages state machines for protocol parsing, navigation state, and UI stateful components.\r\n\r\n---\r\n\r\n## 1. Purpose & Usage\r\n\r\n- **Encapsulate state-specific behavior**: separate logic into state classes.\r\n- **Examples**: download state machine, navigation request states, audio focus states.\r\n\r\n---\r\n\r\n## 2. Key Implementations\r\n\r\n- **`DownloadItemImpl::DownloadState`**\r\n  - Enum-backed state (IN_PROGRESS, COMPLETE, CANCELLED).\r\n  - Methods branch on state to decide UI icon, allowed actions.\r\n\r\n- **`NavigationRequest`**\r\n  - State machine states: WILL_START_REQUEST, WILL_REDIRECT_REQUEST, WILL_PROCESS_RESPONSE.\r\n\r\n- **`CrxInstaller`**\r\n  - Phases: PENDING, DOWNLOADING, INSTALLING, COMPLETE.\r\n\r\n---\r\n\r\n## 3. Sample State Machine (Download)\r\n\r\n```text\r\n[NotStarted] --Start--> [InProgress] --Finish--> [Complete]\r\n               \\--Cancel--> [Cancelled]\r\n```\r\n\r\n```cpp\r\nswitch (DownloadState state) {\r\n  case IN_PROGRESS:\r\n    UpdateProgressBar();\r\n    break;\r\n  case COMPLETE:\r\n    ShowOpenButton();\r\n    break;\r\n}\r\n```\r\n\r\n## 4. Best Practices\r\n\r\n- Use clear enum names and document transitions.\r\n\r\n- Centralize transitions to avoid invalid state combos.\r\n\r\n- Consider base::State helper classes for complex machines.\r\n\r\n## 5. Links & References\r\n\r\n- content/browser/download/download_item_impl.{h,cc}\r\n\r\n- content/browser/loader/navigation_request.cc\r\n\r\n- extensions/browser/crx_installer.cc"
  },
  {
    "path": "architecture/design-patterns/pre-post-contract",
    "title": "Pre/Post and Contract Programming in Chromium",
    "content": "# Pre/Post and Contract Programming in Chromium\r\n\r\nPre/Post is not a typical design pattern but rather a concept rooted in **contract programming**. It emphasizes defining **preconditions** and **postconditions** for functions or methods, ensuring that software components adhere to a formal contract. This approach improves code reliability, maintainability, and clarity.\r\n\r\n---\r\n\r\n## What is Contract Programming?\r\n\r\nContract programming is a method of designing software by defining formal, precise, and verifiable interfaces for software components. It introduces:\r\n- **Preconditions**: Conditions that must hold true before a function is executed.\r\n- **Postconditions**: Conditions that must hold true after a function is executed.\r\n- **Invariants**: Conditions that must always hold true for an object, except during the execution of a public method.\r\n\r\nAt its core, contract programming relies on **assertions**—Boolean statements that must always evaluate to `true`. If an assertion fails, it indicates a program error.\r\n\r\n---\r\n\r\n## Pre/Post in Chromium\r\n\r\nAlthough C++11 does not natively support contract programming syntax, Chromium's codebase demonstrates the **Pre/Post** concept through its design. This approach is evident in Chromium's startup sequence and other critical components.\r\n\r\n### Example: Chromium Startup Sequence\r\n\r\nThe following diagram illustrates the **Pre/Post** design in Chromium's startup process:\r\n\r\n![](../../img/architecture/chromium-startup-sequence.jpeg)\r\n\r\n1. **Preconditions**:\r\n   - Before starting the main message loop, the environment is prepared using `PreMainMessageLoopStart`.\r\n2. **Postconditions**:\r\n   - After the main message loop starts, cleanup and additional setup are performed using `PostMainMessageLoopStart`.\r\n\r\nThis ensures that each stage of the startup process is clearly defined and adheres to its contract.\r\n\r\n---\r\n\r\n## Benefits of Pre/Post Design\r\n\r\n1. **Improved Readability**:\r\n   - The code is easier to understand because each stage has clearly defined responsibilities.\r\n2. **Enhanced Maintainability**:\r\n   - Changes to one stage do not affect others, as long as the contract is upheld.\r\n3. **Error Prevention**:\r\n   - By enforcing preconditions and postconditions, potential errors are caught early in the development process.\r\n\r\n---\r\n\r\n## Pre/Post in Practice\r\n\r\n### Example: Browser Main Loop\r\n\r\nIn Chromium's `BrowserMainLoop`, the **Pre/Post** design is applied at multiple levels:\r\n\r\n1. **Preconditions**:\r\n   - `PreMainMessageLoopStart` prepares the environment for the main message loop.\r\n   - Platform-specific components (e.g., `ChromeBrowserMainParts`) are initialized.\r\n\r\n2. **Postconditions**:\r\n   - `PostMainMessageLoopStart` performs cleanup and final setup after the main message loop starts.\r\n\r\nThe following diagrams illustrate the layered **Pre/Post** design in Chromium:\r\n\r\n![](../../img/architecture/chromium-pre-post-layers-1.jpeg)\r\n![](../../img/architecture/chromium-pre-post-layers-2.png)\r\n![](../../img/architecture/chromium-pre-post-layers-3.jpeg)\r\n\r\n---\r\n\r\n## Why Use Pre/Post?\r\n\r\nIn programming languages that do not natively support **Design by Contract**, implementing **Pre/Post** at the code level provides many of the same benefits:\r\n- **Clarity**: Developers know exactly what conditions must be met at each stage.\r\n- **Consistency**: The contract ensures that components interact predictably.\r\n- **Debugging**: Assertions help identify issues during development.\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nThe **Pre/Post** design in Chromium demonstrates how contract programming principles can be applied in real-world software development. By defining clear preconditions and postconditions, Chromium's codebase achieves greater stability, security, and maintainability."
  },
  {
    "path": "architecture/design-patterns/observer-pattern",
    "title": "Observer Pattern in Chromium",
    "content": "# Observer Pattern in Chromium\r\n\r\nThe **Observer Pattern** is a widely used software design pattern in Chromium. It allows objects to subscribe to and receive notifications about changes in the state of another object, promoting loose coupling and real-time event handling.\r\n\r\n---\r\n\r\n## What is the Observer Pattern?\r\n\r\nThe **Observer Pattern** is a behavioral design pattern where:\r\n- A **Subject** (or Publisher) maintains a list of its dependents, called **Observers** (or Subscribers).\r\n- When the state of the Subject changes, it notifies all registered Observers, typically by calling a method on them.\r\n\r\n### Key Features:\r\n- **Real-Time Notifications**: Observers are notified immediately when the Subject's state changes.\r\n- **Loose Coupling**: The Subject and Observers are decoupled, making the system more modular and flexible.\r\n- **Scalability**: Multiple Observers can subscribe to a single Subject.\r\n\r\n### UML Diagram:\r\nHere is a simple UML class diagram for the Observer Pattern:\r\n\r\n![](../../img/design-patterns/observer-pattern-uml.png)\r\n\r\n---\r\n\r\n## Observer Pattern in Chromium\r\n\r\nThe Observer Pattern is extensively used in Chromium for various components, including:\r\n- **Tab Strip Management**: Observers are notified of changes in the tab strip (e.g., tab creation, closure).\r\n- **Upgrade Detectors**: Observers monitor and respond to browser upgrade events.\r\n- **Download Management**: Observers track download events, such as the creation of new download items.\r\n\r\nSince C++ does not natively support the Observer Pattern, Chromium implements it using:\r\n- **AddObserver()** and **RemoveObserver()** methods in the Subject.\r\n- **ObserverList<>**: A utility class in Chromium's `base` library to manage lists of Observers.\r\n- **FOR_EACH_OBSERVER**: A macro used to iterate over Observers and notify them.\r\n\r\n---\r\n\r\n## Example: Download Manager\r\n\r\nIn Chromium's **Download Manager**, the Observer Pattern is used to notify Observers about download-related events. For example:\r\n- When a new download item is created, the `OnDownloadCreated` method is called on all registered Observers.\r\n\r\n### Workflow:\r\n1. The user initiates a download.\r\n2. The `CreateDownloadItem` method is called in the `DownloadManager`.\r\n3. All registered Observers are notified via the `OnDownloadCreated` method.\r\n\r\n### Diagram:\r\n![](../../img/design-patterns/download-manager-observer.png)\r\n\r\n---\r\n\r\n## Observer Pattern in Testing\r\n\r\nThe Observer Pattern simplifies automated testing in Chromium. Test-specific Observers can be implemented to monitor and respond to events during testing.\r\n\r\n### Example: Test Observer for Download Manager\r\n\r\nA test-specific Observer can be implemented by extending the base Observer class. For instance:\r\n- The `OnDownloadCreated` method can be overridden to verify that the correct notifications are sent during testing.\r\n\r\n#### Code Example:\r\n```cpp\r\nclass TestDownloadObserver : public DownloadManager::Observer {\r\n public:\r\n  void OnDownloadCreated(DownloadItem* item) override {\r\n    // Custom logic for testing\r\n    EXPECT_TRUE(item != nullptr);\r\n  }\r\n};\r\n```\r\n\r\nIn the test setup, the custom Observer is registered with the DownloadManager:\r\n```cpp\r\nDownloadManager* manager = GetDownloadManager();\r\nauto test_observer = std::make_unique<TestDownloadObserver>();\r\nmanager->AddObserver(test_observer.get());\r\n```\r\n\r\nThis approach ensures that tests can verify event notifications without modifying the core logic.\r\n\r\n## Benefits of the Observer Pattern\r\n\r\n1. Real-Time Event Handling:\r\n - Observers are notified immediately when the Subject's state changes.\r\n2. Loose Coupling:\r\n - The Subject and Observers are decoupled, making the system more modular and easier to maintain.\r\n3. Scalability:\r\n - Multiple Observers can subscribe to a single Subject, enabling complex event-driven systems.\r\n4. Improved Testing:\r\n - Test-specific Observers can be implemented to monitor and verify events during testing.\r\n\r\n## Summary\r\n\r\nThe **Observer Pattern** is a powerful tool for managing real-time events in Chromium. By decoupling Subjects and Observers, it promotes modularity, scalability, and testability. From tab management to download tracking, the Observer Pattern is a cornerstone of Chromium's architecture."
  },
  {
    "path": "architecture/design-patterns/factory-pattern",
    "title": "Factory Pattern",
    "content": "# Factory Pattern\r\n\r\nThe Factory pattern provides a way to create objects without specifying the exact class of the object to create. Chromium uses factories to abstract platform-specific or feature-specific instantiation.\r\n\r\n---\r\n\r\n## 1. Purpose & Usage\r\n\r\n- **Encapsulate object creation**: hide complex `new` logic behind factory methods.\r\n- **Examples**: creating platform-specific UI widgets, protocol handlers, URLLoader instances.\r\n\r\n---\r\n\r\n## 2. Key Interfaces & Classes\r\n\r\n- **`Factory` classes**: static `Create()` methods returning interface pointers.\r\n\r\n- **`BrowserMainParts`** (`chrome/browser/browser_main_parts.h`)\r\n  - Factory for initializing browser process parts per platform.\r\n  - E.g. `CreateBrowserMainParts()` returns `BrowserMainParts` for Windows, Mac, Linux.\r\n\r\n- **`URLLoaderFactory`**\r\n  - In Renderers, `RenderFrameHostImpl` uses `mojo::PendingRemote<network::mojom::URLLoaderFactory>` factory proxy.\r\n\r\n---\r\n\r\n## 3. Usage in Code\r\n\r\n1. **Platform Parts**\r\n   ```cpp\r\n   std::unique_ptr<BrowserMainParts> parts(\r\n       CreateBrowserMainParts(executable_path));\r\n   ```\r\n\r\n2. **Content Module Factories**\r\n\r\n  - RenderProcessHostFactory::Create() (controlled by --renderer-process-type).\r\n\r\n3. **Service Factories**\r\n\r\n  - ServiceManagerConnection::GetForProcess()->GetConnector() provides factories for services.\r\n\r\n## 4. Best Practices\r\n\r\n- Keep factory methods lightweight; move heavy initialization into Init() methods.\r\n\r\n- Use interfaces (std::unique_ptr<MyInterface>) to allow mocking in tests.\r\n\r\n## 5. Links & References\r\n\r\n- chrome/browser/browser_main_parts.h\r\n\r\n- content/public/browser/render_process_host_factory.h"
  },
  {
    "path": "architecture/design-patterns/delegate-pattern",
    "title": "Delegate Pattern in Chromium",
    "content": "# Delegate Pattern in Chromium\r\n\r\nThe **Delegate Pattern** is a fundamental software design pattern widely used in Chromium. It allows objects to delegate responsibilities to other objects, promoting flexibility and modularity in the codebase.\r\n\r\n---\r\n\r\n## What is the Delegate Pattern?\r\n\r\nThe Delegate Pattern is a structural design pattern where one object delegates a request to another object for processing. It is often used to replace inheritance with composition, allowing for more flexible and reusable code.\r\n\r\n### Key Features:\r\n- **Separation of Concerns**: The object that delegates the task does not need to know the details of how the task is performed.\r\n- **Customizability**: Developers can easily extend or modify functionality by implementing custom delegate classes.\r\n- **Testing**: The pattern simplifies automated testing by allowing test-specific delegates to override behavior.\r\n\r\n---\r\n\r\n## Delegate Pattern in Chromium\r\n\r\nChromium is a complex open-source project that extensively uses the Delegate Pattern to organize its code. Many modules in Chromium rely on delegate classes to implement specific functionality. Developers can inherit these delegate classes to customize behavior or omit them entirely if the functionality is not needed.\r\n\r\n### Example: Download Manager Delegate\r\n\r\nIn Chromium, the **Download Manager** class is responsible for managing file downloads. However, the actual work of downloading files is delegated to the **Download Manager Delegate**. This includes tasks such as:\r\n- Selecting the file path.\r\n- Validating the file name.\r\n- Completing the download process.\r\n\r\nDevelopers can create custom delegate classes by inheriting from the `DownloadManagerDelegate` and overriding specific methods to implement custom behavior.\r\n\r\n#### UML Diagram:\r\nThe following UML diagram illustrates the relationship between the `DownloadManager` and its delegate:\r\n\r\n![](../../img/architecture/download-manager-delegate-uml.jpeg)\r\n\r\n---\r\n\r\n## Benefits of the Delegate Pattern\r\n\r\n1. **Flexibility**:\r\n   - Developers can easily replace or extend functionality by implementing custom delegates.\r\n2. **Modularity**:\r\n   - The pattern promotes separation of concerns, making the codebase easier to maintain.\r\n3. **Automated Testing**:\r\n   - Test-specific delegates can override behavior to simulate scenarios or bypass complex logic.\r\n\r\n---\r\n\r\n## Delegate Pattern in Automated Testing\r\n\r\nThe Delegate Pattern is particularly useful in automated testing. For example, in Chromium's **Download Manager**, a custom delegate can be implemented to bypass manual input or complex logic during testing.\r\n\r\n### Example: Test Delegate for Download Manager\r\n\r\nA test-specific delegate can override methods in the `DownloadManagerDelegate` to simplify testing. For instance:\r\n- The `ShouldCompleteDownload` method can be overridden to bypass complex logic and return a fixed value for testing purposes.\r\n\r\n#### Code Example:\r\n```cpp\r\nclass TestDownloadManagerDelegate : public DownloadManagerDelegate {\r\n public:\r\n  bool ShouldCompleteDownload() override {\r\n    // Simplified logic for testing\r\n    return false;\r\n  }\r\n};\r\n```\r\n\r\nIn the test case, the custom delegate is registered with the DownloadManager using the SetDelegate method:\r\n\r\n```cpp\r\nDownloadManager* manager = GetDownloadManager();\r\nmanager->SetDelegate(std::make_unique<TestDownloadManagerDelegate>());\r\n```\r\n\r\nThis approach ensures that the test environment is isolated and predictable.\r\n\r\n## Delegate Pattern in Practice\r\n\r\nThe Delegate Pattern is used extensively in Chromium for various modules, including:\r\n\r\n- **Download Manager**: Handles file downloads.\r\n- **Dialog Management**: Manages user interactions with dialogs.\r\n- **Network Requests**: Customizes behavior for specific network operations.\r\n\r\nBy leveraging the Delegate Pattern, Chromium achieves a high degree of modularity and flexibility, making it easier to maintain and extend the codebase.\r\n\r\n## Conclusion\r\n\r\nThe Delegate Pattern is a powerful tool for organizing code in large projects like Chromium. It promotes flexibility, modularity, and testability, making it an essential design pattern for modern software development."
  }
]