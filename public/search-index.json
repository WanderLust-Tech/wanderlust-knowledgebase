[
  {
    "path": "security/security-model",
    "title": "Security Model",
    "content": "# Security Model\r\n\r\nChromium’s security architecture is layered to protect users from malicious content, compromised sites, and browser vulnerabilities. This article breaks down the key pieces of that model—from sandboxing to origin isolation to transport security—and points you to the source files where each is implemented.\r\n\r\n---\r\n\r\n## 1. Threat Model & Goals\r\n\r\n- **Threats Addressed**  \r\n  - Arbitrary code execution via renderer or plugin bugs  \r\n  - Cross-site data leakage (XSS, CSRF)  \r\n  - Network eavesdropping or man-in-the-middle attacks  \r\n- **Security Goals**  \r\n  1. **Isolation**: ensure that untrusted web content cannot read or write user data outside its scope.  \r\n  2. **Least Privilege**: run each component with minimal OS privileges.  \r\n  3. **Defense in Depth**: multiple overlapping safeguards (sandbox, site isolation, CSP).  \r\n\r\n---\r\n\r\n## 2. Origin & Same-Origin Policy\r\n\r\n- **Origin Definition**  \r\n  - A tuple of (scheme, host, port). Two pages may interact only if all three match.  \r\n- **Enforcement**  \r\n  - Implemented in Blink’s DOM bindings under `third_party/blink/renderer/bindings/`.  \r\n  - Checked in navigation, XHR/fetch, iframe embedding, `document.cookie`.  \r\n- **Key Files**  \r\n  - `security_origin.cc` (defines `SecurityOrigin` and policy checks)  \r\n  - `script_security.cc` (enforces JS‐level checks)\r\n\r\n---\r\n\r\n## 3. Site Isolation & Process-Per-Site\r\n\r\n- **Site-Per-Process**  \r\n  - By default, Chromium maps each “site” (origin) into its own renderer process.  \r\n  - Prevents a compromised renderer from poking into other sites’ memory.  \r\n- **Implementation**  \r\n  - Controlled by GN flag `site_per_process` in `content/browser/site_isolation/`.  \r\n  - `SiteIsolationPolicy` and `SiteInstance` classes coordinate process mapping.  \r\n- **Crash Containment**  \r\n  - Renderer crash shows only that tab’s error page; other tabs unaffected.\r\n\r\n---\r\n\r\n## 4. OS-Level Sandboxing\r\n\r\nChromium runs its renderers and helper processes in strict OS sandboxes:\r\n\r\n| Platform | Mechanism                                          | Source Location                           |\r\n|----------|----------------------------------------------------|-------------------------------------------|\r\n| **Windows** | Job objects + restricted tokens                 | `sandbox/win/`                            |\r\n| **Linux**   | setuid “chrome-sandbox” or seccomp‐bpf filters  | `sandbox/linux/`                          |\r\n| **macOS**   | Seatbelt profiles                                | `sandbox/mac/`                            |\r\n\r\n- **Sandbox Brokers**  \r\n  - A minimal “broker” process handles syscalls (e.g. DNS, font enumeration) on behalf of the sandboxed child.  \r\n- **Key Files**  \r\n  - `sandbox_init.cc`  \r\n  - Platform‐specific policy headers under `sandbox/{win,linux,mac}/`.\r\n\r\n---\r\n\r\n## 5. Permissions & Feature Policy\r\n\r\n- **Permissions API**  \r\n  - JS interfaces for `geolocation`, `notifications`, `camera`, etc.  \r\n  - Backed by `PermissionController` in `content/browser/permissions/`.  \r\n- **Feature Policy / Permissions Policy**  \r\n  - Page‐level opt-in/opt-out controls which APIs iframes can use.  \r\n  - Defined via `FeaturePolicy` in Blink (`third_party/blink/renderer/core/feature_policy/`).  \r\n- **UI Prompt**  \r\n  - Browser UI for granting/denying lives in `chrome/browser/ui/permission_bubble/`.\r\n\r\n---\r\n\r\n## 6. Content Security Policy (CSP)\r\n\r\n- **CSP Headers**  \r\n  - Enforced by Blink’s `CSPContext` in `third_party/blink/renderer/core/loader/`.  \r\n  - Prevents inline script, remote code, or framing per site’s policy.  \r\n- **Reporting**  \r\n  - Violation reports sent via `ReportSender` to configured endpoints.  \r\n\r\n---\r\n\r\n## 7. Transport Security & Certificate Validation\r\n\r\n- **Trust Store**  \r\n  - Uses OS‐provided roots on Windows/macOS; Mozilla’s on Linux.  \r\n  - Managed in `net/cert/` (`cert_verifier.cc`, `root_store.cc`).  \r\n- **HSTS / HPKP**  \r\n  - HSTS enforced by `TransportSecurityState`.  \r\n  - HPKP deprecated but still present in some code paths.  \r\n- **OCSP & CRL Sets**  \r\n  - Stapled OCSP responses validated in `net/ocsp/`.  \r\n  - Chrome uses “CRLSet” updates via Safe Browsing service.\r\n\r\n---\r\n\r\n## 8. Safe Browsing & Malware Protection\r\n\r\n- **Phishing & Malware Lists**  \r\n  - Maintained by Google; downloaded to browser periodically.  \r\n  - Checks happen in `safe_browsing/` under `chrome/browser/`.  \r\n- **Interstitial UI**  \r\n  - Block pages with clear warnings.  \r\n  - Code in `chrome/browser/safe_browsing/`.  \r\n\r\n---\r\n\r\n## 9. Extension Security\r\n\r\n- **Isolated Worlds**  \r\n  - Content scripts run in separate V8 contexts with limited DOM access.  \r\n- **Permission Model**  \r\n  - Declared in `manifest.json`, enforced by `ExtensionPermission` classes.  \r\n- **Native Messaging**  \r\n  - Host apps communicate via a JSON‐over‐stdin bridge with strict path restrictions.\r\n\r\n---\r\n\r\n## 10. Developer Tools & Auditing\r\n\r\n- **chrome://security** (future) and `chrome://sandbox` pages  \r\n- **chrome://webrtc-internals** for inspecting WebRTC security parameters  \r\n- **Auditing Tools**  \r\n  - `chrome://policy` for Enterprise policy enforcement  \r\n  - Tracing categories: `SECURITY`, `NETWORK_SECURITY` in `chrome://tracing`\r\n\r\n---\r\n\r\n## 11. Testing & Hardening\r\n\r\n- **Unit & Integration Tests**  \r\n  - `content/browser/site_isolation_browsertest`  \r\n  - `security_interstitial_browsertest`  \r\n  - `sandbox_browsertest`  \r\n- **Fuzzing**  \r\n  - OSS-Fuzz integration for renderer, V8, PDFium, libogg, etc.  \r\n\r\n---\r\n\r\n## 12. Next Steps\r\n\r\n1. Read **Debugging → Debugging Tools** to learn how to trace sandbox violations.  \r\n2. Explore **Modules → Networking (HTTP)** for TLS handshake internals.  \r\n3. Dive into **Architecture → Process Model** to see how sandboxed processes communicate.  \r\n\r\n---\r\n"
  },
  {
    "path": "security/overview",
    "title": "Security & Safety",
    "content": "# Security & Safety\r\n\r\nWelcome to the Security section! This area covers the comprehensive security model and safety mechanisms implemented in the Wanderlust custom Chromium browser.\r\n\r\n## What You'll Find Here\r\n\r\nThis section provides essential security information:\r\n\r\n- **[Security Model](security-model.md)**: Comprehensive overview of browser security architecture and principles\r\n- **Sandboxing**: Process isolation and security boundaries\r\n- **Permission Management**: User permission systems and access controls\r\n- **Security Updates**: Keeping the browser secure with regular updates\r\n\r\n## Security Principles\r\n\r\nOur custom Chromium implementation follows these core security principles:\r\n\r\n### Defense in Depth\r\n- **Multiple Security Layers**: No single point of failure\r\n- **Process Isolation**: Separate processes for different security contexts\r\n- **Sandboxing**: Restricted execution environments for untrusted content\r\n- **Permission Models**: Granular control over resource access\r\n\r\n### Security by Design\r\n- **Least Privilege**: Components operate with minimal necessary permissions\r\n- **Secure Defaults**: Safe configurations out of the box\r\n- **Input Validation**: Comprehensive validation of all external inputs\r\n- **Secure Communication**: Encrypted channels for all sensitive data\r\n\r\n## Key Security Components\r\n\r\n### Process Security\r\n- **Site Isolation**: Each site runs in its own process\r\n- **Renderer Sandboxing**: Web content runs in restricted environments\r\n- **Privilege Separation**: Different privilege levels for different components\r\n\r\n### Network Security\r\n- **TLS/HTTPS**: Secure communication protocols\r\n- **Certificate Validation**: Robust certificate checking\r\n- **Mixed Content Protection**: Preventing insecure content on secure pages\r\n\r\n### Content Security\r\n- **Content Security Policy (CSP)**: Preventing code injection attacks\r\n- **Same-Origin Policy**: Controlling cross-origin resource access\r\n- **Subresource Integrity**: Ensuring resource authenticity\r\n\r\n## Security Threats and Mitigations\r\n\r\n### Common Attack Vectors\r\n- **Cross-Site Scripting (XSS)**: Mitigated through CSP and input sanitization\r\n- **Cross-Site Request Forgery (CSRF)**: Protected by SameSite cookies and tokens\r\n- **Code Injection**: Prevented through sandboxing and input validation\r\n- **Man-in-the-Middle**: Blocked by certificate pinning and HSTS\r\n\r\n### Browser-Specific Security\r\n- **Extension Security**: Secure extension architecture and permissions\r\n- **Download Protection**: Scanning and validation of downloaded files\r\n- **Safe Browsing**: Protection against malicious websites and downloads\r\n\r\n## Integration with Browser Architecture\r\n\r\nSecurity integrates deeply with:\r\n- [Architecture](../architecture/overview.md): Security boundaries in the process model\r\n- [Modules](../modules/overview.md): Security considerations for each module\r\n- [Debugging](../debugging/overview.md): Security-focused debugging techniques\r\n\r\n## Security Best Practices\r\n\r\nFor developers working on security-sensitive code:\r\n\r\n1. **Follow Security Guidelines**: Adhere to established security coding practices\r\n2. **Regular Security Reviews**: Code reviews with security focus\r\n3. **Security Testing**: Comprehensive testing including security scenarios\r\n4. **Stay Updated**: Keep informed about latest security threats and mitigations\r\n\r\n## Compliance and Standards\r\n\r\nOur security implementation follows:\r\n- **Web Security Standards**: W3C and WHATWG security specifications\r\n- **Industry Best Practices**: OWASP guidelines and recommendations\r\n- **Regulatory Requirements**: Compliance with relevant security regulations\r\n\r\n---\r\n\r\n*Start with our [security model documentation](security-model.md) to understand the foundational security architecture and principles.*\r\n"
  },
  {
    "path": "modules/storage-cache",
    "title": "Storage & Cache",
    "content": "# Storage & Cache\r\n\r\nEfficient storage and caching are critical to Chromium’s performance and user experience. This article covers both the low-level HTTP cache and higher-level web storage APIs, how they interact, and where to look in the source for each.\r\n\r\n---\r\n\r\n## 1. Overview\r\n\r\n- **Scope**  \r\n  - **HTTP Cache**: response caching for network requests  \r\n  - **In-Memory Cache**: fast lookup for small resources  \r\n  - **Web Storage**: LocalStorage, SessionStorage, IndexedDB, Cache API  \r\n  - **Quota & Storage Partitions**: per-origin isolation and limits  \r\n- **Goals**  \r\n  - **Performance**: avoid unnecessary network trips, disk I/O  \r\n  - **Correctness**: respect cache validation (ETags, freshness)  \r\n  - **Security**: isolate origin data, enforce quotas  \r\n\r\n---\r\n\r\n## 2. HTTP Cache (`net/disk_cache/` & `net/http/http_cache_*`)\r\n\r\n### 2.1 Architecture\r\n\r\n```text\r\nRenderer        Browser        Network Service\r\n   │               │                  │\r\n   └─URLLoader───▶│                  │\r\n           │      └──▶HttpCache───▶HttpNetworkTransaction──▶Socket\r\nHttpCache sits in between URLRequest and HttpNetworkTransaction.\r\n\r\nDisk Cache (LRU) implemented in net/disk_cache/simple/simple_entry_impl.cc.\r\n\r\nMemory Cache keeps small objects in RAM (SimpleBackend, MemBackendImpl).\r\n\r\n2.2 Key Files\r\nnet/http/http_cache.cc / .h\r\n\r\nnet/disk_cache/simple/simple_backend_impl.cc\r\n\r\nnet/disk_cache/backend_factory.h\r\n\r\n2.3 Eviction & Validation\r\nLRU eviction when size limit (default ~300 MB) is reached.\r\n\r\nCache-Control headers drive freshness; revalidate with ETag/Last-Modified.\r\n\r\nConditional Requests: 304 responses update stored entry metadata.\r\n\r\n3. Quota & Storage Partitions\r\n3.1 Storage Partitioning\r\nEach BrowserContext (Profile) has one or more StoragePartitions.\r\n\r\nPartitions isolate data by origin and by mode (e.g. default, incognito).\r\n\r\nDefined in content/browser/storage_partition_impl.cc.\r\n\r\n3.2 Quota Management\r\nQuotaManager (content/browser/quota/quota_manager_impl.cc)\r\n\r\nTracks usage per origin.\r\n\r\nEnforces soft/hard limits (default ~6 GB per origin on desktop).\r\n\r\nQuotaClient interfaces for each storage type (IndexedDB, FileSystem, Cache API).\r\n\r\n4. Web Storage APIs\r\n4.1 LocalStorage & SessionStorage\r\nLocalStorage stored in SQLite under Local Storage/ directory.\r\n\r\nSessionStorage tied to single top-level browsing context.\r\n\r\nCode lives in content/browser/dom_storage/ and content/renderer/dom_storage/.\r\n\r\n4.2 IndexedDB\r\nHigh-level object store, transactional.\r\n\r\nBacked by LevelDB in third_party/blink/renderer/modules/indexeddb/.\r\n\r\nQuota interactions via IndexedDBQuotaClient.\r\n\r\n4.3 Cache API (Service Workers)\r\nProgrammatic cache of Request/Response pairs.\r\n\r\nImplemented in service_worker/ under cache_storage/.\r\n\r\nUses the same DiskCache backend under the hood.\r\n\r\n5. Interaction with Network Stack\r\nCache-Control Overrides\r\n\r\nHTTP fetch in Service Workers can bypass the HTTP cache.\r\n\r\nStale-while-revalidate\r\n\r\nCustomizable via headers and Cache API strategies.\r\n\r\n6. Debugging & Instrumentation\r\nchrome://cache (legacy) or chrome://net-export for HTTP cache traces.\r\n\r\nchrome://quota-internals shows per-origin usage and limits.\r\n\r\nchrome://indexeddb-internals inspects IndexedDB databases.\r\n\r\nLogging flags:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --enable-logging=stderr --v=1 --log-net-log=netlog.json\r\n7. Testing & Tools\r\nUnit tests in net/disk_cache/ and content/browser/quota/.\r\n\r\nnet/tools/quic_client/ can test cache behavior over HTTP/3.\r\n\r\nUse storage_browsertest (in content/test/) to automate web storage scenarios.\r\n\r\n8. Best Practices & Extensions\r\nCache only what you can revalidate: avoid caching sensitive data.\r\n\r\nClean up on unload for SessionStorage in embedded contexts.\r\n\r\nCustom URLRequestJob to layer additional caching logic:\r\n\r\ncpp\r\nCopy\r\nEdit\r\nURLRequestFilter::GetInstance()->AddUrlInterceptor(\r\n    \"https://example.com/\", std::make_unique<MyCacheInterceptor>());\r\n9. Next Steps\r\nDive into Security → Security Model to see how origin isolation is enforced.\r\n\r\nExplore Modules → Networking (HTTP) to understand how HTTP caching hooks in.\r\n\r\nRead Debugging → Debugging Tools for end-to-end cache debugging patterns."
  },
  {
    "path": "modules/overview",
    "title": "Modules & Components",
    "content": "# Modules & Components\r\n\r\nWelcome to the Modules section! This area provides detailed documentation about the core modules and components that make up the Wanderlust custom Chromium browser.\r\n\r\n## What You'll Find Here\r\n\r\nThis section covers the major functional modules of our Chromium implementation:\r\n\r\n- **[JavaScript V8 Engine](javascript-v8.md)**: V8 JavaScript engine integration and customizations\r\n- **[Networking & HTTP](networking-http.md)**: Network stack, HTTP handling, and protocol implementations\r\n- **[Storage & Cache](storage-cache.md)**: Storage systems, caching mechanisms, and data persistence\r\n- **[Storage Cache Details](storage-cache/)**: In-depth storage cache implementation details\r\n\r\n## Module Architecture\r\n\r\nOur custom Chromium browser is built with a modular architecture where each module handles specific functionality:\r\n\r\n### Core Engine Modules\r\n- **V8 JavaScript Engine**: Handles JavaScript execution, optimization, and runtime management\r\n- **Networking Stack**: Manages all network communications, HTTP/HTTPS protocols, and connection handling\r\n- **Storage Systems**: Provides data persistence, caching, and storage management\r\n\r\n### Module Interactions\r\n\r\nEach module is designed to work independently while maintaining clean interfaces with other components:\r\n\r\n- **JavaScript ↔ Networking**: Script-initiated network requests and responses\r\n- **Networking ↔ Storage**: Caching network resources and managing cached content\r\n- **Storage ↔ JavaScript**: Persistent storage APIs accessible from web content\r\n\r\n## Understanding Module Documentation\r\n\r\nEach module documentation includes:\r\n- **Purpose and Responsibilities**: What the module does and why it exists\r\n- **API Interfaces**: Public interfaces and integration points\r\n- **Implementation Details**: Internal architecture and design decisions\r\n- **Configuration Options**: Customizable settings and parameters\r\n- **Performance Considerations**: Optimization strategies and performance tips\r\n\r\n## Development Guidelines\r\n\r\nWhen working with modules:\r\n\r\n1. **Understand Dependencies**: Review how modules interact with each other\r\n2. **Follow Interfaces**: Use established APIs and avoid direct internal access\r\n3. **Consider Performance**: Each module affects overall browser performance\r\n4. **Maintain Compatibility**: Ensure changes don't break other modules\r\n\r\n## Integration with Browser Architecture\r\n\r\nThese modules integrate with the broader browser architecture covered in:\r\n- [Architecture Overview](../architecture/overview.md): System-level design and process model\r\n- [Security Model](../security/overview.md): Security boundaries and sandboxing\r\n- [Debugging Tools](../debugging/overview.md): Module-specific debugging techniques\r\n\r\n## Module-Specific Resources\r\n\r\n- **JavaScript V8**: Engine internals, optimization, and script execution\r\n- **Networking**: Protocol handling, connection management, and network security\r\n- **Storage**: File systems, databases, caching strategies, and data management\r\n\r\n---\r\n\r\n*Explore individual modules to understand their specific implementations, or start with the [JavaScript V8 documentation](javascript-v8.md) for core engine functionality.*\r\n"
  },
  {
    "path": "modules/networking-http",
    "title": "Networking (HTTP)",
    "content": "# Networking (HTTP)\r\n\r\nChromium’s HTTP stack underpins all web communication. In this article we’ll trace an HTTP request from the browser down to the network, cover caching, QUIC, and show you where to hook in or inspect traffic.\r\n\r\n---\r\n\r\n## 1. Overview\r\n\r\n- **Components**  \r\n  - **Network Service** (`services/network/`)  \r\n  - **URLLoader / URLRequest** abstractions  \r\n  - **HTTP Cache** (`net/http/http_cache_*.cc`)  \r\n  - **QUIC & HTTP/2** via `net/quic/` and `net/spdy/`  \r\n- **Goals**  \r\n  - Performance: multiplexing, caching, prioritization  \r\n  - Security: TLS validation, safe headers  \r\n  - Flexibility: pluggable protocols, proxy support\r\n\r\n---\r\n\r\n## 2. The Network Service\r\n\r\nChromium runs its network stack in a separate process by default:\r\n\r\n```text\r\nBrowser Process  ←───Mojo───→  Network Service Process\r\nEntrypoint: services/network/network_service.cc\r\n\r\nIPC Interface: network_service.mojom\r\n\r\nManages global resources (DNS cache, socket pools, proxy config).\r\n\r\n3. URLLoader / URLRequest Lifecycle\r\nURLLoaderFactory\r\n\r\nCreated in the browser, sent over Mojo to Renderers.\r\n\r\nRenderer calls CreateLoaderAndStart().\r\n\r\nURLLoader\r\n\r\nImplements network::mojom::URLLoader.\r\n\r\nWraps a URLRequest (non-Mojo) or directly uses UrlLoader on non-NetworkService builds.\r\n\r\nURLRequest (net/url_request/url_request.cc)\r\n\r\nCore state machine: redirect handling, auth, retries.\r\n\r\nDelegates to HttpStreamFactory for transport.\r\n\r\ntext\r\nCopy\r\nEdit\r\nRenderer → URLLoader → URLRequest → HttpNetworkTransaction → Socket\r\n4. HTTP Transport\r\nHttpNetworkTransaction (net/http/http_network_transaction.cc)\r\n\r\nSerializes headers and body, parses responses.\r\n\r\nHonors HttpRequestHeaders, HttpResponseHeaders.\r\n\r\nConnection Pool (net/http/http_stream_factory.cc)\r\n\r\nReuses idle connections (keep-alive).\r\n\r\nCategorizes by host:port, proxy, SSL.\r\n\r\n5. HTTP/2 & QUIC\r\nChromium supports modern protocols for speed:\r\n\r\nHTTP/2 (SPDY)\r\n\r\nMultiplexed streams over a single TCP connection.\r\n\r\nImplementation under net/spdy/.\r\n\r\nQUIC (HTTP/3)\r\n\r\nRuns atop UDP.\r\n\r\nImplemented in net/quic/.\r\n\r\nHandshake, stream abstraction, congestion control.\r\n\r\nEnable via GN args:\r\n\r\ngn\r\nCopy\r\nEdit\r\nenable_http2=true\r\nenable_quic=true\r\n6. Caching Layer\r\nDisk Cache (net/disk_cache/)\r\n\r\nStores responses keyed by URL, vary headers.\r\n\r\nLRU eviction.\r\n\r\nMemory Cache\r\n\r\nFast cache of small responses.\r\n\r\nCache API Hooks\r\n\r\nHttpCache sits between URLRequest and HttpNetworkTransaction.\r\n\r\ntext\r\nCopy\r\nEdit\r\nURLRequest → HttpCache → (hit: serve; miss: HttpNetworkTransaction)\r\n7. Proxy & DNS Resolution\r\nProxy Configuration\r\n\r\nRead from system or PAC scripts (proxy_config_service.cc).\r\n\r\nDNS\r\n\r\nHostResolver API with built-in DNS cache.\r\n\r\nAsync lookups via dns_client.cc.\r\n\r\n8. Prioritization & Throttling\r\nResourceScheduler (net/http/resource_scheduler.cc)\r\n\r\nAssigns priorities (e.g. script > image).\r\n\r\nLimits max concurrent requests per host.\r\n\r\n9. Security & Certificate Validation\r\nCertVerifier (net/cert/cert_verifier.cc)\r\n\r\nValidates TLS certificates, OCSP stapling.\r\n\r\nTransportSecurityState\r\n\r\nHSTS, HPKP policies.\r\n\r\nSandbox\r\n\r\nSocket operations restricted by sandbox policy.\r\n\r\n10. Debugging & Instrumentation\r\nLogging\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --enable-logging=stderr --v=1\r\nchrome://net-internals (legacy) or chrome://net-export\r\n\r\nTracing\r\n\r\nNET_LOG category in chrome://tracing.\r\n\r\nUnit Tests\r\n\r\nUnder net/http/ and net/tools/quic_client/.\r\n\r\n11. Extensions & Hooks\r\nIf you want to inject custom behavior:\r\n\r\nURLRequestJob\r\n\r\nCreate a factory via URLRequestFilter::RegisterProtocolHandler.\r\n\r\nNetworkDelegate\r\n\r\nIntercept headers, auth events in NetworkService.\r\n\r\n12. Next Steps\r\nDeep dive: Modules → Storage & Cache to see how responses are stored.\r\n\r\nExplore Security → Security Model for TLS sandbox details.\r\n\r\nExperiment: build with enable_quic=true and capture QUIC frames with Wireshark."
  },
  {
    "path": "modules/javascript-v8",
    "title": "JavaScript (V8)",
    "content": "# JavaScript (V8)\r\n\r\nChromium embeds Google’s high-performance V8 JavaScript engine to power all script execution in web pages and browser internals. This article explores how V8 fits into Chromium’s architecture, its compilation & execution pipeline, memory management, embedding APIs, and debugging tools.\r\n\r\n---\r\n\r\n## 1. Role of V8 in Chromium\r\n\r\n- **Where it lives**  \r\n  - In the **renderer process**, under `src/third_party/v8/`  \r\n  - Blink calls into V8 via the **V8 embedder APIs** in `content/renderer/v8_*`  \r\n- **What it does**  \r\n  - Parses, compiles, and executes all JavaScript on web pages  \r\n  - Runs extension & internal scripts (e.g. DevTools, PDF viewer)  \r\n\r\n---\r\n\r\n## 2. V8 Engine Architecture\r\n\r\n```text\r\nJavaScript Source\r\n      ↓\r\n LEXING / PARSING\r\n      ↓           ↘\r\n  AST           ↘  BYTECODE (Ignition)\r\n      ↓              ↓\r\n  TURBOFan IR ← OPTIMIZING COMPILER\r\n      ↓\r\nNATIVE MACHINE CODE\r\nParser & AST\r\n\r\nparser.cc builds the Abstract Syntax Tree.\r\n\r\nUses “pre-parsing” to quickly skip heavy functions.\r\n\r\nIgnition Interpreter\r\n\r\nBytecode generator (bytecode-generator.cc) produces compact bytecodes.\r\n\r\nInterpreter (interpreter.cc) executes without initial machine-code compile.\r\n\r\nTurbofan Optimizing Compiler\r\n\r\nHot functions are profiled, then passed through Turbofan (turbofan/)\r\n\r\nGenerates highly optimized machine code.\r\n\r\nDeoptimization & On-Stack Replacement\r\n\r\nIf assumptions break (e.g. type change), deopt back to baseline.\r\n\r\n3. Memory Management & Garbage Collection\r\nHeaps & Spaces\r\n\r\nYoung Generation (Scavenge, Semi-Spaces)\r\n\r\nOld Generation (Mark-Sweep, Mark-Compact)\r\n\r\nLarge Object Space\r\n\r\nIncremental & Concurrent GC\r\n\r\nScavenges small heaps quickly\r\n\r\nMarks & compacts old generation on background threads\r\n\r\nHandles & LocalHandles\r\n\r\nC++ wrappers ensuring safe pointer movement across GCs\r\n\r\n4. V8 Embedding in Chromium\r\nIsolates (v8::Isolate)\r\n\r\nOne per renderer process by default; isolates encapsulate heaps & contexts.\r\n\r\nContexts (v8::Context)\r\n\r\nExecute code in separate global object environments (e.g. <iframe>).\r\n\r\nBindings & Templates\r\n\r\nNative classes/functions exposed to JS via FunctionTemplate and ObjectTemplate.\r\n\r\nBlink defines DOM APIs by wiring its C++ implementations to V8.\r\n\r\nMicrotasks & Promise Hooks\r\n\r\nChromium pumps the microtask queue between tasks to implement Promises.\r\n\r\n5. Compilation & Startup\r\nSnapshotting\r\n\r\nStartup snapshot captures pre-compiled builtins & standard library for faster cold starts.\r\n\r\nBuild Flags\r\n\r\nControlled via GN args:\r\n\r\ngn\r\nCopy\r\nEdit\r\nv8_enable_pointer_compression = true\r\nv8_enable_slow_dchecks = false\r\nv8_static_rooting = true\r\nDebug vs Release\r\n\r\nDebug builds include extra checks, slower GC; release builds optimize for speed.\r\n\r\n6. Debugging & Profiling\r\nDevTools Protocol\r\n\r\nV8 exposes the Debugger, Profiler, and Heap domains.\r\n\r\nConnect via chrome://inspect or embed custom tools.\r\n\r\nCPU & Memory Profiles\r\n\r\nCapture JS call stacks, optimize hotspots in Turbofan.\r\n\r\nHeap snapshots to find leaks.\r\n\r\nLogging & Flags\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --js-flags=\"--trace-gc --trace-opt --prof\"\r\nExternal Tools\r\n\r\nHeap Inspector, d8 shell for iterative testing.\r\n\r\n7. Web Workers & Service Workers\r\nWorker Contexts\r\n\r\nEach worker spawns its own V8 isolate & event loop.\r\n\r\nShared ArrayBuffer & Atomics\r\n\r\nEnables parallel JS with shared memory.\r\n\r\n8. Compatibility & Standards\r\nECMAScript Versions\r\n\r\nV8 keeps pace with ES6+ features: modules, async/await, proxies, BigInt.\r\n\r\nWebAssembly\r\n\r\nIntegrated via wasm.cc modules; both interpreter and tier-up compilation.\r\n\r\n9. Extending & Hooking In\r\nCustom Builtins\r\n\r\nAdd new functions by extending V8’s builtins in src/third_party/v8/src/builtins.\r\n\r\nInspector API\r\n\r\nEmbed the Inspector protocol in other tools or integrations.\r\n\r\nFlags & Experiments\r\n\r\nFeature-flag new JS proposals before standardization.\r\n\r\n10. Next Steps\r\nRead Modules → Storage & Cache to see how JS resources (scripts, modules) are cached.\r\n\r\nExplore Debugging → Debugging Tools for end-to-end JS debugging setups.\r\n\r\nClone and play with the d8 shell in third_party/v8/tools/d8 for hands-on experimentation.\r\n\r\n"
  },
  {
    "path": "modules/storage-cache/overview",
    "title": "Storage Cache Implementation",
    "content": "# Storage Cache Implementation\r\n\r\nWelcome to the Storage Cache detailed implementation section! This area provides in-depth technical documentation about the storage and caching systems used in the Wanderlust custom Chromium browser.\r\n\r\n## What You'll Find Here\r\n\r\nThis section contains detailed implementation documentation:\r\n\r\n- **[Disk Cache Design Principles](disk-cache-design-principles.md)**: Core principles and design decisions for disk-based caching\r\n- **Cache Architecture**: Detailed technical architecture of the storage cache system\r\n- **Performance Optimization**: Strategies for optimizing cache performance and efficiency\r\n- **Cache Management**: Policies for cache eviction, cleanup, and maintenance\r\n\r\n## Storage Cache Overview\r\n\r\nThe storage cache system is a critical component that provides:\r\n\r\n### Core Functionality\r\n- **Resource Caching**: Efficient storage and retrieval of web resources\r\n- **Disk Management**: Intelligent disk space usage and management\r\n- **Performance Optimization**: Fast access to frequently used resources\r\n- **Memory Efficiency**: Balanced memory and disk usage strategies\r\n\r\n### Cache Types\r\n- **HTTP Cache**: Standard HTTP caching for web resources\r\n- **Application Cache**: Offline application resource storage\r\n- **Service Worker Cache**: Programmatic cache management for PWAs\r\n- **Browser Cache**: Internal browser resource caching\r\n\r\n## Technical Architecture\r\n\r\n### Cache Hierarchy\r\n1. **Memory Cache**: Fast RAM-based caching for immediate access\r\n2. **Disk Cache**: Persistent storage for long-term resource caching\r\n3. **Network Fallback**: Fetch from network when cache misses occur\r\n\r\n### Storage Strategies\r\n- **LRU Eviction**: Least Recently Used cache eviction policies\r\n- **Size Management**: Intelligent cache size limits and management\r\n- **Compression**: Resource compression for efficient storage\r\n- **Indexing**: Fast lookup and retrieval mechanisms\r\n\r\n## Implementation Details\r\n\r\n### Design Principles\r\nThe storage cache follows specific design principles outlined in:\r\n- [Disk Cache Design Principles](disk-cache-design-principles.md): Fundamental design decisions and rationale\r\n\r\n### Performance Considerations\r\n- **Access Patterns**: Optimized for common web browsing patterns\r\n- **Concurrency**: Thread-safe operations for multi-process access\r\n- **I/O Optimization**: Efficient disk read/write operations\r\n- **Memory Management**: Careful memory usage to avoid system impact\r\n\r\n## Integration Points\r\n\r\n### Module Integration\r\nThe storage cache integrates with:\r\n- **Networking Module**: Caching network responses and resources\r\n- **JavaScript Engine**: Providing cached resources to script execution\r\n- **Rendering Engine**: Fast access to cached stylesheets, images, and assets\r\n\r\n### Browser Architecture\r\n- **Process Model**: Cache access across different browser processes\r\n- **Security Boundaries**: Secure cache isolation between origins\r\n- **Resource Loading**: Integration with the browser's resource loading pipeline\r\n\r\n## Development and Debugging\r\n\r\n### Cache Debugging\r\n- **Cache Inspection**: Tools for examining cache contents and state\r\n- **Performance Monitoring**: Tracking cache hit rates and performance metrics\r\n- **Debug Interfaces**: Internal pages for cache analysis and debugging\r\n\r\n### Configuration Options\r\n- **Cache Policies**: Configurable caching behaviors and policies\r\n- **Size Limits**: Adjustable cache size limits and thresholds\r\n- **Debugging Flags**: Development flags for cache debugging and analysis\r\n\r\n## Related Documentation\r\n\r\nFor broader context, see:\r\n- [Storage & Cache Overview](../storage-cache.md): High-level storage and cache documentation\r\n- [Modules Overview](../overview.md): How storage fits into the overall module architecture\r\n- [Architecture](../../architecture/overview.md): System-level cache architecture\r\n- [Debugging](../../debugging/overview.md): Tools for cache debugging and analysis\r\n\r\n---\r\n\r\n*Begin with the [disk cache design principles](disk-cache-design-principles.md) to understand the fundamental design decisions behind our storage cache implementation.*\r\n"
  },
  {
    "path": "modules/storage-cache/disk-cache-design-principles",
    "title": "Disk Cache Design Principles",
    "content": "# Disk Cache Design Principles\r\n\r\nThis deep-dive covers Chromium’s on-disk cache: its goals, on-disk format, key interfaces, and implementation notes.\r\n\r\n---\r\n\r\n## 1. Overview\r\n\r\nThe disk cache stores web-fetched resources for fast later access. Key characteristics:\r\n\r\n- **Size Bound**  \r\n  The cache must not grow without limit; an eviction algorithm decides when to remove old entries.\r\n- **Crash Resilience**  \r\n  Survives application crashes by discarding only entries in use at crash time. A full system crash may still wipe the entire cache.\r\n- **Efficient Access**  \r\n  Supports both synchronous and asynchronous operations with low latency.\r\n- **Conflict Avoidance**  \r\n  Layout prevents simultaneous-store conflicts (cache thrashing).\r\n- **Entry Removal**  \r\n  Individual entries can be removed; existing handles continue to function, and new opens fail as if the entry never existed.\r\n- **Single-threaded Assumption**  \r\n  Callers share one thread; callbacks are posted on the thread’s message loop to avoid reentrancy.\r\n\r\n---\r\n\r\n## 2. External Interfaces\r\n\r\nChromium’s cache API (in `src/net/disk_cache/disk_cache.h`) exposes:\r\n\r\n- **`disk_cache::Backend`**  \r\n  Enumerate entries, open existing or create new entries.\r\n- **`disk_cache::Entry`**  \r\n  Read/write data streams for a single resource.\r\n\r\nEach entry has a unique key (e.g., `http://example.com/favicon.ico`). Data is stored in separate streams (HTTP headers vs. payload), indexed by stream ID in `Entry::ReadData`/`WriteData`.\r\n\r\n---\r\n\r\n## 3. On-Disk Format\r\n\r\nAll cache files live under a `cache/` directory. Chromium uses at least:\r\n\r\n- **1 Index File**  \r\n  Contains a memory-mapped hash table mapping keys to addresses.\r\n- **≥4 Block-Files** (`data_n`)  \r\n  Store fixed-size blocks (e.g., 256 B). Each file grows by 1 KB-aligned increments and chains to same-size files via headers.\r\n- **Separate Files** (`f_xx`)  \r\n  Resources > 16 KB bypass block-files and live in standalone files.\r\n\r\n### 3.1 Cache Address\r\n\r\nA 32-bit value directing to:\r\n\r\n- A block-file (file number, start block, block count, block type)\r\n- A separate file (hex identifier)\r\n\r\nDefined in `disk_cache/addr.h`, it enables unified handling of diverse data.\r\n\r\n### 3.2 Index File Structure\r\n\r\nDefined in `disk_cache/disk_format.h`:\r\n\r\n```text\r\nIndexHeader\r\nHashTable (size ≥ kIndexTableSize, actual length in header.table_len)\r\n```\r\n\r\n- Memory-mapped for rapid key→address lookup (using low-order hash bits).\r\n- Header includes magic number + major/minor version; a major bump is incompatible.\r\n\r\n### 3.3 Block-File Structure\r\n\r\nAlso in `disk_cache/disk_format.h`:\r\n\r\n- **Header (8 KB)**: memory-mapped bitmap tracks up to ~64K blocks.\r\n- **Data blocks**: fixed size (e.g., 256 B). Files grow by 1 024 blocks until full, then link to a new file of same block size via `next_file`.\r\n\r\nBlocks align on 4-block boundaries to simplify allocation:\r\n\r\n1. A record uses 1–4 contiguous blocks.  \r\n2. Allocations jump to the next aligned region if needed.  \r\n\r\nHeader fields `empty_slots` and `hints` optimize allocation and detect crashes mid-update.\r\n\r\n### 3.4 Cache Entry Layout\r\n\r\nEach entry splits into two structures:\r\n\r\n- **`EntryStore`** (1–4 blocks of 256 B)  \r\n  Stores key hash, stream addresses, pointer to next collision, and optional out-of-line key pointer.\r\n- **`RankingsNode`** (36 B, its own block-files)  \r\n  Tracks eviction metadata; marked in-use while open.\r\n\r\n### 3.5 The Big Picture\r\n\r\nA typical cache has:\r\n\r\n1. One index file  \r\n2. Multiple block-files (256 B, 1 KB, 4 KB) chained by size  \r\n3. Separate files for large payloads\r\n\r\nEntries link across streams and files via cache addresses.  \r\n![](../../../img/modules/the-big-picture.png)\r\n\r\n---\r\n\r\n## 4. Implementation Notes\r\n\r\n### 4.1 Two Backends\r\n\r\n- **Disk-based** (`disk_cache/backend_impl.cc`, `entry_impl.cc`)  \r\n- **In-memory** (`disk_cache/mem_backend_impl.cc`) for Incognito mode\r\n\r\nCache types (media, AppCache, general) share APIs but may differ in eviction.\r\n\r\n### 4.2 Lower-Level I/O\r\n\r\nOS abstractions in `disk_cache/file.h` & `mapped_file.h`.  \r\n`disk_cache::BlockFiles` manages block-file access.  \r\n`StorageBlock<T>` template handles loading/storing of `EntryStore` or `RankingsNode`.\r\n\r\n### 4.3 Eviction\r\n\r\n- **Ranking lists**: `disk_cache/rankings` (and `mem_rankings`).  \r\n- **Eviction logic**: `disk_cache/eviction` implements LRU and reuse/age-aware variants.  \r\n- **Transactions**: ensure consistency across crashes.  \r\n- **Multiple lists** by reuse frequency plus a “recently evicted” list.\r\n\r\n### 4.4 Buffering\r\n\r\n- Buffers up to 16 KB per stream before first disk write.  \r\n- Grows to 1 MB or a global cap.  \r\n- Minimizes disk I/O for small entries and computes record size for address allocation.\r\n\r\n### 4.5 Deleting Entries\r\n\r\n- `Doom*()` methods mark entries for deferred deletion after all handles close.  \r\n- Doomed entries removed from index; new opens create fresh entries.\r\n\r\n### 4.6 Enumeration\r\n\r\n- Example: `URLRequestViewCacheJob` iterates entries (order not guaranteed, can be slow).\r\n\r\n### 4.7 Sparse Data\r\n\r\n- Supports two streams: regular + sparse.  \r\n- Sparse data split into child entries linked from a parent (`disk_cache/sparse_control`).\r\n\r\n### 4.8 Dedicated Cache Thread\r\n\r\n- A background cache thread handles file I/O, offloading the browser I/O thread (IPC/UI).  \r\n- Uses task posting (`in_flight_io` / `in_flight_backend_io`).  \r\n- No locking: some calls (e.g. `GetDataSize`) may race with writes.\r\n\r\n---\r\n\r\n## 5. Data Integrity\r\n\r\nBalancing performance vs. crash resilience:\r\n\r\n- Leverages OS file-cache; no journaling to avoid complexity.  \r\n- Memory-mapped headers flush latest state on crash.  \r\n- On system crash, eviction lists may corrupt; the fallback is to discard the cache rather than risk inconsistency.\r\n\r\n*End of Disk Cache Design Principles Deep Dive*\r\n\r\n"
  },
  {
    "path": "introduction/overview",
    "title": "Chromium Knowledge Base Overview (v134+)",
    "content": "# Chromium Knowledge Base Overview (v134+)\r\n\r\nWelcome to the **Wanderlust Knowledge Base**! This comprehensive resource is designed to help you navigate, understand, and contribute to modern Chromium's sophisticated codebase and the **custom-browser project** built upon it.\r\n\r\n---\r\n\r\n## 1. What Is Modern Chromium? (v134+)\r\n\r\n- **Definition**  \r\n  Chromium is the cutting-edge open-source browser engine powering Google Chrome, Microsoft Edge, Opera, Brave, and our **custom-browser project**. As of v134+, it represents one of the most sophisticated software architectures ever built.\r\n\r\n- **Modern Goals & Achievements**  \r\n  – **Performance Excellence**: 60+ FPS rendering, sub-100ms navigation, Core Web Vitals optimization  \r\n  – **Advanced Security**: Site isolation, Control Flow Integrity (CFI), Privacy Sandbox integration  \r\n  – **Cross-Platform Mastery**: Windows, macOS, Linux, Chrome OS, Android, iOS with platform-specific optimizations  \r\n  – **Web Standards Leadership**: WebGPU, WebAssembly, Progressive Web Apps, and emerging APIs  \r\n\r\n- **v134+ Evolution & Community**  \r\n  – **Origin**: Started by Google in 2008, now a massive collaborative effort  \r\n  – **Modern Scale**: 25+ million lines of code, 1000+ daily commits, global contributor network  \r\n  – **Contribution Ecosystem**: Chromium Bug Tracker, Gerrit code review, specialized mailing lists  \r\n  – **Innovation Hub**: Driving web platform evolution and browser technology advancement  \r\n\r\n---\r\n\r\n## 2. Why Explore Modern Chromium Source? (v134+)\r\n\r\n- **Advanced Learning Opportunities**  \r\n  – **Modern C++20/23 Practices**: Template metaprogramming, memory safety, performance optimization  \r\n  – **Service-Oriented Architecture**: Microservice design with Mojo IPC, process coordination  \r\n  – **Graphics & Rendering**: Viz compositor, GPU acceleration, advanced rendering pipelines  \r\n  – **Security Engineering**: Multi-layered security, sandboxing, exploit mitigation techniques  \r\n\r\n- **Professional Development**  \r\n  – **Performance Engineering**: Memory optimization, threading, real-time systems  \r\n  – **Cross-Platform Development**: Platform abstraction, native integration, responsive design  \r\n  – **Large-Scale Software Architecture**: Managing complexity, modularity, maintainability  \r\n  – **Web Technology Innovation**: Implementing cutting-edge web standards and APIs  \r\n\r\n- **Custom Browser Development**  \r\n  – **Feature Implementation**: Adding custom functionality to browser components  \r\n  – **Performance Tuning**: Optimizing for specific use cases and hardware configurations  \r\n  – **Security Enhancements**: Implementing additional security layers and privacy features  \r\n  – **Integration Possibilities**: Connecting with external services, APIs, and platforms  \r\n\r\n---\r\n\r\n## 3. Modern Multi-Process Architecture (v134+)\r\n\r\nChromium's sophisticated architecture has evolved significantly:\r\n\r\n### Core Processes\r\n- **Browser Process**: Central coordinator with enhanced UI management and service orchestration\r\n- **Renderer Processes**: Site-isolated content rendering with strict security boundaries\r\n- **GPU Process**: Unified Viz compositor with Out-of-Process Rasterization (OOP-R)\r\n- **Network Service**: Dedicated network process with HTTP/3 and QUIC support\r\n\r\n### Modern Service Ecosystem\r\n- **Audio Service**: Isolated audio processing and hardware acceleration\r\n- **Storage Service**: Centralized data management with enhanced privacy controls\r\n- **Device Service**: Secure hardware access with permission management\r\n- **ML Service**: On-device machine learning with TensorFlow Lite integration\r\n- **Utility Processes**: Sandboxed processing for various specialized tasks\r\n\r\n### Advanced Features (v134+)\r\n- **Site Isolation**: Per-origin process boundaries for enhanced security\r\n- **Mojo IPC**: Type-safe inter-process communication with capability-based security\r\n- **Service Manager**: Intelligent service coordination and dependency management\r\n- **Enhanced Sandboxing**: Platform-specific security with CFI and memory protection\r\n\r\n_(Explore detailed sections: [Process Model](../architecture/process-model.md), [Render Pipeline](../architecture/render-pipeline.md), [IPC Internals](../architecture/ipc-internals.md))_\r\n\r\n---\r\n\r\n## 4. Custom-Browser Project Structure\r\n\r\nOur enhanced directory layout integrates custom modifications with upstream Chromium:\r\n\r\n```text\r\ncustom-browser/\r\n├── .gclient                 # Chromium source synchronization\r\n├── package.json             # Project configuration and dependencies\r\n├── requirements.txt         # Python development tools\r\n├── lib/                     # Python utilities and development tools\r\n│   ├── logger.py           # Advanced console logging with colors\r\n│   └── utils.py            # Common utility functions\r\n├── scripts/                # Automation and build scripts\r\n│   └── init.py             # Project initialization and setup\r\n├── patches/                # Custom Chromium modifications\r\n├── docs/                   # Project-specific documentation\r\n└── src/                    # Chromium source tree with enhancements\r\n    ├── chrome/             # Browser UI and Chrome-specific features\r\n    ├── content/            # Core browser engine and renderer\r\n    ├── custom/             # 🎯 Our custom browser modifications\r\n    ├── components/         # Reusable feature modules\r\n    ├── services/           # Modern Mojo-based services\r\n    ├── third_party/        # External dependencies (Blink, V8, Skia)\r\n    ├── net/               # Advanced networking (HTTP/3, QUIC, DNS)\r\n    ├── gpu/               # Graphics and Viz compositor\r\n    ├── ui/                # Cross-platform UI framework\r\n    ├── base/              # Fundamental utilities and abstractions\r\n    └── build/             # Build system and configuration\r\n```\r\n\r\n### Key Integration Points\r\n- **`src/custom/`**: Our browser enhancements and modifications\r\n- **`lib/`**: Development tools specific to our workflow\r\n- **`scripts/`**: Project automation and initialization\r\n- **`patches/`**: Required patches to upstream Chromium\r\n\r\n---\r\n\r\n## 5. Modern Web Technologies & Features (v134+)\r\n\r\n### Cutting-Edge Web APIs\r\n- **WebGPU**: Next-generation graphics API with compute shader support\r\n- **WebAssembly (WASM)**: High-performance code execution with SIMD and threading\r\n- **Origin Private File System**: Secure file system access for web applications\r\n- **Web Locks**: Cross-tab coordination and resource management\r\n- **Web Streams**: Efficient data processing with backpressure handling\r\n\r\n### Privacy & Security Innovations\r\n- **Privacy Sandbox**: Cookieless advertising with Topics API and FLEDGE\r\n- **Trust Tokens**: Anti-fraud mechanisms without fingerprinting\r\n- **Attribution Reporting**: Privacy-preserving conversion measurement\r\n- **Enhanced Site Isolation**: Protection against Spectre-style attacks\r\n\r\n### Performance Optimizations\r\n- **Core Web Vitals**: LCP, FID, CLS optimization at the engine level\r\n- **Navigation API**: Smooth page transitions with shared element animations\r\n- **Container Queries**: Responsive design without layout thrashing\r\n- **CSS Cascade Layers**: Advanced styling control and organization\r\n\r\n---\r\n\r\n## 6. Development Workflow & Tools (v134+)\r\n\r\n### Getting Started\r\n1. **Environment Setup**: `npm run install:python` for development tools\r\n2. **Project Initialization**: `npm run init` to fetch Chromium and dependencies\r\n3. **Build Configuration**: `gn gen out/Default` with modern build options\r\n4. **Compilation**: `ninja -C out/Default chrome` for browser executable\r\n\r\n### Modern Development Tools\r\n- **Advanced Debugging**: Chrome DevTools integration with process inspection\r\n- **Performance Profiling**: Real-time Core Web Vitals measurement\r\n- **Security Analysis**: Comprehensive sandbox and IPC monitoring\r\n- **Code Navigation**: Intelligent cross-referencing and documentation\r\n\r\n### Essential Debugging Resources\r\n```bash\r\n# Modern debugging pages\r\nchrome://gpu/              # GPU capabilities and Viz status\r\nchrome://process-internals/ # Process and service monitoring\r\nchrome://tracing/          # Advanced performance timeline\r\nchrome://mojo-internals/   # IPC and service inspection\r\nchrome://components/       # Component status and versions\r\n```\r\n\r\n---\r\n\r\n## 7. Learning Paths & Next Steps\r\n\r\n### For New Developers\r\n1. **Start Here**: [Project Layout](../getting-started/project-layout.md) - Understanding the codebase structure\r\n2. **Architecture Deep Dive**: [Browser Components](../architecture/browser-components.md) - Modern component overview\r\n3. **Hands-On**: [Setup & Build](../getting-started/setup-build.md) - Get your development environment running\r\n\r\n### For Advanced Contributors\r\n1. **Process Architecture**: [Process Model](../architecture/process-model.md) - Multi-process design and security\r\n2. **Rendering Engine**: [Render Pipeline](../architecture/render-pipeline.md) - From HTML to pixels\r\n3. **Communication**: [IPC Internals](../architecture/ipc-internals.md) - Mojo and modern IPC patterns\r\n\r\n### Specialized Topics\r\n- **Security**: [Security Model](../security/security-model.md) - Sandboxing and exploit mitigation\r\n- **Networking**: [HTTP & Networking](../modules/networking-http.md) - Modern network stack\r\n- **Storage**: [Storage & Cache](../modules/storage-cache.md) - Data persistence and privacy\r\n- **JavaScript**: [V8 Integration](../modules/javascript-v8.md) - JavaScript engine internals\r\n\r\n---\r\n\r\n## 8. Community & Contribution\r\n\r\n### Stay Connected\r\n- **Chromium Blog**: Latest architectural decisions and feature announcements\r\n- **Chrome Platform Status**: Track implementation of new web standards\r\n- **Chromium Groups**: Specialized mailing lists for different areas of development\r\n\r\n### Contributing Guidelines\r\n- **Code Style**: Follow Chromium's comprehensive style guide\r\n- **Testing**: Implement thorough unit and integration tests\r\n- **Documentation**: Update relevant documentation with code changes\r\n- **Security**: Consider security implications for all modifications\r\n\r\n### Custom Browser Development\r\n- **Feature Planning**: Design features that integrate cleanly with Chromium's architecture\r\n- **Upstream Compatibility**: Maintain compatibility with Chromium updates\r\n- **Performance**: Profile and optimize custom features for production use\r\n- **Security**: Implement security reviews for all custom functionality\r\n\r\n---\r\n\r\n**Welcome to the future of browser development!** This knowledge base will guide you through the intricacies of modern Chromium architecture and help you build exceptional browsing experiences with the custom-browser project.\r\n\r\n**Quick Links**:\r\n- 🚀 [Get Started](../getting-started/setup-build.md)\r\n- 🏗️ [Architecture Overview](../architecture/browser-components.md)\r\n- 🔧 [Development Guide](../getting-started/project-layout.md)\r\n- 🛡️ [Security Model](../security/security-model.md)\r\n"
  },
  {
    "path": "getting-started/setup-build",
    "title": "Setup & Build",
    "content": "# Setup & Build\r\n\r\nThis guide shows you how to fetch, build, and run Chromium from source on **Linux**, **macOS**, or **Windows**.\r\n\r\n---\r\n\r\n## 1. Prerequisites\r\n\r\nBefore you begin, make sure you have:\r\n\r\n- A supported OS:\r\n  - **Linux**: Ubuntu 20.04+ or equivalent\r\n  - **macOS**: 10.15+ (Intel or Apple Silicon)\r\n  - **Windows**: 10 (x64)\r\n- **Disk space**: At least 30 GB free\r\n- **RAM**: ≥ 8 GB (16 GB+ recommended)\r\n- **Tools**:\r\n  - **Python 3.8+** (for build scripts)\r\n  - **Git** (2.25+)\r\n  - **Depot Tools** (Google’s repo of Chromium helper scripts)\r\n\r\n### 1.1 Installing Depot Tools\r\n\r\n```bash\r\n# Clone Depot Tools somewhere in your PATH:\r\ngit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git ~/depot_tools\r\nexport PATH=\"$PATH:$HOME/depot_tools\"\r\n# (Add the export line to your shell rc: ~/.bashrc, ~/.zshrc, or PowerShell profile)\r\n```\r\n\r\n## 2. Fetching the Source\r\n\r\n### 2.1 Create a working directory:\r\n\r\n```bash\r\nmkdir -p ~/chromium && cd ~/chromium\r\n```\r\n\r\n### 2.2 Fetch the code:\r\n\r\n```bash\r\nfetch --nohooks chromium\r\ncd src\r\n```\r\n\r\n### 2.3 Install additional hooks:\r\n\r\n```bash\r\ngclient sync --with_branch_heads --with_tags\r\n```\r\n\r\n## 3. Configuring Your Build\r\n\r\nChromium uses GN for meta-build configuration and Ninja as the build engine.\r\n\r\n### 3.1 Generate build files:\r\n\r\n```bash\r\ngn gen out/Default --args='\r\n  is_debug=false            # or true for a debug build\r\n  symbol_level=1            # 0=no symbols, 1=debug symbols only\r\n  is_component_build=true   # modules are built as shared libs\r\n'\r\n```\r\n\r\n### 3.2 Common args:\r\n\r\n```text\r\nis_debug=true               # Debug build (with assertions & logging)\r\nis_official_build=false     # Disable Google-branded splash screens\r\nenable_nacl=false           # Disable Native Client (optional)\r\nremove_webcore_debug_symbols=true  # Strip extra symbols\r\n```\r\n\r\n### 4. Building\r\n\r\nFrom the src/ directory:\r\n\r\n```bash\r\nninja -C out/Default chrome\r\n```\r\n\r\n- -C out/Default tells Ninja where your build files live.\r\n- chrome is the target; you can also build content_shell, browser_tests, etc.\r\n\r\nTip: On multi-core machines you can speed up builds:\r\n\r\n```bash\r\nninja -C out/Default -j8\r\n```\r\n\r\n(where 8 ≈ number of CPU cores)\r\n\r\n## 5. Running Your Build\r\n\r\n- Linux & macOS:\r\n\r\n```bash\r\nout/Default/chrome        # Launches your custom build\r\n```\r\n\r\n- Windows (PowerShell):\r\n\r\n```powershell\r\n.\\out\\Default\\chrome.exe\r\n```\r\n\r\nYou can pass any Chromium CLI flags, for example:\r\n\r\n```bash\r\nout/Default/chrome --enable-logging --v=1\r\n```\r\n\r\n## 6. Iterating & Incremental Builds\r\n\r\nAfter code changes, simply rerun:\r\n\r\n```bash\r\nninja -C out/Default\r\n```\r\n\r\nNinja only rebuilds what’s necessary, so incremental iterations are fast.\r\n\r\n## 7. Common Issues & Troubleshooting\r\n\r\nSymptom\tPossible Fix\r\nfetch is not found\tEnsure depot_tools is in your PATH\r\ngclient sync errors out\tDelete src/.gclient_entries and retry\r\nGN complains about bad args\tRun gn args out/Default --list to verify flags\r\nOut-of-memory during build\tLower -j jobs or increase swap space\r\n\r\n## 8. Next Steps\r\n\r\n- Dive into Project Layout: see how src/ is organized\r\n- Explore Architecture → Process Model: understand multi-process design\r\n- Try a Debug Build and play with logging flags\r\n\r\n"
  },
  {
    "path": "getting-started/project-layout",
    "title": "Project Layout",
    "content": "# Project Layout\r\n\r\nThe custom-browser project is a Chromium-based browser implementation with a structured development environment. This guide provides a comprehensive tour of the project's directories and files to help you navigate and understand the codebase effectively.\r\n\r\n---\r\n\r\n## 1. Top-Level Structure\r\n\r\n```text\r\ncustom-browser/\r\n├── .gclient                 # gclient configuration for Chromium sync\r\n├── .gitignore               # files to ignore in Git\r\n├── package.json             # project configuration and npm scripts\r\n├── package-lock.json        # locked npm dependencies\r\n├── requirements.txt         # Python dependencies\r\n├── .npmrc                   # npm configuration\r\n├── README.md                # project overview and setup guide\r\n├── lib/                     # Python utilities and libraries\r\n├── scripts/                 # automation and build scripts\r\n├── patches/                 # Chromium patches and modifications\r\n├── docs/                    # project documentation (currently empty)\r\n└── src/                     # Chromium source code and custom modules\r\n```\r\n\r\n### Configuration Files\r\n\r\n- **`.gclient`** - Defines how to fetch Chromium source and dependencies\r\n- **`package.json`** - Contains project metadata, npm scripts, and custom project configurations\r\n- **`requirements.txt`** - Python packages required for development tools\r\n- **`.npmrc`** - npm registry and configuration settings\r\n\r\n### Development Directories\r\n\r\n- **`lib/`** - Python utilities for logging, development tools, and helper functions\r\n- **`scripts/`** - Automation scripts for project initialization and build processes\r\n- **`patches/`** - Custom patches and modifications to Chromium source\r\n- **`docs/`** - Project documentation (expandable for future documentation)\r\n- **`src/`** - Main Chromium source tree with custom modifications\r\n\r\n---\r\n\r\n## 2. The lib/ Directory\r\n\r\nThe `lib/` directory contains Python utilities that support the development workflow:\r\n\r\n```text\r\nlib/\r\n├── __init__.py              # Python package initialization\r\n├── logger.py                # Advanced colored console logging utility\r\n├── logger_demo.py           # Demonstration of logging capabilities\r\n├── utils.py                 # General utility functions\r\n└── __pycache__/             # Python bytecode cache\r\n```\r\n\r\n### Key Components\r\n\r\n- **`logger.py`** - Provides rich console output with progress bars, spinners, and colored logging\r\n- **`logger_demo.py`** - Shows examples of how to use the logging system\r\n- **`utils.py`** - Common utility functions used across the project\r\n\r\n---\r\n\r\n## 3. The scripts/ Directory\r\n\r\nContains automation scripts for project setup and development:\r\n\r\n```text\r\nscripts/\r\n├── init.py                  # Main project initialization script\r\n└── av/                      # Additional automation scripts\r\n```\r\n\r\n### Main Scripts\r\n\r\n- **`init.py`** - Handles project setup, dependency fetching, and environment configuration\r\n- **`av/`** - Directory for additional automation and validation scripts\r\n\r\n---\r\n\r\n## 4. The src/ Directory\r\n\r\nAfter running project initialization, the Chromium source code lives in `src/`. This follows the standard Chromium layout with custom additions:\r\n\r\n```text\r\nsrc/\r\n├── chrome/                  # Chrome browser shell & UI code\r\n├── content/                 # Blink/V8 embedder & shared browser logic  \r\n├── cc/                      # Compositor & layered rendering\r\n├── gpu/                     # GPU process, drivers, and command buffer\r\n├── net/                     # Networking stack (HTTP, QUIC, proxies)\r\n├── ui/                      # Cross-platform UI abstraction\r\n├── components/              # Reusable modules (autofill, payments, etc.)\r\n├── third_party/             # External dependencies and libraries\r\n├── tools/                   # Build-time code generation & helper scripts\r\n├── custom/                  # Custom-core project (our modifications)\r\n├── build/                   # Build system configuration\r\n├── base/                    # Fundamental utilities and abstractions\r\n├── sandbox/                 # Security sandbox implementation\r\n├── services/                # Mojo-based services\r\n└── out/                     # Build output directory\r\n```\r\n\r\n### Core Directories\r\n\r\n- **`chrome/`** - Entry points, Chrome UI (tabs, omnibox, menus), and platform-specific code\r\n- **`content/`** - Integrates Blink (rendering) and V8 (JavaScript), plus IPC and navigation\r\n- **`custom/`** - **Our custom modifications and extensions to Chromium**\r\n- **`net/`** - Implements HTTP(S), QUIC, caching, cookies, proxy resolution\r\n- **`ui/`** - Cross-platform windowing, input events, and vector graphics\r\n\r\n### Custom Integration\r\n\r\n- **`custom/`** - Contains the custom-core project with our browser modifications\r\n- **`out/`** - Generated during build process, contains compiled binaries and intermediates\r\n\r\n---\r\n\r\n## 5. Build Outputs & Configuration\r\n\r\n```text\r\nsrc/out/\r\n└── Default/               # Default build configuration\r\n    ├── obj/               # Intermediate object files\r\n    ├── chrome.exe         # Built browser executable (Windows)\r\n    ├── *.dll              # Shared libraries (if component build)\r\n    └── *.ninja_log        # Build logs and timing information\r\n```\r\n\r\nBuild outputs are generated using the GN (Generate Ninja) build system:\r\n- Use `gn gen out/Default` to generate build files\r\n- Use `ninja -C out/Default chrome` to build the browser\r\n\r\n---\r\n\r\n## 6. Project Configuration & Metadata\r\n\r\n### Build Configuration Files\r\n\r\n- **`BUILD.gn`** files - Scattered throughout the tree, define build targets\r\n- **`.gn`** files - Build system templates and configuration\r\n- **`DEPS`** - External dependency definitions and version pinning\r\n- **`PRESUBMIT.py`** - Pre-commit hooks for code quality checks\r\n\r\n### Project Management\r\n\r\n- **`package.json` config section** - Defines custom project dependencies and their locations\r\n- **`scripts/init.py`** - Automates the fetching and setup of configured projects\r\n- **`.gclient`** - Controls Chromium source synchronization\r\n\r\n---\r\n\r\n## 7. Development Workflow\r\n\r\n### Initial Setup\r\n\r\n1. **Install dependencies**: `npm run install:python`\r\n2. **Initialize project**: `npm run init`\r\n3. **Configure build**: Navigate to `src/` and run `gn gen out/Default`\r\n4. **Build browser**: `ninja -C out/Default chrome`\r\n\r\n### Directory Navigation Tips\r\n\r\n| Need to... | Look in... |\r\n|------------|------------|\r\n| Modify networking behavior | `src/net/` |\r\n| Customize UI components | `src/ui/` or `src/chrome/browser/ui/` |\r\n| Add browser features | `src/custom/` (our modifications) |\r\n| Debug build issues | `src/build/` or build logs in `src/out/` |\r\n| Work with Python tools | `lib/` directory |\r\n| Add automation scripts | `scripts/` directory |\r\n\r\n### Code Search and Navigation\r\n\r\n- Use **VS Code** or your preferred IDE for local code navigation\r\n- **Chromium Code Search**: https://source.chromium.org for upstream Chromium reference\r\n- **grep/ripgrep**: Fast text search across the large codebase\r\n- **BUILD.gn search**: `find . -name BUILD.gn | xargs grep <target>` to locate build definitions\r\n\r\n---\r\n\r\n## 8. Custom Integration Points\r\n\r\n### Our Modifications\r\n\r\n- **`src/custom/`** - Contains the custom-core project with our browser enhancements\r\n- **`lib/`** - Development tools and utilities specific to our workflow\r\n- **`scripts/`** - Automation for project management and initialization\r\n- **`patches/`** - Any required patches to upstream Chromium code\r\n\r\n### Development Best Practices\r\n\r\n- Keep custom code in the `src/custom/` directory when possible\r\n- Use the Python utilities in `lib/` for consistent logging and development experience\r\n- Follow Chromium's coding standards for modifications to core directories\r\n- Document custom features and modifications in the `docs/` directory\r\n\r\n---\r\n\r\n**Navigation Tips:**\r\n- Start with the `README.md` for project overview and setup\r\n- Use `lib/logger_demo.py` to understand the development tools\r\n- Explore `src/custom/` for our specific browser modifications\r\n- Reference upstream Chromium documentation for core functionality understanding\r\n"
  },
  {
    "path": "getting-started/overview",
    "title": "Getting Started with Wanderlust",
    "content": "# Getting Started with Wanderlust\r\n\r\nWelcome to the Getting Started section! This is your entry point for setting up and beginning development with the Wanderlust custom Chromium browser project.\r\n\r\n## What You'll Find Here\r\n\r\nThis section provides everything you need to get up and running:\r\n\r\n- **[Project Layout](project-layout.md)**: Understanding the overall project structure and organization\r\n- **[Code Directory Structure](code-directory-structure.md)**: Detailed breakdown of the codebase organization\r\n- **[Setup & Build](setup-build.md)**: Complete setup instructions and build process\r\n\r\n## Quick Start Guide\r\n\r\nFollow these steps to get started with Wanderlust development:\r\n\r\n1. **Understand the Project**: Review the project layout and directory structure\r\n2. **Set Up Environment**: Follow the setup and build instructions\r\n3. **Explore the Codebase**: Familiarize yourself with the code organization\r\n4. **Build the Project**: Complete your first successful build\r\n5. **Start Development**: Begin making changes and contributions\r\n\r\n## Prerequisites\r\n\r\nBefore diving into development, ensure you have:\r\n- Appropriate development environment (Windows/Linux/macOS)\r\n- Required build tools and dependencies\r\n- Understanding of Chromium's build system\r\n- Basic knowledge of C++, JavaScript, and web technologies\r\n\r\n## Next Steps\r\n\r\nAfter completing the getting started process:\r\n\r\n- Explore the [Architecture](../architecture/overview.md) to understand system design\r\n- Review [Modules](../modules/overview.md) for component-specific information\r\n- Check [Debugging](../debugging/overview.md) for troubleshooting techniques\r\n- Read [Contributing](../contributing/overview.md) guidelines for contribution workflow\r\n\r\n## Development Workflow\r\n\r\n1. **Setup**: Complete the initial setup and build process\r\n2. **Explore**: Understand the codebase structure and architecture\r\n3. **Develop**: Make changes following our coding standards\r\n4. **Test**: Verify your changes work correctly\r\n5. **Contribute**: Submit your improvements following our contribution guidelines\r\n\r\n## Support\r\n\r\nIf you encounter issues during setup:\r\n- Check the troubleshooting sections in each guide\r\n- Review the [Debugging](../debugging/overview.md) section for common solutions\r\n- Consult the [Contributing](../contributing/overview.md) section for development workflow questions\r\n\r\n---\r\n\r\n*Ready to start? Begin with our [project layout guide](project-layout.md) to understand the overall structure, then proceed to [setup and build instructions](setup-build.md).*\r\n"
  },
  {
    "path": "getting-started/code-directory-structure",
    "title": "Code Directory Structure",
    "content": "# Code Directory Structure\r\n\r\nThis page expands on *Project Layout* with a detailed directory-by-directory tour of the custom-browser project's code organization, including both the top-level project structure and the Chromium `src/` tree.\r\n\r\n---\r\n\r\n## Project Root Directories\r\n\r\n### Configuration & Setup Files\r\n\r\n- **`.gclient`** – Controls Chromium source synchronization and dependency management\r\n- **`.gitignore`** – Specifies files to ignore in version control\r\n- **`package.json`** – Project metadata, npm scripts, and custom project configurations\r\n- **`package-lock.json`** – Locked npm dependency versions for reproducible builds\r\n- **`requirements.txt`** – Python package dependencies for development tools\r\n- **`.npmrc`** – npm registry settings and configuration\r\n\r\n### Development Support Directories\r\n\r\n#### `lib/` – Python Development Utilities\r\n- **`__init__.py`** – Python package initialization file\r\n- **`logger.py`** – Advanced colored console logging with progress bars and spinners\r\n- **`logger_demo.py`** – Interactive demonstration of logging system capabilities\r\n- **`utils.py`** – Common utility functions used across development scripts\r\n- **`__pycache__/`** – Python bytecode cache (auto-generated)\r\n\r\n#### `scripts/` – Automation & Build Scripts\r\n- **`init.py`** – Main project initialization script that handles dependency fetching\r\n- **`av/`** – Additional automation and validation scripts for development workflow\r\n\r\n#### `patches/` – Chromium Modifications\r\n- Contains custom patches and modifications to upstream Chromium code\r\n- Organized patches for specific features or bug fixes\r\n- Used when direct source modifications aren't feasible\r\n\r\n#### `docs/` – Project Documentation\r\n- Currently empty but designated for project-specific documentation\r\n- Future home for custom browser feature documentation and development guides\r\n\r\n---\r\n\r\n## The `src/` Directory Structure\r\n\r\nAfter running `npm run init`, the Chromium source code is synchronized into the `src/` directory. Here's a comprehensive breakdown:\r\n\r\n### Core Browser Components\r\n\r\n#### `chrome/` – Browser Shell & UI\r\n- **`app/`** – Application entry points and main() functions\r\n- **`browser/`** – Browser process logic, UI controllers, and feature implementations\r\n- **`common/`** – Shared code between browser and renderer processes\r\n- **`renderer/`** – Renderer process specific code and extensions\r\n- **`test/`** – Chrome-specific test utilities and test data\r\n- **Platform directories**: `android/`, `ios/`, `mac/`, `win/`, `linux/` for platform-specific code\r\n\r\n#### `content/` – Core Browser Engine\r\n- **`browser/`** – Browser process implementation (navigation, resource loading, IPC)\r\n- **`renderer/`** – Renderer process implementation (DOM, JavaScript execution)\r\n- **`common/`** – Shared interfaces and utilities between processes\r\n- **`gpu/`** – GPU process integration code\r\n- **`utility/`** – Utility process implementations\r\n- **`public/`** – Public APIs for embedders\r\n\r\n#### `custom/` – **Our Custom Modifications** 🎯\r\n- **Custom-core project** with our browser enhancements and modifications\r\n- Contains project-specific features and customizations\r\n- Organized to minimize conflicts with upstream Chromium updates\r\n\r\n### Rendering & Graphics\r\n\r\n#### `cc/` – Compositor & Rendering Pipeline\r\n- **`layers/`** – Layer tree implementation for hardware acceleration\r\n- **`trees/`** – Layer tree host and commit/activation logic\r\n- **`animation/`** – Animation system integration\r\n- **`raster/`** – Tile rasterization and GPU texture management\r\n\r\n#### `gpu/` – Graphics Processing\r\n- **`command_buffer/`** – GPU command buffer implementation\r\n- **`config/`** – GPU driver and capability detection\r\n- **`ipc/`** – Inter-process communication for GPU operations\r\n- **`vulkan/`** – Vulkan graphics API integration\r\n\r\n#### `ui/` – Cross-Platform UI Toolkit\r\n- **`base/`** – Fundamental UI primitives and utilities\r\n- **`views/`** – Native widget toolkit abstraction\r\n- **`gfx/`** – 2D graphics, fonts, and image handling\r\n- **`events/`** – Input event handling and dispatch\r\n- **Platform directories**: `gtk/`, `win/`, `cocoa/`, `ozone/` for platform UI\r\n\r\n### Networking & Communication\r\n\r\n#### `net/` – Networking Stack\r\n- **`http/`** – HTTP/HTTPS protocol implementation\r\n- **`quic/`** – QUIC protocol support\r\n- **`dns/`** – DNS resolution and caching\r\n- **`cookies/`** – Cookie storage and management\r\n- **`proxy/`** – Proxy detection and configuration\r\n- **`ssl/`** – SSL/TLS certificate handling\r\n\r\n#### `ipc/` – Inter-Process Communication\r\n- **Core IPC** – Message passing between browser processes\r\n- **Mojo integration** – Modern IPC system built on Mojo\r\n- **Security boundaries** – Process isolation and sandboxing support\r\n\r\n### Core Infrastructure\r\n\r\n#### `base/` – Fundamental Utilities\r\n- **`containers/`** – Custom container classes and algorithms\r\n- **`memory/`** – Memory management utilities and smart pointers\r\n- **`task/`** – Task scheduling and thread pool management\r\n- **`files/`** – File system operations and path handling\r\n- **`strings/`** – String utilities and manipulation functions\r\n\r\n#### `build/` – Build System Configuration\r\n- **GN files** – Build target definitions and dependencies\r\n- **Config files** – Compiler flags, toolchain settings\r\n- **Scripts** – Build automation and CI/CD integration\r\n\r\n#### `tools/` – Development Tools\r\n- **`gn/`** – Generate Ninja build system\r\n- **`clang/`** – Clang-based tools (format, tidy, static analysis)\r\n- **`metrics/`** – Performance and usage metrics collection\r\n- **`variations/`** – A/B testing and feature flag infrastructure\r\n\r\n### Web Technologies\r\n\r\n#### `third_party/` – External Dependencies\r\n- **`blink/`** – Web rendering engine (WebKit fork)\r\n- **`v8/`** – JavaScript engine\r\n- **`skia/`** – 2D graphics library\r\n- **`webrtc/`** – Real-time communication\r\n- **`protobuf/`** – Protocol buffer serialization\r\n- **`zlib/`**, **`libpng/`**, **`libjpeg/`** – Media format libraries\r\n\r\n#### `components/` – Reusable Feature Modules\r\n- **`autofill/`** – Form auto-completion functionality\r\n- **`bookmarks/`** – Bookmark management\r\n- **`history/`** – Browsing history storage and search\r\n- **`password_manager/`** – Password storage and auto-fill\r\n- **`payments/`** – Web payments API implementation\r\n- **`sync/`** – Cross-device data synchronization\r\n\r\n### Security & Sandboxing\r\n\r\n#### `sandbox/` – Security Isolation\r\n- **Platform-specific** – Windows, macOS, Linux sandboxing implementations\r\n- **Policy files** – Security policy definitions and enforcement\r\n- **IPC restrictions** – Communication constraints between processes\r\n\r\n#### `crypto/` – Cryptographic Operations\r\n- **Encryption/decryption** – Symmetric and asymmetric cryptography\r\n- **Hashing** – Secure hash algorithms\r\n- **Certificate handling** – X.509 certificate validation\r\n\r\n### Services & Extensions\r\n\r\n#### `services/` – Mojo-Based Services\r\n- **`network/`** – Network service for process isolation\r\n- **`storage/`** – Storage APIs (IndexedDB, Cache API, etc.)\r\n- **`device/`** – Hardware device access APIs\r\n- **`media/`** – Media capture and playback services\r\n\r\n#### `extensions/` – Browser Extensions\r\n- **`api/`** – Extension API implementations\r\n- **`browser/`** – Extension host and management\r\n- **`renderer/`** – Extension content script injection\r\n\r\n### Build Outputs\r\n\r\n#### `out/` – Compilation Results\r\n- **`Default/`** – Default build configuration output\r\n  - **`obj/`** – Intermediate object files and libraries\r\n  - **`chrome.exe`** – Main browser executable (Windows)\r\n  - **`*.dll`** – Dynamic libraries (Windows component builds)\r\n  - **`resources/`** – Packaged resources and assets\r\n  - **`locales/`** – Internationalization files\r\n\r\n---\r\n\r\n## Directory Relationships & Dependencies\r\n\r\n### Layer Architecture\r\n```\r\n┌─────────────────────────────────────┐\r\n│ chrome/ (Browser Shell & Features)  │\r\n├─────────────────────────────────────┤\r\n│ components/ (Reusable Modules)      │\r\n├─────────────────────────────────────┤\r\n│ content/ (Browser Engine)           │\r\n├─────────────────────────────────────┤\r\n│ third_party/ (External Libraries)   │\r\n├─────────────────────────────────────┤\r\n│ base/ (Fundamental Utilities)       │\r\n└─────────────────────────────────────┘\r\n```\r\n\r\n### Custom Integration Points\r\n- **`custom/`** integrates at the `chrome/` and `components/` level\r\n- **`lib/`** and **`scripts/`** support development workflow\r\n- **`patches/`** modifies any level when direct changes aren't possible\r\n\r\n### Development Workflow Directories\r\n1. **Start here**: `lib/logger_demo.py` to understand tooling\r\n2. **Project setup**: `scripts/init.py` for dependency management\r\n3. **Custom features**: `src/custom/` for browser modifications\r\n4. **Build configuration**: `src/build/` for compilation settings\r\n5. **Output inspection**: `src/out/Default/` for built artifacts\r\n\r\n---\r\n\r\n**See also:**\r\n- [Project Layout](project-layout.md) for high-level project organization\r\n- [Architecture → Browser Components](../architecture/browser-components.md) for runtime component relationships\r\n- [Setup & Build](setup-build.md) for development environment configurationructure"
  },
  {
    "path": "demo/syntax-highlighting",
    "title": "Code Syntax Highlighting Demo",
    "content": "# Code Syntax Highlighting Demo\r\n\r\nThis page demonstrates the enhanced code syntax highlighting capabilities of the Wanderlust Knowledge Base.\r\n\r\n## Supported Languages\r\n\r\nThe knowledge base now supports syntax highlighting for multiple programming languages with copy-to-clipboard functionality and theme-aware styling.\r\n\r\n### TypeScript/JavaScript\r\n\r\n```typescript\r\ninterface BookmarkFeatures {\r\n  pageBookmarks: boolean;\r\n  sectionBookmarks: boolean;\r\n  persistentStorage: boolean;\r\n  searchAndFilter: boolean;\r\n  importExport: boolean;\r\n  categorization: boolean;\r\n}\r\n\r\nclass BookmarkManager {\r\n  private bookmarks: Map<string, Bookmark> = new Map();\r\n  \r\n  constructor(private storage: Storage) {\r\n    this.loadBookmarks();\r\n  }\r\n  \r\n  async addBookmark(bookmark: Omit<Bookmark, 'id' | 'timestamp'>): Promise<void> {\r\n    const newBookmark: Bookmark = {\r\n      ...bookmark,\r\n      id: this.generateId(),\r\n      timestamp: Date.now(),\r\n    };\r\n    \r\n    this.bookmarks.set(newBookmark.id, newBookmark);\r\n    await this.saveBookmarks();\r\n  }\r\n  \r\n  private generateId(): string {\r\n    return Date.now().toString(36) + Math.random().toString(36).substr(2);\r\n  }\r\n}\r\n```\r\n\r\n### C++ (Chromium Code Example)\r\n\r\n```cpp\r\n#include \"base/memory/weak_ptr.h\"\r\n#include \"content/public/browser/browser_context.h\"\r\n#include \"content/public/browser/render_frame_host.h\"\r\n\r\nnamespace content {\r\n\r\nclass DownloadManagerDelegate {\r\n public:\r\n  virtual ~DownloadManagerDelegate() = default;\r\n  \r\n  // Called when a download is created.\r\n  virtual void OnDownloadCreated(DownloadManager* manager,\r\n                                DownloadItem* item) {}\r\n  \r\n  // Determine the download target path.\r\n  virtual bool DetermineDownloadTarget(\r\n      DownloadItem* download,\r\n      const DownloadTargetCallback& callback) {\r\n    return false;\r\n  }\r\n  \r\n  // Check if the download should proceed.\r\n  virtual bool ShouldCompleteDownload(\r\n      DownloadItem* item,\r\n      const base::Closure& complete_callback) {\r\n    return true;\r\n  }\r\n  \r\n private:\r\n  base::WeakPtrFactory<DownloadManagerDelegate> weak_ptr_factory_{this};\r\n};\r\n\r\n}  // namespace content\r\n```\r\n\r\n### Python (Build Scripts)\r\n\r\n```python\r\n#!/usr/bin/env python3\r\n\"\"\"\r\nChromium build script utilities for the custom browser project.\r\n\"\"\"\r\n\r\nimport os\r\nimport sys\r\nimport subprocess\r\nimport argparse\r\nfrom pathlib import Path\r\nfrom typing import List, Optional, Dict\r\n\r\nclass ChromiumBuilder:\r\n    \"\"\"Handles building Chromium with custom modifications.\"\"\"\r\n    \r\n    def __init__(self, source_dir: Path, build_dir: Path):\r\n        self.source_dir = source_dir\r\n        self.build_dir = build_dir\r\n        self.gn_args = {\r\n            'is_debug': False,\r\n            'is_component_build': False,\r\n            'symbol_level': 1,\r\n            'enable_nacl': False,\r\n            'target_cpu': 'x64',\r\n        }\r\n    \r\n    def configure_build(self, custom_args: Optional[Dict[str, any]] = None) -> bool:\r\n        \"\"\"Configure the build with GN.\"\"\"\r\n        if custom_args:\r\n            self.gn_args.update(custom_args)\r\n        \r\n        gn_command = [\r\n            'gn', 'gen', str(self.build_dir),\r\n            '--args=' + ' '.join(f'{k}={v}' for k, v in self.gn_args.items())\r\n        ]\r\n        \r\n        try:\r\n            result = subprocess.run(gn_command, cwd=self.source_dir, \r\n                                  capture_output=True, text=True)\r\n            if result.returncode != 0:\r\n                print(f\"GN configuration failed: {result.stderr}\")\r\n                return False\r\n            return True\r\n        except Exception as e:\r\n            print(f\"Error running GN: {e}\")\r\n            return False\r\n    \r\n    def build_target(self, target: str = 'chrome') -> bool:\r\n        \"\"\"Build the specified target.\"\"\"\r\n        ninja_command = ['ninja', '-C', str(self.build_dir), target]\r\n        \r\n        try:\r\n            subprocess.run(ninja_command, cwd=self.source_dir, check=True)\r\n            return True\r\n        except subprocess.CalledProcessError as e:\r\n            print(f\"Build failed with exit code {e.returncode}\")\r\n            return False\r\n\r\ndef main():\r\n    parser = argparse.ArgumentParser(description='Build Chromium')\r\n    parser.add_argument('--source-dir', type=Path, required=True)\r\n    parser.add_argument('--build-dir', type=Path, required=True)\r\n    parser.add_argument('--target', default='chrome')\r\n    parser.add_argument('--debug', action='store_true')\r\n    \r\n    args = parser.parse_args()\r\n    \r\n    builder = ChromiumBuilder(args.source_dir, args.build_dir)\r\n    \r\n    if args.debug:\r\n        builder.gn_args['is_debug'] = True\r\n        builder.gn_args['symbol_level'] = 2\r\n    \r\n    if not builder.configure_build():\r\n        sys.exit(1)\r\n    \r\n    if not builder.build_target(args.target):\r\n        sys.exit(1)\r\n    \r\n    print(f\"Successfully built {args.target}\")\r\n\r\nif __name__ == '__main__':\r\n    main()\r\n```\r\n\r\n### Bash (Shell Scripts)\r\n\r\n```bash\r\n#!/bin/bash\r\n# Chromium development environment setup script\r\n\r\nset -euo pipefail\r\n\r\nSCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"\r\nCHROMIUM_DIR=\"${SCRIPT_DIR}/chromium\"\r\nDEPOT_TOOLS_DIR=\"${SCRIPT_DIR}/depot_tools\"\r\n\r\n# Colors for output\r\nRED='\\033[0;31m'\r\nGREEN='\\033[0;32m'\r\nYELLOW='\\033[1;33m'\r\nNC='\\033[0m' # No Color\r\n\r\nlog_info() {\r\n    echo -e \"${GREEN}[INFO]${NC} $1\"\r\n}\r\n\r\nlog_warn() {\r\n    echo -e \"${YELLOW}[WARN]${NC} $1\"\r\n}\r\n\r\nlog_error() {\r\n    echo -e \"${RED}[ERROR]${NC} $1\"\r\n}\r\n\r\ninstall_depot_tools() {\r\n    if [[ ! -d \"$DEPOT_TOOLS_DIR\" ]]; then\r\n        log_info \"Installing depot_tools...\"\r\n        git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git \"$DEPOT_TOOLS_DIR\"\r\n    else\r\n        log_info \"depot_tools already installed, updating...\"\r\n        cd \"$DEPOT_TOOLS_DIR\"\r\n        git pull\r\n    fi\r\n    \r\n    export PATH=\"$DEPOT_TOOLS_DIR:$PATH\"\r\n}\r\n\r\nfetch_chromium() {\r\n    if [[ ! -d \"$CHROMIUM_DIR\" ]]; then\r\n        log_info \"Fetching Chromium source code...\"\r\n        mkdir -p \"$CHROMIUM_DIR\"\r\n        cd \"$CHROMIUM_DIR\"\r\n        fetch --nohooks chromium\r\n    else\r\n        log_info \"Chromium already fetched, syncing...\"\r\n        cd \"$CHROMIUM_DIR/src\"\r\n        git pull\r\n        gclient sync\r\n    fi\r\n}\r\n\r\nsetup_build_environment() {\r\n    cd \"$CHROMIUM_DIR/src\"\r\n    \r\n    log_info \"Installing build dependencies...\"\r\n    if [[ \"$OSTYPE\" == \"linux-gnu\"* ]]; then\r\n        ./build/install-build-deps.sh\r\n    elif [[ \"$OSTYPE\" == \"darwin\"* ]]; then\r\n        log_warn \"Please install Xcode and command line tools manually\"\r\n    fi\r\n    \r\n    log_info \"Running hooks...\"\r\n    gclient runhooks\r\n}\r\n\r\nmain() {\r\n    log_info \"Setting up Chromium development environment...\"\r\n    \r\n    install_depot_tools\r\n    fetch_chromium\r\n    setup_build_environment\r\n    \r\n    log_info \"Setup complete! You can now build Chromium:\"\r\n    log_info \"  cd $CHROMIUM_DIR/src\"\r\n    log_info \"  gn gen out/Default\"\r\n    log_info \"  ninja -C out/Default chrome\"\r\n}\r\n\r\nmain \"$@\"\r\n```\r\n\r\n### JSON Configuration\r\n\r\n```json\r\n{\r\n  \"name\": \"wanderlust-knowledgebase\",\r\n  \"version\": \"1.0.0\",\r\n  \"description\": \"A comprehensive knowledge base for Chromium development\",\r\n  \"main\": \"index.js\",\r\n  \"scripts\": {\r\n    \"dev\": \"vite\",\r\n    \"build\": \"tsc && vite build\",\r\n    \"preview\": \"vite preview\",\r\n    \"generate-search-index\": \"node scripts/generate-search-index.js\",\r\n    \"generate-icons\": \"node scripts/generate-icons.js\"\r\n  },\r\n  \"dependencies\": {\r\n    \"react\": \"^18.2.0\",\r\n    \"react-dom\": \"^18.2.0\",\r\n    \"react-router-dom\": \"^6.8.1\",\r\n    \"react-markdown\": \"^8.0.5\",\r\n    \"react-syntax-highlighter\": \"^15.5.0\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@types/react\": \"^18.0.27\",\r\n    \"@types/react-dom\": \"^18.0.10\",\r\n    \"@types/react-syntax-highlighter\": \"^15.5.6\",\r\n    \"@vitejs/plugin-react\": \"^3.1.0\",\r\n    \"autoprefixer\": \"^10.4.13\",\r\n    \"postcss\": \"^8.4.21\",\r\n    \"tailwindcss\": \"^3.2.6\",\r\n    \"typescript\": \"^4.9.4\",\r\n    \"vite\": \"^4.1.0\"\r\n  },\r\n  \"browserslist\": {\r\n    \"production\": [\r\n      \">0.2%\",\r\n      \"not dead\",\r\n      \"not op_mini all\"\r\n    ],\r\n    \"development\": [\r\n      \"last 1 chrome version\",\r\n      \"last 1 firefox version\",\r\n      \"last 1 safari version\"\r\n    ]\r\n  }\r\n}\r\n```\r\n\r\n### SQL Database Schema\r\n\r\n```sql\r\n-- User management and preferences\r\nCREATE TABLE users (\r\n    id SERIAL PRIMARY KEY,\r\n    username VARCHAR(255) UNIQUE NOT NULL,\r\n    email VARCHAR(255) UNIQUE NOT NULL,\r\n    password_hash VARCHAR(255) NOT NULL,\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\r\n);\r\n\r\n-- Content bookmarks\r\nCREATE TABLE bookmarks (\r\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\r\n    user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,\r\n    title VARCHAR(500) NOT NULL,\r\n    path VARCHAR(500) NOT NULL,\r\n    url VARCHAR(500) NOT NULL,\r\n    description TEXT,\r\n    section VARCHAR(255),\r\n    anchor VARCHAR(255),\r\n    category VARCHAR(100),\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    INDEX idx_user_bookmarks (user_id, created_at),\r\n    INDEX idx_bookmark_path (path),\r\n    INDEX idx_bookmark_category (category)\r\n);\r\n\r\n-- Search analytics\r\nCREATE TABLE search_queries (\r\n    id SERIAL PRIMARY KEY,\r\n    query TEXT NOT NULL,\r\n    results_count INTEGER DEFAULT 0,\r\n    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,\r\n    ip_address INET,\r\n    user_agent TEXT,\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    INDEX idx_search_analytics (created_at, query),\r\n    INDEX idx_popular_searches (results_count DESC, created_at DESC)\r\n);\r\n\r\n-- Content feedback and ratings\r\nCREATE TABLE content_feedback (\r\n    id SERIAL PRIMARY KEY,\r\n    article_path VARCHAR(500) NOT NULL,\r\n    user_id INTEGER REFERENCES users(id) ON DELETE SET NULL,\r\n    rating INTEGER CHECK (rating BETWEEN 1 AND 5),\r\n    feedback_type ENUM('helpful', 'outdated', 'error', 'suggestion', 'unclear'),\r\n    content TEXT,\r\n    is_resolved BOOLEAN DEFAULT FALSE,\r\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\r\n    INDEX idx_content_feedback (article_path, created_at),\r\n    INDEX idx_unresolved_feedback (is_resolved, created_at)\r\n);\r\n```\r\n\r\n### CSS Styling\r\n\r\n```css\r\n/* Syntax highlighting custom styles */\r\n.code-block-container {\r\n  @apply relative my-4 rounded-lg overflow-hidden;\r\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\r\n}\r\n\r\n.code-block-header {\r\n  @apply flex items-center justify-between px-4 py-2 text-sm;\r\n  @apply bg-gray-100 dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700;\r\n}\r\n\r\n.code-block-language {\r\n  @apply text-gray-600 dark:text-gray-400 font-medium uppercase tracking-wide;\r\n  font-size: 11px;\r\n  letter-spacing: 0.05em;\r\n}\r\n\r\n.code-block-copy-button {\r\n  @apply flex items-center gap-1.5 px-2 py-1 rounded text-xs transition-all duration-200;\r\n  @apply bg-gray-200 dark:bg-gray-700 text-gray-600 dark:text-gray-400;\r\n  @apply hover:bg-gray-300 dark:hover:bg-gray-600;\r\n}\r\n\r\n.code-block-copy-button.copied {\r\n  @apply bg-green-100 dark:bg-green-900 text-green-700 dark:text-green-300;\r\n}\r\n\r\n/* Custom scrollbar for code blocks */\r\n.code-block-container pre::-webkit-scrollbar {\r\n  height: 8px;\r\n}\r\n\r\n.code-block-container pre::-webkit-scrollbar-track {\r\n  @apply bg-gray-100 dark:bg-gray-800;\r\n}\r\n\r\n.code-block-container pre::-webkit-scrollbar-thumb {\r\n  @apply bg-gray-300 dark:bg-gray-600 rounded;\r\n}\r\n\r\n.code-block-container pre::-webkit-scrollbar-thumb:hover {\r\n  @apply bg-gray-400 dark:bg-gray-500;\r\n}\r\n\r\n/* Inline code styling */\r\n.inline-code {\r\n  @apply bg-gray-100 dark:bg-gray-800 text-red-600 dark:text-red-400;\r\n  @apply px-1.5 py-0.5 rounded text-sm font-mono;\r\n  font-size: 0.875em;\r\n}\r\n\r\n/* Line number styling */\r\n.code-line-numbers {\r\n  @apply select-none;\r\n  border-right: 1px solid rgba(156, 163, 175, 0.3);\r\n  margin-right: 1em;\r\n  padding-right: 1em;\r\n  min-width: 2.5em;\r\n  text-align: right;\r\n}\r\n```\r\n\r\n## Features\r\n\r\n- **Theme-Aware**: Automatically switches between light and dark syntax themes\r\n- **Copy to Clipboard**: One-click copying with visual feedback\r\n- **Language Detection**: Automatic syntax highlighting based on language tags\r\n- **Line Numbers**: For longer code blocks (>5 lines)\r\n- **Responsive Design**: Optimized for all screen sizes\r\n- **Bookmarkable**: Large code blocks can be bookmarked for quick reference\r\n\r\n## Inline Code\r\n\r\nYou can also use `inline code` with proper styling that adapts to the current theme.\r\n\r\n## Supported Languages\r\n\r\nThe syntax highlighter supports over 100 programming languages including:\r\n- JavaScript/TypeScript\r\n- Python\r\n- C/C++\r\n- Java\r\n- Go\r\n- Rust\r\n- Shell/Bash\r\n- SQL\r\n- JSON/YAML\r\n- CSS/SCSS\r\n- HTML\r\n- Markdown\r\n- And many more...\r\n\r\nTry copying any of the code blocks above to see the copy functionality in action!\r\n"
  },
  {
    "path": "demo/progress-tracking",
    "title": "Progress Tracking System",
    "content": "# Progress Tracking System\r\n\r\nWelcome to the comprehensive progress tracking system! This feature helps you monitor your learning journey through the Chromium knowledge base.\r\n\r\n## Features Overview\r\n\r\n### 📊 Reading Progress\r\n- **Automatic tracking**: Progress is tracked based on scroll position and time spent reading\r\n- **Article completion**: Articles are marked as complete when you reach 95% scroll progress\r\n- **Time tracking**: Monitor how much time you spend on each article\r\n- **Cross-session persistence**: Your progress is saved across browser sessions\r\n\r\n### 🎯 Learning Analytics\r\n- **Weekly activity**: Visual charts showing your reading patterns over the past week\r\n- **Category progress**: See how much you've explored in each content category\r\n- **Reading streaks**: Track consecutive days of learning activity\r\n- **Overall progress**: Get a bird's-eye view of your platform progress\r\n\r\n### 🛤️ Learning Paths\r\n- **Custom paths**: Create structured learning journeys for specific topics\r\n- **Progress tracking**: Monitor completion of learning path articles\r\n- **Estimated time**: Get reading time estimates for entire learning paths\r\n- **Difficulty levels**: Organize paths by beginner, intermediate, or advanced levels\r\n\r\n### 📈 Intelligent Recommendations\r\n- **Continue reading**: Smart suggestions for articles you've started but haven't finished\r\n- **Related content**: Discover articles based on your reading history\r\n- **Category exploration**: Find new areas to explore based on your interests\r\n\r\n## How It Works\r\n\r\n### Automatic Progress Tracking\r\n\r\nThe system automatically tracks your reading progress using several methods:\r\n\r\n1. **Scroll-based tracking**: As you scroll through an article, your progress percentage increases\r\n2. **Time-based tracking**: The system records how much time you spend reading each article\r\n3. **Completion detection**: When you scroll to 95% of an article, it's marked as complete\r\n4. **Session management**: Your reading session is tracked from when you start reading until you navigate away\r\n\r\n### Data Storage\r\n\r\nAll progress data is stored locally in your browser using localStorage, ensuring:\r\n- **Privacy**: Your reading data never leaves your device\r\n- **Performance**: Fast access to your progress data\r\n- **Offline support**: Progress tracking works even when offline\r\n- **Data portability**: Export and import your progress data\r\n\r\n### Visual Indicators\r\n\r\nYou'll see progress indicators throughout the platform:\r\n- **Progress bar**: At the top of each article showing reading progress\r\n- **Time estimates**: Reading time estimates for articles and learning paths\r\n- **Completion badges**: Visual indicators for completed articles\r\n- **Streak counters**: Daily reading streak display\r\n\r\n## Getting Started\r\n\r\n### Access Your Dashboard\r\n\r\nClick the progress icon (📊) in the header to access your **Learning Progress Dashboard** where you can:\r\n\r\n- View your overall statistics\r\n- See your reading history\r\n- Manage learning paths\r\n- Analyze your learning patterns\r\n- Export/import your data\r\n\r\n### Create Learning Paths\r\n\r\nOrganize your learning by creating custom learning paths:\r\n\r\n1. Go to the **Learning Paths** tab in your progress dashboard\r\n2. Click **\"Create New Path\"**\r\n3. Add articles to your path\r\n4. Set difficulty level and estimated time\r\n5. Track your progress as you complete articles\r\n\r\n### Monitor Your Progress\r\n\r\nEach article you read will automatically:\r\n- Show a progress indicator at the top\r\n- Track time spent reading\r\n- Update your overall statistics\r\n- Contribute to your learning streaks\r\n\r\n## Example Learning Paths\r\n\r\nHere are some suggested learning paths to get you started:\r\n\r\n### Beginner: Chromium Basics\r\n1. Introduction → Overview\r\n2. Getting Started → Setup & Build\r\n3. Architecture → Overview\r\n4. Architecture → Process Model\r\n\r\n### Intermediate: Browser Architecture\r\n1. Architecture → Module Layering\r\n2. Architecture → IPC Internals\r\n3. Architecture → Render Pipeline\r\n4. Modules → Networking (HTTP)\r\n\r\n### Advanced: Deep Dive Development\r\n1. Architecture → Security → Sandbox Architecture\r\n2. Modules → JavaScript (V8)\r\n3. Architecture → Design Patterns → All patterns\r\n4. Contributing → Contributing Guide\r\n\r\n## Privacy and Data\r\n\r\n### Local Storage Only\r\nYour progress data is stored entirely in your browser's local storage. This means:\r\n- **No server tracking**: Your reading habits are completely private\r\n- **No account required**: Start tracking immediately without signing up\r\n- **Device-specific**: Progress is tied to your specific browser and device\r\n\r\n### Data Export/Import\r\nYou can export your progress data to:\r\n- **Backup your progress**: Save your data before clearing browser storage\r\n- **Transfer between devices**: Move your progress to another browser or device\r\n- **Share learning paths**: Export specific learning paths to share with others\r\n\r\n### Data Management\r\nFull control over your data:\r\n- **Clear all progress**: Reset your progress tracking at any time\r\n- **Selective deletion**: Remove specific articles or learning paths\r\n- **Export anytime**: Get a JSON export of all your progress data\r\n\r\n## Technical Implementation\r\n\r\nThe progress tracking system is built with:\r\n- **React Context**: Centralized state management for progress data\r\n- **TypeScript**: Type-safe interfaces for all progress data structures\r\n- **localStorage API**: Persistent local storage for cross-session data\r\n- **Scroll tracking**: Advanced scroll position monitoring\r\n- **Time tracking**: Accurate reading time measurement\r\n\r\n### Performance Considerations\r\n- **Efficient storage**: Minimal data footprint with optimized storage structure\r\n- **Background tracking**: Non-intrusive progress updates that don't affect reading experience\r\n- **Lazy loading**: Progress dashboard components are loaded only when needed\r\n- **Debounced updates**: Progress updates are batched to prevent excessive localStorage writes\r\n\r\nStart exploring the knowledge base, and watch your progress grow! The system will automatically begin tracking as soon as you start reading articles.\r\n"
  },
  {
    "path": "demo/interactive-diagrams",
    "title": "Interactive Architecture Diagrams",
    "content": "# Interactive Architecture Diagrams\r\n\r\nExplore Chromium's architecture through interactive diagrams. Click on components to learn more about their roles and responsibilities.\r\n\r\n## Chromium Multi-Process Architecture\r\n\r\nThis diagram shows the high-level process architecture of Chromium. Each process runs in its own sandbox for security and stability.\r\n\r\n```interactive-diagram\r\n{\r\n  \"title\": \"Chromium Multi-Process Architecture\",\r\n  \"description\": \"Click on processes to learn about their responsibilities and security boundaries\",\r\n  \"height\": 500,\r\n  \"interactive\": true,\r\n  \"controls\": true,\r\n  \"miniMap\": true,\r\n  \"background\": true,\r\n  \"nodes\": [\r\n    {\r\n      \"id\": \"browser-process\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 100, \"y\": 100 },\r\n      \"data\": {\r\n        \"label\": \"Browser Process\",\r\n        \"description\": \"Main process that manages the UI, network, and coordinates other processes\",\r\n        \"details\": \"The browser process is the main process in Chromium. It handles the browser UI, manages tabs, bookmarks, history, and coordinates communication between other processes.\",\r\n        \"icon\": \"🏠\",\r\n        \"processType\": \"browser\",\r\n        \"links\": [\r\n          { \"title\": \"Browser Process Documentation\", \"url\": \"#/architecture/process-model\" },\r\n          { \"title\": \"Process Model Overview\", \"url\": \"#/architecture/overview\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"renderer-process-1\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 400, \"y\": 50 },\r\n      \"data\": {\r\n        \"label\": \"Renderer Process\",\r\n        \"description\": \"Renders web content, executes JavaScript, handles DOM manipulation\",\r\n        \"details\": \"Each tab typically runs in its own renderer process. This provides isolation between tabs and websites for security and stability.\",\r\n        \"icon\": \"🌐\",\r\n        \"processType\": \"renderer\",\r\n        \"links\": [\r\n          { \"title\": \"Render Pipeline\", \"url\": \"#/architecture/render-pipeline\" },\r\n          { \"title\": \"Blink Architecture\", \"url\": \"#/modules/javascript-v8\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"renderer-process-2\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 400, \"y\": 150 },\r\n      \"data\": {\r\n        \"label\": \"Renderer Process\",\r\n        \"description\": \"Another tab's renderer process (isolated)\",\r\n        \"icon\": \"🌐\",\r\n        \"processType\": \"renderer\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"gpu-process\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 100, \"y\": 250 },\r\n      \"data\": {\r\n        \"label\": \"GPU Process\",\r\n        \"description\": \"Handles graphics acceleration and compositing\",\r\n        \"details\": \"The GPU process manages hardware acceleration for graphics rendering, video decoding, and UI compositing.\",\r\n        \"icon\": \"🎮\",\r\n        \"processType\": \"gpu\",\r\n        \"links\": [\r\n          { \"title\": \"GPU Architecture\", \"url\": \"#/architecture/browser-components\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"network-process\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 100, \"y\": 350 },\r\n      \"data\": {\r\n        \"label\": \"Network Process\",\r\n        \"description\": \"Manages network requests, caching, and security\",\r\n        \"details\": \"Handles all network communication, HTTP/HTTPS requests, caching, and network security policies.\",\r\n        \"icon\": \"🌍\",\r\n        \"processType\": \"network\",\r\n        \"links\": [\r\n          { \"title\": \"Network Stack\", \"url\": \"#/modules/networking-http\" },\r\n          { \"title\": \"Storage & Cache\", \"url\": \"#/modules/storage-cache\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"utility-process\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 400, \"y\": 300 },\r\n      \"data\": {\r\n        \"label\": \"Utility Process\",\r\n        \"description\": \"Handles various utility tasks like audio, device access\",\r\n        \"details\": \"Runs services that need sandboxing but don't fit into other process types. Examples include audio service, device service, and storage service.\",\r\n        \"icon\": \"🔧\",\r\n        \"processType\": \"utility\",\r\n        \"links\": [\r\n          { \"title\": \"Process Model\", \"url\": \"#/architecture/process-model\" }\r\n        ]\r\n      }\r\n    }\r\n  ],\r\n  \"edges\": [\r\n    {\r\n      \"id\": \"browser-renderer1\",\r\n      \"source\": \"browser-process\",\r\n      \"target\": \"renderer-process-1\",\r\n      \"label\": \"IPC\",\r\n      \"description\": \"Inter-process communication for tab management\",\r\n      \"type\": \"smoothstep\",\r\n      \"animated\": true,\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#374151\" }\r\n    },\r\n    {\r\n      \"id\": \"browser-renderer2\",\r\n      \"source\": \"browser-process\",\r\n      \"target\": \"renderer-process-2\",\r\n      \"label\": \"IPC\",\r\n      \"type\": \"smoothstep\",\r\n      \"animated\": true,\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#374151\" }\r\n    },\r\n    {\r\n      \"id\": \"browser-gpu\",\r\n      \"source\": \"browser-process\",\r\n      \"target\": \"gpu-process\",\r\n      \"label\": \"Graphics Commands\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#374151\" }\r\n    },\r\n    {\r\n      \"id\": \"browser-network\",\r\n      \"source\": \"browser-process\",\r\n      \"target\": \"network-process\",\r\n      \"label\": \"Network Requests\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#374151\" }\r\n    },\r\n    {\r\n      \"id\": \"renderer1-gpu\",\r\n      \"source\": \"renderer-process-1\",\r\n      \"target\": \"gpu-process\",\r\n      \"label\": \"Rendering\",\r\n      \"type\": \"smoothstep\",\r\n      \"style\": { \"stroke\": \"#dc2626\", \"strokeDasharray\": \"5,5\" },\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#dc2626\" }\r\n    },\r\n    {\r\n      \"id\": \"renderer2-gpu\",\r\n      \"source\": \"renderer-process-2\",\r\n      \"target\": \"gpu-process\",\r\n      \"label\": \"Rendering\",\r\n      \"type\": \"smoothstep\",\r\n      \"style\": { \"stroke\": \"#dc2626\", \"strokeDasharray\": \"5,5\" },\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#dc2626\" }\r\n    },\r\n    {\r\n      \"id\": \"browser-utility\",\r\n      \"source\": \"browser-process\",\r\n      \"target\": \"utility-process\",\r\n      \"label\": \"Services\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#374151\" }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## Blink Rendering Engine Components\r\n\r\nThis diagram shows the internal structure of Blink, the rendering engine used in Chromium's renderer processes.\r\n\r\n```interactive-diagram\r\n{\r\n  \"title\": \"Blink Rendering Engine Architecture\",\r\n  \"description\": \"Explore the components that transform HTML, CSS, and JavaScript into rendered web pages\",\r\n  \"height\": 600,\r\n  \"interactive\": true,\r\n  \"controls\": true,\r\n  \"background\": true,\r\n  \"nodes\": [\r\n    {\r\n      \"id\": \"html-parser\",\r\n      \"type\": \"chromium-component\",\r\n      \"position\": { \"x\": 50, \"y\": 50 },\r\n      \"data\": {\r\n        \"label\": \"HTML Parser\",\r\n        \"description\": \"Parses HTML markup into DOM tree\",\r\n        \"details\": \"Converts HTML text into a Document Object Model (DOM) tree structure that represents the document's structure and content.\",\r\n        \"icon\": \"📄\",\r\n        \"componentType\": \"content\",\r\n        \"links\": [\r\n          { \"title\": \"Render Pipeline\", \"url\": \"#/architecture/render-pipeline\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"css-parser\",\r\n      \"type\": \"chromium-component\",\r\n      \"position\": { \"x\": 50, \"y\": 150 },\r\n      \"data\": {\r\n        \"label\": \"CSS Parser\",\r\n        \"description\": \"Parses CSS stylesheets and computes styles\",\r\n        \"details\": \"Parses CSS stylesheets and creates CSSOM (CSS Object Model). Handles selector matching and style computation.\",\r\n        \"icon\": \"🎨\",\r\n        \"componentType\": \"content\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"layout-engine\",\r\n      \"type\": \"chromium-component\",\r\n      \"position\": { \"x\": 300, \"y\": 100 },\r\n      \"data\": {\r\n        \"label\": \"Layout Engine\",\r\n        \"description\": \"Calculates element positions and sizes\",\r\n        \"details\": \"Performs layout calculations to determine the position and size of each element based on CSS rules and content.\",\r\n        \"icon\": \"📐\",\r\n        \"componentType\": \"blink\",\r\n        \"links\": [\r\n          { \"title\": \"Render Pipeline\", \"url\": \"#/architecture/render-pipeline\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"paint-engine\",\r\n      \"type\": \"chromium-component\",\r\n      \"position\": { \"x\": 300, \"y\": 200 },\r\n      \"data\": {\r\n        \"label\": \"Paint Engine\",\r\n        \"description\": \"Converts layout tree to paint instructions\",\r\n        \"details\": \"Generates paint operations (draw commands) that describe how to render each element visually.\",\r\n        \"icon\": \"🖌️\",\r\n        \"componentType\": \"blink\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"v8-engine\",\r\n      \"type\": \"chromium-component\",\r\n      \"position\": { \"x\": 50, \"y\": 300 },\r\n      \"data\": {\r\n        \"label\": \"V8 JavaScript Engine\",\r\n        \"description\": \"Executes JavaScript code and manages DOM APIs\",\r\n        \"details\": \"High-performance JavaScript engine that compiles and executes JavaScript, manages memory, and provides DOM/Web APIs.\",\r\n        \"icon\": \"⚡\",\r\n        \"componentType\": \"v8\",\r\n        \"links\": [\r\n          { \"title\": \"JavaScript Integration\", \"url\": \"#/modules/javascript-v8\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"compositor\",\r\n      \"type\": \"chromium-component\",\r\n      \"position\": { \"x\": 550, \"y\": 150 },\r\n      \"data\": {\r\n        \"label\": \"Compositor\",\r\n        \"description\": \"Composites layers for GPU acceleration\",\r\n        \"details\": \"Manages compositing layers and coordinates with the GPU process for hardware-accelerated rendering.\",\r\n        \"icon\": \"🔧\",\r\n        \"componentType\": \"blink\",\r\n        \"links\": [\r\n          { \"title\": \"GPU Architecture\", \"url\": \"#/architecture/browser-components\" }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"dom\",\r\n      \"type\": \"default\",\r\n      \"position\": { \"x\": 300, \"y\": 50 },\r\n      \"data\": {\r\n        \"label\": \"DOM Tree\",\r\n        \"description\": \"Document Object Model representation\",\r\n        \"icon\": \"🌳\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"render-tree\",\r\n      \"type\": \"default\",\r\n      \"position\": { \"x\": 550, \"y\": 100 },\r\n      \"data\": {\r\n        \"label\": \"Render Tree\",\r\n        \"description\": \"Combined DOM + Style tree for rendering\",\r\n        \"icon\": \"🌲\"\r\n      }\r\n    }\r\n  ],\r\n  \"edges\": [\r\n    {\r\n      \"id\": \"html-dom\",\r\n      \"source\": \"html-parser\",\r\n      \"target\": \"dom\",\r\n      \"label\": \"creates\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"css-layout\",\r\n      \"source\": \"css-parser\",\r\n      \"target\": \"layout-engine\",\r\n      \"label\": \"styles\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"dom-layout\",\r\n      \"source\": \"dom\",\r\n      \"target\": \"layout-engine\",\r\n      \"label\": \"structure\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"layout-render\",\r\n      \"source\": \"layout-engine\",\r\n      \"target\": \"render-tree\",\r\n      \"label\": \"generates\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"layout-paint\",\r\n      \"source\": \"layout-engine\",\r\n      \"target\": \"paint-engine\",\r\n      \"label\": \"layout info\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"paint-compositor\",\r\n      \"source\": \"paint-engine\",\r\n      \"target\": \"compositor\",\r\n      \"label\": \"paint ops\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"render-compositor\",\r\n      \"source\": \"render-tree\",\r\n      \"target\": \"compositor\",\r\n      \"label\": \"layers\",\r\n      \"type\": \"smoothstep\",\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"v8-dom\",\r\n      \"source\": \"v8-engine\",\r\n      \"target\": \"dom\",\r\n      \"label\": \"DOM API\",\r\n      \"type\": \"smoothstep\",\r\n      \"style\": { \"stroke\": \"#f59e0b\", \"strokeDasharray\": \"3,3\" },\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#f59e0b\" }\r\n    },\r\n    {\r\n      \"id\": \"v8-layout\",\r\n      \"source\": \"v8-engine\",\r\n      \"target\": \"layout-engine\",\r\n      \"label\": \"style changes\",\r\n      \"type\": \"smoothstep\",\r\n      \"style\": { \"stroke\": \"#f59e0b\", \"strokeDasharray\": \"3,3\" },\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#f59e0b\" }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## IPC (Inter-Process Communication) Flow\r\n\r\nUnderstanding how different processes communicate is crucial for Chromium development.\r\n\r\n```interactive-diagram\r\n{\r\n  \"title\": \"IPC Message Flow Example\",\r\n  \"description\": \"Follow a typical user interaction from browser UI to web content rendering\",\r\n  \"height\": 400,\r\n  \"interactive\": true,\r\n  \"controls\": true,\r\n  \"nodes\": [\r\n    {\r\n      \"id\": \"user\",\r\n      \"type\": \"default\",\r\n      \"position\": { \"x\": 50, \"y\": 200 },\r\n      \"data\": {\r\n        \"label\": \"User\",\r\n        \"description\": \"User clicks a link in the browser\",\r\n        \"icon\": \"👤\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"browser-ui\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 200, \"y\": 200 },\r\n      \"data\": {\r\n        \"label\": \"Browser UI\",\r\n        \"description\": \"Browser process handles UI events\",\r\n        \"processType\": \"browser\",\r\n        \"icon\": \"🖥️\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"renderer\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 400, \"y\": 200 },\r\n      \"data\": {\r\n        \"label\": \"Renderer\",\r\n        \"description\": \"Renderer process handles the navigation\",\r\n        \"processType\": \"renderer\",\r\n        \"icon\": \"🌐\"\r\n      }\r\n    },\r\n    {\r\n      \"id\": \"network\",\r\n      \"type\": \"chromium-process\",\r\n      \"position\": { \"x\": 600, \"y\": 200 },\r\n      \"data\": {\r\n        \"label\": \"Network\",\r\n        \"description\": \"Network process fetches the resource\",\r\n        \"processType\": \"network\",\r\n        \"icon\": \"🌍\"\r\n      }\r\n    }\r\n  ],\r\n  \"edges\": [\r\n    {\r\n      \"id\": \"user-browser\",\r\n      \"source\": \"user\",\r\n      \"target\": \"browser-ui\",\r\n      \"label\": \"1. Click\",\r\n      \"type\": \"smoothstep\",\r\n      \"animated\": true,\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"browser-renderer\",\r\n      \"source\": \"browser-ui\",\r\n      \"target\": \"renderer\",\r\n      \"label\": \"2. Navigate IPC\",\r\n      \"type\": \"smoothstep\",\r\n      \"animated\": true,\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"renderer-network\",\r\n      \"source\": \"renderer\",\r\n      \"target\": \"network\",\r\n      \"label\": \"3. Fetch Request\",\r\n      \"type\": \"smoothstep\",\r\n      \"animated\": true,\r\n      \"markerEnd\": { \"type\": \"arrowclosed\" }\r\n    },\r\n    {\r\n      \"id\": \"network-renderer-back\",\r\n      \"source\": \"network\",\r\n      \"target\": \"renderer\",\r\n      \"label\": \"4. Response\",\r\n      \"type\": \"smoothstep\",\r\n      \"style\": { \"stroke\": \"#16a34a\" },\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#16a34a\" }\r\n    },\r\n    {\r\n      \"id\": \"renderer-browser-back\",\r\n      \"source\": \"renderer\",\r\n      \"target\": \"browser-ui\",\r\n      \"label\": \"5. Update UI\",\r\n      \"type\": \"smoothstep\",\r\n      \"style\": { \"stroke\": \"#16a34a\" },\r\n      \"markerEnd\": { \"type\": \"arrowclosed\", \"color\": \"#16a34a\" }\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## Learning Notes\r\n\r\n### Key Concepts Demonstrated:\r\n\r\n1. **Process Isolation**: Each process runs in its own sandbox for security\r\n2. **IPC Communication**: Processes communicate through well-defined message interfaces\r\n3. **Component Separation**: Different responsibilities are clearly separated\r\n4. **Security Boundaries**: Renderer processes are heavily sandboxed\r\n\r\n### Interactive Features:\r\n\r\n- **Click nodes** to see detailed descriptions and links to relevant documentation\r\n- **Drag nodes** to rearrange the diagram for better understanding\r\n- **Use mouse wheel** to zoom in/out for different levels of detail\r\n- **Minimap** (when enabled) provides overview of large diagrams\r\n\r\n### Next Steps:\r\n\r\nExplore the linked documentation pages to dive deeper into each component's implementation details and design principles.\r\n"
  },
  {
    "path": "demo/enhanced-component-architecture",
    "title": "Enhanced Component Architecture Demo",
    "content": "# Enhanced Component Architecture Demo\r\n\r\nThis page demonstrates the modular, extensible article/component rendering system that supports multiple content types with consistent interaction patterns.\r\n\r\n## Markdown Components\r\n\r\nThis is a standard markdown component that supports rich text formatting, code blocks with syntax highlighting, and interactive section bookmarks.\r\n\r\n### Code Example\r\n\r\nHere's some JavaScript code with syntax highlighting:\r\n\r\n```javascript\r\n// React Component Example\r\nimport React, { useState } from 'react';\r\n\r\nconst ExampleComponent = () => {\r\n  const [count, setCount] = useState(0);\r\n\r\n  const handleClick = () => {\r\n    setCount(prevCount => prevCount + 1);\r\n  };\r\n\r\n  return (\r\n    <div className=\"component\">\r\n      <h2>Count: {count}</h2>\r\n      <button onClick={handleClick}>\r\n        Increment\r\n      </button>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ExampleComponent;\r\n```\r\n\r\n### Features\r\n\r\n- ✅ **Syntax Highlighting**: Automatic code highlighting for multiple languages\r\n- ✅ **Section Bookmarks**: Click the bookmark icon next to any heading to save it\r\n- ✅ **Responsive Design**: Optimized for mobile and desktop viewing\r\n- ✅ **Theme Support**: Supports both light and dark themes\r\n\r\n## Interactive Components\r\n\r\nThe system supports various interactive content types:\r\n\r\n### Code Editor\r\n- Live code editing with syntax highlighting\r\n- Multiple programming language support\r\n- Run and reset functionality\r\n\r\n### Simulations\r\n- Interactive simulations with configurable parameters\r\n- Real-time updates and controls\r\n- Educational demonstrations\r\n\r\n### Demos\r\n- Step-by-step interactive demonstrations\r\n- Progress tracking and state management\r\n- Customizable configuration options\r\n\r\n## Media Components\r\n\r\n### Video Content\r\n- HTML5 video player with custom controls\r\n- Interactive captions and transcripts\r\n- Thumbnail previews and metadata display\r\n- Progress tracking and seeking\r\n\r\n### Diagrams\r\n- Multiple diagram types (Mermaid, PlantUML, Flowcharts, Architecture)\r\n- Interactive elements with clickable nodes\r\n- Fullscreen viewing mode\r\n- Zoom and pan controls\r\n\r\n## UI Components\r\n\r\n### Callouts\r\nVarious callout types for important information:\r\n\r\n- **Info**: General information and tips\r\n- **Warning**: Important warnings and cautions\r\n- **Error**: Error messages and troubleshooting\r\n- **Success**: Success messages and confirmations\r\n- **Tip**: Pro tips and best practices\r\n\r\n### Quizzes\r\n- Multiple choice questions\r\n- True/false questions\r\n- Code completion exercises\r\n- Progress tracking and scoring\r\n- Detailed explanations and feedback\r\n\r\n## Architecture Benefits\r\n\r\n### 1. Modularity\r\nEach component type is implemented as a separate, focused renderer that can be developed, tested, and maintained independently.\r\n\r\n### 2. Extensibility\r\nNew component types can be easily added by:\r\n1. Creating a new renderer component\r\n2. Adding the type to the ComponentTypes interface\r\n3. Updating the ComponentRenderer switch statement\r\n\r\n### 3. Consistency\r\nAll components follow the same interaction patterns and design principles, providing a unified user experience.\r\n\r\n### 4. Performance\r\n- Lazy loading of component renderers\r\n- Suspense boundaries for graceful loading states\r\n- Optimized re-rendering with React.memo and proper dependency management\r\n\r\n### 5. Developer Experience\r\n- Type-safe component definitions\r\n- Comprehensive error handling and fallbacks\r\n- Development-time debugging information\r\n- Extensive logging and analytics hooks\r\n\r\n## Technical Implementation\r\n\r\nThe Enhanced Component Architecture consists of:\r\n\r\n- **Core Types**: TypeScript interfaces defining component structure and content types\r\n- **Component Renderer**: Main orchestrator that routes components to appropriate renderers\r\n- **Modular Renderers**: Specialized components for each content type\r\n- **Interaction System**: Consistent event handling and state management\r\n- **Layout System**: Flexible layout and styling options\r\n\r\nThis architecture enables the creation of rich, interactive documentation that goes beyond traditional markdown while maintaining excellent performance and developer experience.\r\n"
  },
  {
    "path": "demo/cpp-chromium-playground",
    "title": "C++ and Chromium Development Playground",
    "content": "# C++ and Chromium Development Playground\r\n\r\nExplore C++ concepts and Chromium-specific patterns in this interactive playground. While full C++ compilation requires a server, you can learn syntax, understand patterns, and experiment with code structure.\r\n\r\n## Basic C++ Concepts\r\n\r\n### Memory Management and Smart Pointers\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <memory>\r\n#include <vector>\r\n#include <string>\r\n\r\n// Modern C++ memory management example\r\nclass ChromiumComponent {\r\nprivate:\r\n    std::string name_;\r\n    int priority_;\r\n    \r\npublic:\r\n    ChromiumComponent(const std::string& name, int priority) \r\n        : name_(name), priority_(priority) {\r\n        std::cout << \"Creating component: \" << name_ << std::endl;\r\n    }\r\n    \r\n    ~ChromiumComponent() {\r\n        std::cout << \"Destroying component: \" << name_ << std::endl;\r\n    }\r\n    \r\n    const std::string& GetName() const { return name_; }\r\n    int GetPriority() const { return priority_; }\r\n    \r\n    void Process() {\r\n        std::cout << \"Processing \" << name_ << \" with priority \" << priority_ << std::endl;\r\n    }\r\n};\r\n\r\n// Factory pattern commonly used in Chromium\r\nclass ComponentFactory {\r\npublic:\r\n    static std::unique_ptr<ChromiumComponent> CreateComponent(\r\n        const std::string& type, const std::string& name) {\r\n        \r\n        int priority = (type == \"ui\") ? 1 : (type == \"network\") ? 2 : 3;\r\n        return std::make_unique<ChromiumComponent>(name, priority);\r\n    }\r\n};\r\n\r\nint main() {\r\n    // Smart pointer usage - automatic memory management\r\n    std::vector<std::unique_ptr<ChromiumComponent>> components;\r\n    \r\n    // Create components using factory\r\n    components.push_back(ComponentFactory::CreateComponent(\"ui\", \"MainWindow\"));\r\n    components.push_back(ComponentFactory::CreateComponent(\"network\", \"HttpClient\"));\r\n    components.push_back(ComponentFactory::CreateComponent(\"storage\", \"CacheManager\"));\r\n    \r\n    // Process all components\r\n    std::cout << \"\\n--- Processing Components ---\\n\";\r\n    for (const auto& component : components) {\r\n        component->Process();\r\n    }\r\n    \r\n    // Memory is automatically cleaned up when vector goes out of scope\r\n    std::cout << \"\\n--- Cleanup ---\\n\";\r\n    return 0;\r\n}\r\n```\r\n\r\n**Learning Points:**\r\n- RAII (Resource Acquisition Is Initialization) principle\r\n- Smart pointers for automatic memory management\r\n- Factory pattern for object creation\r\n- Const correctness in member functions\r\n\r\n---\r\n\r\n## Chromium-Style Code Patterns\r\n\r\n### Observer Pattern Implementation\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <memory>\r\n\r\n// Observer pattern - widely used in Chromium for event handling\r\nclass Observer {\r\npublic:\r\n    virtual ~Observer() = default;\r\n    virtual void OnNotify(const std::string& event) = 0;\r\n};\r\n\r\nclass Subject {\r\nprivate:\r\n    std::vector<Observer*> observers_;\r\n    \r\npublic:\r\n    void AddObserver(Observer* observer) {\r\n        observers_.push_back(observer);\r\n    }\r\n    \r\n    void RemoveObserver(Observer* observer) {\r\n        observers_.erase(\r\n            std::remove(observers_.begin(), observers_.end(), observer),\r\n            observers_.end()\r\n        );\r\n    }\r\n    \r\n    void NotifyAll(const std::string& event) {\r\n        for (Observer* observer : observers_) {\r\n            observer->OnNotify(event);\r\n        }\r\n    }\r\n};\r\n\r\n// Concrete observers\r\nclass UIObserver : public Observer {\r\nprivate:\r\n    std::string name_;\r\n    \r\npublic:\r\n    UIObserver(const std::string& name) : name_(name) {}\r\n    \r\n    void OnNotify(const std::string& event) override {\r\n        std::cout << \"[UI:\" << name_ << \"] Received event: \" << event << std::endl;\r\n        // Handle UI updates here\r\n    }\r\n};\r\n\r\nclass NetworkObserver : public Observer {\r\npublic:\r\n    void OnNotify(const std::string& event) override {\r\n        std::cout << \"[Network] Handling event: \" << event << std::endl;\r\n        // Handle network-related events\r\n    }\r\n};\r\n\r\n// Example usage\r\nint main() {\r\n    Subject browserEvents;\r\n    \r\n    UIObserver mainWindow(\"MainWindow\");\r\n    UIObserver toolbar(\"Toolbar\");\r\n    NetworkObserver networkManager;\r\n    \r\n    // Register observers\r\n    browserEvents.AddObserver(&mainWindow);\r\n    browserEvents.AddObserver(&toolbar);\r\n    browserEvents.AddObserver(&networkManager);\r\n    \r\n    // Simulate browser events\r\n    std::cout << \"=== Browser Events Simulation ===\\n\";\r\n    browserEvents.NotifyAll(\"page_load_started\");\r\n    browserEvents.NotifyAll(\"navigation_completed\");\r\n    browserEvents.NotifyAll(\"network_error\");\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n**Chromium Usage:**\r\n- Content API notifications\r\n- UI event propagation\r\n- Browser process communication\r\n- Preference change notifications\r\n\r\n---\r\n\r\n## C++ Templates and Modern Features\r\n\r\n### Template Metaprogramming Example\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <type_traits>\r\n#include <string>\r\n#include <vector>\r\n\r\n// Template metaprogramming - used extensively in Chromium's base library\r\ntemplate<typename T>\r\nclass Optional {\r\nprivate:\r\n    bool has_value_;\r\n    alignas(T) char storage_[sizeof(T)];\r\n    \r\npublic:\r\n    Optional() : has_value_(false) {}\r\n    \r\n    Optional(const T& value) : has_value_(true) {\r\n        new(storage_) T(value);\r\n    }\r\n    \r\n    ~Optional() {\r\n        if (has_value_) {\r\n            reinterpret_cast<T*>(storage_)->~T();\r\n        }\r\n    }\r\n    \r\n    bool has_value() const { return has_value_; }\r\n    \r\n    const T& value() const {\r\n        if (!has_value_) {\r\n            throw std::runtime_error(\"Optional has no value\");\r\n        }\r\n        return *reinterpret_cast<const T*>(storage_);\r\n    }\r\n    \r\n    T value_or(const T& default_value) const {\r\n        return has_value_ ? value() : default_value;\r\n    }\r\n};\r\n\r\n// SFINAE (Substitution Failure Is Not An Error) example\r\ntemplate<typename T>\r\ntypename std::enable_if<std::is_arithmetic<T>::value, void>::type\r\nPrintValue(const T& value) {\r\n    std::cout << \"Numeric value: \" << value << std::endl;\r\n}\r\n\r\ntemplate<typename T>\r\ntypename std::enable_if<!std::is_arithmetic<T>::value, void>::type\r\nPrintValue(const T& value) {\r\n    std::cout << \"Non-numeric value: \" << value << std::endl;\r\n}\r\n\r\n// Variadic templates - used in Chromium's callback system\r\ntemplate<typename... Args>\r\nvoid LogInfo(const std::string& format, Args&&... args) {\r\n    std::cout << \"[INFO] \" << format;\r\n    // In real implementation, would format with args\r\n    ((std::cout << \" \" << args), ...); // C++17 fold expression\r\n    std::cout << std::endl;\r\n}\r\n\r\nint main() {\r\n    // Optional usage\r\n    std::cout << \"=== Optional Example ===\\n\";\r\n    Optional<std::string> maybe_name(\"Chromium\");\r\n    Optional<std::string> empty_name;\r\n    \r\n    std::cout << \"Has name: \" << maybe_name.has_value() << std::endl;\r\n    std::cout << \"Name: \" << maybe_name.value_or(\"Unknown\") << std::endl;\r\n    std::cout << \"Empty name: \" << empty_name.value_or(\"Default\") << std::endl;\r\n    \r\n    // SFINAE demonstration\r\n    std::cout << \"\\n=== SFINAE Example ===\\n\";\r\n    PrintValue(42);\r\n    PrintValue(std::string(\"Hello\"));\r\n    \r\n    // Variadic templates\r\n    std::cout << \"\\n=== Variadic Templates ===\\n\";\r\n    LogInfo(\"Browser started\", \"version\", \"1.0\", \"build\", 12345);\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n**Modern C++ Features:**\r\n- Perfect forwarding with `std::forward`\r\n- SFINAE for template specialization\r\n- Variadic templates for flexible APIs\r\n- Placement new for custom memory management\r\n\r\n---\r\n\r\n## Chromium Base Library Patterns\r\n\r\n### Callback System Simulation\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <functional>\r\n#include <memory>\r\n#include <vector>\r\n\r\n// Simplified version of Chromium's callback system\r\ntemplate<typename Signature>\r\nclass Callback;\r\n\r\ntemplate<typename R, typename... Args>\r\nclass Callback<R(Args...)> {\r\nprivate:\r\n    std::function<R(Args...)> callback_;\r\n    \r\npublic:\r\n    Callback() = default;\r\n    \r\n    template<typename F>\r\n    Callback(F&& f) : callback_(std::forward<F>(f)) {}\r\n    \r\n    R Run(Args... args) const {\r\n        if (callback_) {\r\n            return callback_(args...);\r\n        }\r\n        if constexpr (!std::is_void_v<R>) {\r\n            return R{};\r\n        }\r\n    }\r\n    \r\n    bool is_null() const { return !callback_; }\r\n    \r\n    explicit operator bool() const { return !is_null(); }\r\n};\r\n\r\n// Factory functions for creating callbacks\r\ntemplate<typename F>\r\nauto BindOnce(F&& f) {\r\n    return Callback<std::invoke_result_t<F>()>{std::forward<F>(f)};\r\n}\r\n\r\ntemplate<typename F, typename... Args>\r\nauto BindOnce(F&& f, Args&&... args) {\r\n    return [f = std::forward<F>(f), args...](auto&&... remaining_args) {\r\n        return f(args..., remaining_args...);\r\n    };\r\n}\r\n\r\n// Example usage in a hypothetical browser component\r\nclass NetworkRequest {\r\nprivate:\r\n    std::string url_;\r\n    Callback<void(int, const std::string&)> completion_callback_;\r\n    \r\npublic:\r\n    NetworkRequest(const std::string& url) : url_(url) {}\r\n    \r\n    void SetCompletionCallback(Callback<void(int, const std::string&)> callback) {\r\n        completion_callback_ = std::move(callback);\r\n    }\r\n    \r\n    void Start() {\r\n        std::cout << \"Starting request to: \" << url_ << std::endl;\r\n        \r\n        // Simulate async operation\r\n        // In real code, this would be asynchronous\r\n        int status_code = 200;\r\n        std::string response = \"Response data from \" + url_;\r\n        \r\n        if (completion_callback_) {\r\n            completion_callback_.Run(status_code, response);\r\n        }\r\n    }\r\n};\r\n\r\n// Response handler\r\nvoid HandleResponse(const std::string& context, int status, const std::string& data) {\r\n    std::cout << \"[\" << context << \"] Status: \" << status \r\n              << \", Data: \" << data << std::endl;\r\n}\r\n\r\nint main() {\r\n    std::cout << \"=== Chromium-Style Callback System ===\\n\";\r\n    \r\n    NetworkRequest request(\"https://example.com/api/data\");\r\n    \r\n    // Bind callback with context\r\n    auto callback = BindOnce(&HandleResponse, \"MainFrame\");\r\n    request.SetCompletionCallback(\r\n        Callback<void(int, const std::string&)>{callback}\r\n    );\r\n    \r\n    request.Start();\r\n    \r\n    // Lambda callback example\r\n    std::cout << \"\\n=== Lambda Callback ===\\n\";\r\n    NetworkRequest request2(\"https://api.example.com/users\");\r\n    request2.SetCompletionCallback(\r\n        Callback<void(int, const std::string&)>{\r\n            [](int status, const std::string& data) {\r\n                std::cout << \"Lambda handler - Status: \" << status \r\n                          << \", Data length: \" << data.length() << std::endl;\r\n            }\r\n        }\r\n    );\r\n    \r\n    request2.Start();\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n**Key Concepts:**\r\n- Type erasure with `std::function`\r\n- Perfect forwarding for efficient parameter passing\r\n- RAII for automatic resource management\r\n- Callback binding for asynchronous operations\r\n\r\n---\r\n\r\n## Learning Exercises\r\n\r\n### Exercise 1: Implement a Simple Chrome-style Process Manager\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <map>\r\n#include <memory>\r\n#include <string>\r\n\r\n// TODO: Implement a ProcessManager that can:\r\n// 1. Create and track different types of processes (renderer, gpu, network)\r\n// 2. Monitor process health\r\n// 3. Handle process crashes gracefully\r\n\r\nenum class ProcessType {\r\n    BROWSER,\r\n    RENDERER,\r\n    GPU,\r\n    NETWORK\r\n};\r\n\r\nclass Process {\r\nprivate:\r\n    int pid_;\r\n    ProcessType type_;\r\n    bool is_running_;\r\n    \r\npublic:\r\n    Process(int pid, ProcessType type) \r\n        : pid_(pid), type_(type), is_running_(true) {}\r\n    \r\n    // TODO: Add methods for:\r\n    // - GetPID()\r\n    // - GetType()\r\n    // - IsRunning()\r\n    // - Terminate()\r\n    // - GetMemoryUsage()\r\n};\r\n\r\nclass ProcessManager {\r\nprivate:\r\n    std::map<int, std::unique_ptr<Process>> processes_;\r\n    \r\npublic:\r\n    // TODO: Implement these methods:\r\n    // - CreateProcess(ProcessType type)\r\n    // - KillProcess(int pid)\r\n    // - GetProcessCount()\r\n    // - GetProcessesByType(ProcessType type)\r\n    // - HandleProcessCrash(int pid)\r\n};\r\n\r\nint main() {\r\n    ProcessManager manager;\r\n    \r\n    // TODO: Test your implementation\r\n    // Create processes, simulate crashes, clean up resources\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n### Exercise 2: Implement Chrome's WeakPtr Pattern\r\n\r\n```cpp\r\n#include <iostream>\r\n#include <memory>\r\n\r\n// TODO: Implement a WeakPtr system similar to Chromium's\r\n// WeakPtr is used to safely reference objects that might be deleted\r\n\r\ntemplate<typename T>\r\nclass WeakPtr;\r\n\r\ntemplate<typename T>\r\nclass WeakPtrFactory {\r\n    // TODO: Implement factory for creating weak pointers\r\n    // Should invalidate all weak pointers when destroyed\r\n};\r\n\r\ntemplate<typename T>\r\nclass WeakPtr {\r\n    // TODO: Implement weak pointer that:\r\n    // - Can safely check if object still exists\r\n    // - Returns nullptr if object was deleted\r\n    // - Can be used like a regular pointer when valid\r\n};\r\n\r\n// Test class\r\nclass BrowserWindow {\r\nprivate:\r\n    WeakPtrFactory<BrowserWindow> weak_factory_{this};\r\n    \r\npublic:\r\n    WeakPtr<BrowserWindow> GetWeakPtr() {\r\n        return weak_factory_.GetWeakPtr();\r\n    }\r\n    \r\n    void DoSomething() {\r\n        std::cout << \"BrowserWindow is doing something\\n\";\r\n    }\r\n};\r\n\r\nint main() {\r\n    // TODO: Test weak pointer behavior\r\n    // Create window, get weak ptr, delete window, test weak ptr\r\n    \r\n    return 0;\r\n}\r\n```\r\n\r\n---\r\n\r\n## Next Steps\r\n\r\nReady to dive deeper into Chromium development? Here are some areas to explore:\r\n\r\n1. **Content API**: Learn the public interface for embedding Chromium\r\n2. **Mojo IPC**: Understand inter-process communication\r\n3. **V8 Integration**: JavaScript engine integration patterns\r\n4. **Blink Rendering**: How web content gets rendered\r\n5. **Network Stack**: HTTP/HTTPS handling and caching\r\n\r\nThe code playground helps you understand these concepts before diving into the actual Chromium codebase!\r\n"
  },
  {
    "path": "demo/code-playground",
    "title": "Code Playground Demo",
    "content": "# Code Playground Demo\r\n\r\nWelcome to the interactive Code Playground! This feature allows you to write, edit, and execute code directly in the browser. Perfect for learning, experimenting, and testing code concepts.\r\n\r\n## JavaScript Playground\r\n\r\nLet's start with a simple JavaScript example. Try modifying the code and click \"Run\" to see the results:\r\n\r\n### Basic JavaScript Example\r\n\r\n```javascript\r\n// Welcome to the JavaScript playground!\r\n// Try modifying this code and clicking \"Run\"\r\n\r\nfunction greetUser(name) {\r\n    return `Hello, ${name}! Welcome to the Wanderlust Knowledge Base.`;\r\n}\r\n\r\nfunction calculateFactorial(n) {\r\n    if (n <= 1) return 1;\r\n    return n * calculateFactorial(n - 1);\r\n}\r\n\r\n// Test the functions\r\nconsole.log(greetUser(\"Developer\"));\r\nconsole.log(\"Factorial of 5:\", calculateFactorial(5));\r\n\r\n// Try some array methods\r\nconst numbers = [1, 2, 3, 4, 5];\r\nconst doubled = numbers.map(n => n * 2);\r\nconsole.log(\"Original:\", numbers);\r\nconsole.log(\"Doubled:\", doubled);\r\n\r\n// Return a value to see it in the output\r\n\"JavaScript playground is working! 🎉\"\r\n```\r\n\r\n**Instructions:** Modify the code above, add your own functions, or try different JavaScript features. The console output will appear below the editor.\r\n\r\n---\r\n\r\n## Advanced JavaScript: DOM and Modern Features\r\n\r\nThis playground demonstrates more advanced JavaScript concepts:\r\n\r\n### ES6+ Features and Async Programming\r\n\r\n```javascript\r\n// Modern JavaScript features demonstration\r\n\r\n// Destructuring and arrow functions\r\nconst user = { name: \"Alice\", age: 30, city: \"New York\" };\r\nconst { name, age } = user;\r\nconsole.log(`User: ${name}, Age: ${age}`);\r\n\r\n// Template literals and spread operator\r\nconst hobbies = [\"reading\", \"coding\"];\r\nconst moreHobbies = [...hobbies, \"hiking\", \"photography\"];\r\nconsole.log(\"Hobbies:\", moreHobbies.join(\", \"));\r\n\r\n// Async/await simulation (using setTimeout)\r\nasync function simulateApiCall() {\r\n    console.log(\"Starting API call...\");\r\n    return new Promise(resolve => {\r\n        setTimeout(() => {\r\n            resolve({ data: \"API response data\", status: \"success\" });\r\n        }, 1000);\r\n    });\r\n}\r\n\r\n// Class syntax\r\nclass Calculator {\r\n    constructor(name) {\r\n        this.name = name;\r\n    }\r\n    \r\n    add(a, b) {\r\n        console.log(`${this.name} calculating: ${a} + ${b} = ${a + b}`);\r\n        return a + b;\r\n    }\r\n    \r\n    multiply(a, b) {\r\n        console.log(`${this.name} calculating: ${a} × ${b} = ${a * b}`);\r\n        return a * b;\r\n    }\r\n}\r\n\r\n// Test the class\r\nconst calc = new Calculator(\"MyCalculator\");\r\ncalc.add(5, 3);\r\ncalc.multiply(4, 7);\r\n\r\n// Call the async function\r\nsimulateApiCall().then(result => {\r\n    console.log(\"API Result:\", result);\r\n});\r\n\r\n\"Advanced JavaScript concepts demo complete! ✨\"\r\n```\r\n\r\n**Instructions:** This example shows ES6+ features, classes, async/await, and more. Try adding your own modern JavaScript code!\r\n\r\n---\r\n\r\n## HTML/CSS Playground\r\n\r\nCreate interactive web content with HTML and CSS:\r\n\r\n### Interactive HTML Example\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Interactive Demo</title>\r\n    <style>\r\n        body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            max-width: 600px;\r\n            margin: 0 auto;\r\n            padding: 20px;\r\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\r\n            color: white;\r\n            min-height: 100vh;\r\n        }\r\n        \r\n        .card {\r\n            background: rgba(255, 255, 255, 0.1);\r\n            padding: 20px;\r\n            border-radius: 10px;\r\n            margin: 10px 0;\r\n            backdrop-filter: blur(10px);\r\n            border: 1px solid rgba(255, 255, 255, 0.2);\r\n        }\r\n        \r\n        button {\r\n            background: #ff6b6b;\r\n            color: white;\r\n            border: none;\r\n            padding: 10px 20px;\r\n            border-radius: 5px;\r\n            cursor: pointer;\r\n            font-size: 16px;\r\n            transition: all 0.3s ease;\r\n        }\r\n        \r\n        button:hover {\r\n            background: #ff5252;\r\n            transform: translateY(-2px);\r\n            box-shadow: 0 4px 8px rgba(0,0,0,0.2);\r\n        }\r\n        \r\n        .counter {\r\n            font-size: 24px;\r\n            font-weight: bold;\r\n            text-align: center;\r\n            margin: 20px 0;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"card\">\r\n        <h1>🚀 Interactive HTML Demo</h1>\r\n        <p>This is a live HTML/CSS example running in the browser!</p>\r\n        \r\n        <div class=\"counter\">\r\n            Count: <span id=\"count\">0</span>\r\n        </div>\r\n        \r\n        <button onclick=\"increment()\">Click Me!</button>\r\n        <button onclick=\"reset()\">Reset</button>\r\n    </div>\r\n    \r\n    <div class=\"card\">\r\n        <h2>✨ Features</h2>\r\n        <ul>\r\n            <li>Responsive design</li>\r\n            <li>Modern CSS with gradients and blur effects</li>\r\n            <li>Interactive JavaScript</li>\r\n            <li>Smooth animations</li>\r\n        </ul>\r\n    </div>\r\n\r\n    <script>\r\n        let count = 0;\r\n        const countElement = document.getElementById('count');\r\n        \r\n        function increment() {\r\n            count++;\r\n            countElement.textContent = count;\r\n            \r\n            // Add some fun effects\r\n            if (count % 10 === 0) {\r\n                document.body.style.background = `linear-gradient(135deg, \r\n                    hsl(${count * 10}, 70%, 60%) 0%, \r\n                    hsl(${count * 15}, 70%, 40%) 100%)`;\r\n            }\r\n        }\r\n        \r\n        function reset() {\r\n            count = 0;\r\n            countElement.textContent = count;\r\n            document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';\r\n        }\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**Instructions:** This HTML example includes CSS styling and JavaScript interactivity. Try modifying the styles, adding new elements, or changing the JavaScript logic!\r\n\r\n---\r\n\r\n## TypeScript Playground\r\n\r\nExperience TypeScript's powerful type system:\r\n\r\n### TypeScript Interfaces and Generics\r\n\r\n```typescript\r\n// TypeScript playground with interfaces and generics\r\n\r\ninterface User {\r\n    id: number;\r\n    name: string;\r\n    email: string;\r\n    isActive?: boolean;\r\n}\r\n\r\ninterface ApiResponse<T> {\r\n    data: T;\r\n    status: 'success' | 'error';\r\n    message?: string;\r\n}\r\n\r\n// Generic function\r\nfunction createApiResponse<T>(data: T, status: 'success' | 'error'): ApiResponse<T> {\r\n    return { data, status };\r\n}\r\n\r\n// Class with generics\r\nclass DataStore<T> {\r\n    private items: T[] = [];\r\n    \r\n    add(item: T): void {\r\n        this.items.push(item);\r\n        console.log(`Added item:`, item);\r\n    }\r\n    \r\n    getAll(): T[] {\r\n        return [...this.items];\r\n    }\r\n    \r\n    find(predicate: (item: T) => boolean): T | undefined {\r\n        return this.items.find(predicate);\r\n    }\r\n}\r\n\r\n// Usage examples\r\nconst userStore = new DataStore<User>();\r\n\r\nconst users: User[] = [\r\n    { id: 1, name: \"Alice Johnson\", email: \"alice@example.com\", isActive: true },\r\n    { id: 2, name: \"Bob Smith\", email: \"bob@example.com\", isActive: false },\r\n    { id: 3, name: \"Carol Davis\", email: \"carol@example.com\", isActive: true }\r\n];\r\n\r\nusers.forEach(user => userStore.add(user));\r\n\r\nconsole.log(\"All users:\", userStore.getAll());\r\n\r\nconst activeUser = userStore.find(user => user.isActive === true);\r\nconsole.log(\"First active user:\", activeUser);\r\n\r\n// API response example\r\nconst response = createApiResponse(users, 'success');\r\nconsole.log(\"API Response:\", response);\r\n\r\n// Type checking in action\r\n// This would cause a TypeScript error:\r\n// userStore.add(\"invalid user\"); // Error: string is not assignable to User\r\n\r\n\"TypeScript playground working with full type safety! 🛡️\"\r\n```\r\n\r\n**Instructions:** This TypeScript example demonstrates interfaces, generics, and type safety. Try adding new types or modifying the existing ones!\r\n\r\n---\r\n\r\n## Learning Exercises\r\n\r\n### Exercise 1: JavaScript Algorithm Practice\r\n\r\n```javascript\r\n// Algorithm practice: Implement a simple sorting algorithm\r\n// TODO: Complete the bubble sort implementation\r\n\r\nfunction bubbleSort(arr) {\r\n    // Your implementation here\r\n    // Hint: Use nested loops to compare adjacent elements\r\n    \r\n    return arr;\r\n}\r\n\r\n// Test your implementation\r\nconst testArray = [64, 34, 25, 12, 22, 11, 90];\r\nconsole.log(\"Original array:\", testArray);\r\nconsole.log(\"Sorted array:\", bubbleSort([...testArray]));\r\n\r\n// Expected output: [11, 12, 22, 25, 34, 64, 90]\r\n```\r\n\r\n**Expected Output:**\r\n```\r\nOriginal array: [64, 34, 25, 12, 22, 11, 90]\r\nSorted array: [11, 12, 22, 25, 34, 64, 90]\r\n```\r\n\r\n### Exercise 2: Build a Todo List\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <style>\r\n        body { font-family: Arial, sans-serif; max-width: 500px; margin: 50px auto; }\r\n        .todo-item { padding: 10px; margin: 5px 0; background: #f0f0f0; border-radius: 5px; }\r\n        .completed { text-decoration: line-through; opacity: 0.6; }\r\n        input, button { padding: 8px; margin: 5px; }\r\n        button { background: #007bff; color: white; border: none; border-radius: 3px; cursor: pointer; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <h1>📝 Todo List</h1>\r\n    <div>\r\n        <input type=\"text\" id=\"todoInput\" placeholder=\"Enter a new task...\">\r\n        <button onclick=\"addTodo()\">Add Task</button>\r\n    </div>\r\n    <div id=\"todoList\"></div>\r\n\r\n    <script>\r\n        let todos = [];\r\n        let nextId = 1;\r\n\r\n        function addTodo() {\r\n            const input = document.getElementById('todoInput');\r\n            const text = input.value.trim();\r\n            \r\n            if (text) {\r\n                todos.push({ id: nextId++, text, completed: false });\r\n                input.value = '';\r\n                renderTodos();\r\n            }\r\n        }\r\n\r\n        function toggleTodo(id) {\r\n            const todo = todos.find(t => t.id === id);\r\n            if (todo) {\r\n                todo.completed = !todo.completed;\r\n                renderTodos();\r\n            }\r\n        }\r\n\r\n        function deleteTodo(id) {\r\n            todos = todos.filter(t => t.id !== id);\r\n            renderTodos();\r\n        }\r\n\r\n        function renderTodos() {\r\n            const list = document.getElementById('todoList');\r\n            list.innerHTML = todos.map(todo => `\r\n                <div class=\"todo-item ${todo.completed ? 'completed' : ''}\">\r\n                    <span onclick=\"toggleTodo(${todo.id})\" style=\"cursor: pointer;\">\r\n                        ${todo.completed ? '✅' : '⬜'} ${todo.text}\r\n                    </span>\r\n                    <button onclick=\"deleteTodo(${todo.id})\" style=\"float: right; background: #dc3545;\">Delete</button>\r\n                </div>\r\n            `).join('');\r\n        }\r\n\r\n        // Add some sample todos\r\n        todos = [\r\n            { id: 1, text: \"Learn JavaScript\", completed: true },\r\n            { id: 2, text: \"Build a todo app\", completed: false },\r\n            { id: 3, text: \"Master React\", completed: false }\r\n        ];\r\n        nextId = 4;\r\n        renderTodos();\r\n    </script>\r\n</body>\r\n</html>\r\n```\r\n\r\n**Instructions:** This is a fully functional todo list! Try adding new features like editing tasks, filtering by completion status, or saving to localStorage.\r\n\r\n---\r\n\r\n## Code Playground Features\r\n\r\nThe Code Playground includes:\r\n\r\n- ✅ **Multi-language Support**: JavaScript, TypeScript, HTML, CSS, Python, C++\r\n- ✅ **Live Code Execution**: Run JavaScript and TypeScript code instantly\r\n- ✅ **Monaco Editor**: Full VS Code editor experience with IntelliSense\r\n- ✅ **Console Output**: See console.log output and errors\r\n- ✅ **Code Sharing**: Copy code to clipboard easily\r\n- ✅ **Reset Functionality**: Return to original code anytime\r\n- ✅ **Solution Toggle**: Show/hide solutions for learning exercises\r\n- ✅ **Theme Awareness**: Automatically matches your preferred theme\r\n- ✅ **Keyboard Shortcuts**: Ctrl/Cmd + Enter to run code\r\n- ✅ **File Tabs**: Support for multi-file projects\r\n- ✅ **Error Handling**: Graceful error display and debugging\r\n\r\nThis interactive learning environment makes it easy to experiment with code, learn new concepts, and test ideas without leaving the documentation!\r\n"
  },
  {
    "path": "demo/bookmark-features",
    "title": "Bookmark Feature Demo",
    "content": "# Bookmark Feature Demo\r\n\r\nThis page demonstrates the new bookmarking functionality in the Wanderlust Knowledge Base.\r\n\r\n## Features Overview\r\n\r\nThe bookmarking system includes:\r\n\r\n- **Page-level bookmarks**: Bookmark entire articles for quick access\r\n- **Section-level bookmarks**: Bookmark specific sections and code blocks\r\n- **Persistent storage**: Bookmarks are saved in localStorage\r\n- **Search and filter**: Find bookmarks by title, description, or category\r\n- **Import/Export**: Backup and restore your bookmarks\r\n- **Smart categorization**: Automatic categorization based on content location\r\n\r\n## How to Use Bookmarks\r\n\r\n### Bookmarking Pages\r\n\r\n1. Navigate to any page in the knowledge base\r\n2. Look for the bookmark button with label in the top-right corner of the content\r\n3. Click to bookmark the entire page\r\n\r\n### Bookmarking Sections\r\n\r\n1. Hover over any heading (h2, h3) or substantial code block\r\n2. A small bookmark icon will appear on the left side\r\n3. Click to bookmark that specific section\r\n\r\n### Accessing Your Bookmarks\r\n\r\n1. Click the bookmark icon in the header (shows count badge)\r\n2. Use the search box to find specific bookmarks\r\n3. Filter by category using the dropdown\r\n4. Sort by date, title, or category\r\n5. Click any bookmark to navigate directly to it\r\n\r\n### Managing Bookmarks\r\n\r\n- **Remove**: Click the trash icon on individual bookmarks or use the \"Clear\" button\r\n- **Export**: Save your bookmarks as a JSON file\r\n- **Import**: Load bookmarks from a previously exported file\r\n\r\n## Code Example\r\n\r\nHere's a sample code block that can be bookmarked:\r\n\r\n```typescript\r\ninterface BookmarkFeatures {\r\n  pageBookmarks: boolean;\r\n  sectionBookmarks: boolean;\r\n  persistentStorage: boolean;\r\n  searchAndFilter: boolean;\r\n  importExport: boolean;\r\n  categorization: boolean;\r\n}\r\n\r\nconst features: BookmarkFeatures = {\r\n  pageBookmarks: true,\r\n  sectionBookmarks: true,\r\n  persistentStorage: true,\r\n  searchAndFilter: true,\r\n  importExport: true,\r\n  categorization: true,\r\n};\r\n\r\nconsole.log('All bookmark features are implemented!', features);\r\n```\r\n\r\n## Technical Implementation\r\n\r\n### Architecture Components\r\n\r\nThe bookmarking system consists of:\r\n\r\n1. **BookmarkContext**: React context for state management\r\n2. **BookmarkButton**: Reusable bookmark toggle component\r\n3. **BookmarksPanel**: Full-featured bookmark management interface\r\n4. **SectionBookmark**: Wrapper for section-level bookmarking\r\n\r\n### Data Structure\r\n\r\nEach bookmark contains:\r\n- Unique ID and timestamp\r\n- Page title and path\r\n- Full URL for navigation\r\n- Optional section information\r\n- Category for organization\r\n- Custom description\r\n\r\n## Benefits\r\n\r\n- **Quick Navigation**: Jump directly to important content\r\n- **Personal Organization**: Create your own knowledge paths\r\n- **Offline Access**: Bookmarks work even when offline (with PWA)\r\n- **Cross-Session Persistence**: Bookmarks survive browser restarts\r\n- **Shareable**: Export and share bookmark collections with team members\r\n\r\nTry bookmarking this page and some sections to see the system in action!\r\n"
  },
  {
    "path": "debugging/overview",
    "title": "Debugging & Troubleshooting",
    "content": "# Debugging & Troubleshooting\r\n\r\nWelcome to the Debugging section! This comprehensive guide helps developers debug, troubleshoot, and analyze issues in the Wanderlust custom Chromium browser.\r\n\r\n## What You'll Find Here\r\n\r\nThis section provides essential debugging tools and techniques:\r\n\r\n- **[Chrome Internals URLs](chrome-internals-urls.md)**: Access internal Chrome debugging pages and diagnostic tools\r\n- **[Crash Reports](crash-reports.md)**: Understanding, generating, and analyzing crash reports\r\n- **[Debugging Tools](debugging-tools.md)**: Essential tools and techniques for effective debugging\r\n\r\n## Debugging Workflow\r\n\r\nWhen encountering issues in your Chromium development:\r\n\r\n1. **Identify the Problem**: Reproduce the issue and gather initial information\r\n2. **Use Internal Tools**: Leverage Chrome's built-in debugging URLs and tools\r\n3. **Analyze Logs**: Check console output, crash reports, and diagnostic information\r\n4. **Apply Debugging Tools**: Use specialized debugging tools for deeper analysis\r\n\r\n## Common Debugging Scenarios\r\n\r\n- **Browser Crashes**: Use crash report analysis and debugging symbols\r\n- **Performance Issues**: Profile using Chrome DevTools and internal performance pages\r\n- **Network Problems**: Debug using network internals and protocol analysis\r\n- **Rendering Issues**: Inspect the rendering pipeline and GPU processes\r\n- **JavaScript/V8 Issues**: Debug the V8 engine and JavaScript execution\r\n\r\n## Quick Access to Debugging Resources\r\n\r\n- **Chrome Internals**: `chrome://` URLs for instant access to internal debugging pages\r\n- **Crash Analysis**: Tools and techniques for understanding browser crashes\r\n- **Performance Profiling**: Built-in tools for performance analysis and optimization\r\n\r\n## Integration with Development\r\n\r\nThese debugging techniques integrate seamlessly with:\r\n- [Architecture](../architecture/overview.md) understanding for system-level debugging\r\n- [Modules](../modules/overview.md) specific debugging for individual components\r\n- [Getting Started](../getting-started/overview.md) setup for debugging environment configuration\r\n\r\n---\r\n\r\n*Start debugging effectively by exploring our [debugging tools guide](debugging-tools.md) and familiarizing yourself with [Chrome internal URLs](chrome-internals-urls.md).*\r\n"
  },
  {
    "path": "debugging/debugging-tools",
    "title": "Debugging Tools",
    "content": "# Debugging Tools\r\n\r\nWhen working on Chromium you’ll rely on a variety of built-in tools and flags to inspect, profile, and diagnose both browser and renderer behavior. This guide surveys the most useful techniques, commands, and UIs for catching bugs, measuring performance, and analyzing crashes.\r\n\r\n---\r\n\r\n## 1. Logging & Verbose Flags\r\n\r\nChromium uses VLOG and `--v` logging levels throughout. To enable:\r\n\r\n```bash\r\nout/Default/chrome \\\r\n  --enable-logging=stderr \\\r\n  --v=1             # basic INFO-level logs\r\n  --vmodule=\"*.cc=2\"  # more verbose logging for specific source files\r\nLevels\r\n\r\n--v=0 (WARN & above)\r\n\r\n--v=1 (INFO)\r\n\r\n--v=2..5 (DEBUG with increasing detail)\r\n\r\nRedirecting\r\n\r\n--log-net-log=netlog.json to capture network internals\r\n\r\n--log-file=chrome.log to write all logs to a file\r\n\r\n2. Crash Reporting & Breakpad\r\nChromium’s built-in crash handler (Crashpad on Windows/macOS):\r\n\r\nCrash dumps are written under out/Default/crashes/ by default.\r\n\r\nSymbolization:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/format_symbolized_stacktrace \\\r\n  --symbols-dir=./out/Default \\\r\n  crashes/<dump>.dmp\r\nIntegration\r\n\r\nUnder Git workflows you can upload to a Breakpad server or run locally with minidump_stackwalk.\r\n\r\n3. Chrome Developer Tools\r\nAccessible via F12 or chrome://inspect, DevTools offers:\r\n\r\nElements & Styles\r\n\r\nLive DOM/CSS inspection and editing\r\n\r\nConsole\r\n\r\nRuntime errors, logging APIs, and JS REPL\r\n\r\nSources\r\n\r\nSet breakpoints in JS, step through V8 bytecode/native code\r\n\r\nPerformance\r\n\r\nRecord CPU & heap profiles; “flamethrower” view of main-thread tasks\r\n\r\nNetwork\r\n\r\nInspect HTTP headers, payloads, timing breakdowns\r\n\r\n4. Tracing & Flame Charts\r\n4.1 chrome://tracing\r\nRecord IPC, rendering, and thread-level events.\r\n\r\nFilter by categories (--trace-startup, --trace-mem).\r\n\r\nExport to JSON and view in the Trace Event Profiling Tool.\r\n\r\n4.2 Perfetto (Android & Desktop)\r\n--enable-perfetto and chrome://perfetto for system-wide tracing.\r\n\r\nCaptures kernel, GPU, and user-space events together.\r\n\r\n5. Memory & Heap Analysis\r\n5.1 Heap Profiling\r\nJS heap: use DevTools’ Memory tab → Heap snapshots.\r\n\r\nNative heap:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --enable-heap-checking --heap-profiler\r\ngenerates .heap files, viewable with pprof or Chrome’s heap profiler UI.\r\n\r\n5.2 Address Sanitizer (ASan)\r\nEnable with GN args:\r\n\r\ngn\r\nCopy\r\nEdit\r\nis_asan = true\r\nDetects use-after-free, buffer-overflow errors at runtime.\r\n\r\n5.3 Leak Sanitizer (LSan) & Thread Sanitizer (TSan)\r\nSimilar flags (is_lsan, is_tsan) to catch leaks and data races.\r\n\r\n6. CPU Profiling\r\nSampling profiler via DevTools Performance → CPU.\r\n\r\nIn-process profiler:\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --prof\r\nwrites isolate-0x*.log for V8 CPU sampling.\r\n\r\nExternal tools\r\n\r\nLinux: perf record -g -- out/Default/chrome\r\n\r\nmacOS: Instruments → Time Profiler\r\n\r\n7. GDB & Native Debugging\r\nLaunch Chrome under GDB:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngdb --args out/Default/chrome --enable-logging=stderr\r\nSet breakpoints in C++ (content/browser/..., render_process_main.cc).\r\n\r\nUse thread apply all bt to get stacks from all threads.\r\n\r\n8. Network & Protocol Inspection\r\nchrome://net-export to record HTTP/QUIC traces; then view in NetLog Viewer.\r\n\r\nchrome://webrtc-internals for WebRTC peer-connection stats.\r\n\r\nWireshark: enable --log-net-log and import the JSON trace.\r\n\r\n9. Automated Tests & Debug Builds\r\nDebug Builds (is_debug=true) include assertions and symbol info.\r\n\r\nUnit / Browser Tests:\r\n\r\nbash\r\nCopy\r\nEdit\r\nautoninja -C out/Default content_unittests\r\nout/Default/content_unittests --gtest_filter=YourTest.*\r\nInstrumentation Tests run via run_local_tests.py (Android).\r\n\r\n10. Remote & Headless Debugging\r\nRemote Debugging\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --remote-debugging-port=9222\r\nthen connect DevTools to localhost:9222.\r\n\r\nHeadless Mode\r\n\r\nbash\r\nCopy\r\nEdit\r\nout/Default/chrome --headless --dump-dom https://example.com\r\n11. Common Pitfalls & Tips\r\nStale binaries: remember to gn gen after changing args.\r\n\r\nCache issues: use --disable-application-cache or --user-data-dir=<tmp> to avoid profile interference.\r\n\r\nDevTools hooks: use --remote-debugging-allow-hosts=* when debugging CI environments.\r\n\r\n12. Next Steps\r\nPair Traces → Flame Charts with CPU profiles to correlate jank.\r\n\r\nUse ASan/TSan in your CI builds to catch low-level bugs early.\r\n\r\nIntegrate --enable-heap-checking into nightly runs for memory leak detection."
  },
  {
    "path": "debugging/crash-reports",
    "title": "Crash Reports in Chromium",
    "content": "# Crash Reports in Chromium\r\n\r\nCrash reports are an essential part of debugging and maintaining Chromium. They provide detailed information about crashes, helping developers identify and resolve issues efficiently.\r\n\r\n---\r\n\r\n## Generating a Crash Report\r\n\r\nTo generate a crash report in Chromium:\r\n\r\n1. Open Chromium and access the URL `http://crash/` to trigger the generation of a crash report.\r\n2. The crash report will be saved in the following locations:\r\n   - **Linux**: `~/.config/google-chrome/Crash Reports/`\r\n   - **Windows/Mac**: `/path/to/profile/Crash Reports`\r\n\r\n### Preventing Crash Reports from Being Sent (Linux)\r\n\r\nOn Linux platforms, you can prevent crash reports from being sent to the server by setting the `CHROME_HEADLESS` environment variable. For example:\r\n\r\n```bash\r\n$ env CHROME_HEADLESS=1 ./out/Debug/chrome-wrapper\r\n```\r\n\r\nThis ensures that crash reports are generated locally without being uploaded to the server.\r\n\r\n## Parsing a Crash Report\r\nCrash reports in Chromium can be parsed using the minidump_stackwalk tool. This tool processes the .dmp files generated during a crash and provides a readable stack trace.\r\n\r\nSteps to Parse a Crash Report:\r\nUse the following command to parse a crash report:\r\n```bash\r\n$ minidump_stackwalk <report-name>.dmp\r\n```\r\nFor crash reports generated on Linux, you may need to remove the file header before parsing. To do this:\r\nOpen the .dmp file in a text editor.\r\nSearch for the MDMP character sequence.\r\nDelete the header before the MDMP sequence.\r\n\r\n## References\r\nFor more information on decoding and handling crash reports in Chromium, refer to the following resources:\r\n\r\n![Decoding Crash Dumps](https://www.chromium.org/developers/decoding-crash-dumps)\r\n![Linux Crash Dumping](https://chromium.googlesource.com/chromium/src/+/HEAD/docs/linux_crash_dumping.md)\r\n\r\n## Additional Notes\r\nCrash Report Locations:\r\nEnsure you have the correct permissions to access the crash report directories.\r\nLicensing:\r\nThe original content referenced in this document is licensed under ![CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/)."
  },
  {
    "path": "debugging/chrome-internals-urls",
    "title": "Chrome Internal URLs (Pseudo-URLs)",
    "content": "# Chrome Internal URLs (Pseudo-URLs)\r\n\r\nChrome provides a set of internal URLs (pseudo-URLs) that allow developers and advanced users to access various debugging, configuration, and diagnostic tools. These URLs are accessible by typing them into the Chrome address bar.\r\n\r\n---\r\n\r\n## Common Chrome Internal URLs\r\n\r\n### 1. Accessibility\r\n- **URL**: `chrome://accessibility/`\r\n- **Description**: Displays accessibility analysis tools. By default, accessibility is off. Clicking \"Show Accessibility Tree\" displays the analysis tree.\r\n\r\n---\r\n\r\n### 2. Application Cache\r\n- **URL**: `chrome://appcache-internals/`\r\n- **Description**: Displays a list of all application cache paths.\r\n\r\n---\r\n\r\n### 3. Installed Apps\r\n- **URL**: `chrome://apps/`\r\n- **Description**: Lists all currently installed Chrome apps.\r\n\r\n---\r\n\r\n### 4. Blob Files\r\n- **URL**: `chrome://blob-internals/`\r\n- **Description**: Displays the current list of internal blob files.\r\n\r\n---\r\n\r\n### 5. Bookmarks\r\n- **URL**: `chrome://bookmarks/`\r\n- **Description**: Opens the Bookmark Manager.\r\n\r\n---\r\n\r\n### 6. Cache\r\n- **URL**: `chrome://cache/`\r\n- **Description**: Displays a list of cached URLs. Clicking a URL shows detailed information about the cache file, including type, encoding, expiration time, and binary content.\r\n\r\n---\r\n\r\n### 7. Chrome About Page\r\n- **URL**: `chrome://chrome/`\r\n- **Description**: Displays the current Chrome version information.\r\n\r\n---\r\n\r\n### 8. Chrome URL List\r\n- **URL**: `chrome://chrome-urls/`\r\n- **Description**: Displays a list of all available Chrome pseudo-URLs.\r\n\r\n---\r\n\r\n### 9. Components\r\n- **URL**: `chrome://components/`\r\n- **Description**: Lists Chrome components. You can check for updates and download new versions if available.\r\n\r\n---\r\n\r\n### 10. Crashes\r\n- **URL**: `chrome://crashes/`\r\n- **Description**: Displays the current Chrome crash reports. Crash reporting must be enabled for this to work. Refer to [Google Support](https://support.google.com/chrome/answer/96817) for enabling crash reporting.\r\n\r\n---\r\n\r\n### 11. Device Logs\r\n- **URL**: `chrome://device-log/`\r\n- **Description**: Displays device logs. Use `chrome://device-log/?refresh=seconds` to enable automatic refresh.\r\n\r\n---\r\n\r\n### 12. Discards\r\n- **URL**: `chrome://discards/`\r\n- **Description**: Displays discarded tab pages, sorted by priority. Tabs with the lowest priority may be discarded if memory usage exceeds available resources.\r\n\r\n---\r\n\r\n### 13. DNS\r\n- **URL**: `chrome://dns/`\r\n- **Description**: Displays DNS pre-resolution and TCP pre-connection data. If disabled, you can enable \"Pre-fetch resources for faster loading of web pages\" in settings.\r\n\r\n---\r\n\r\n### 14. Downloads\r\n- **URL**: `chrome://downloads/`\r\n- **Description**: Opens the Downloads page.\r\n\r\n---\r\n\r\n### 15. Extensions\r\n- **URL**: `chrome://extensions/`\r\n- **Description**: Lists all installed extensions.\r\n\r\n---\r\n\r\n### 16. Experimental Features\r\n- **URL**: `chrome://flags/`\r\n- **Description**: Displays a list of experimental features that can be enabled or disabled.\r\n\r\n---\r\n\r\n### 17. GPU Information\r\n- **URL**: `chrome://gpu/`\r\n- **Description**: Displays GPU information, including hardware acceleration status and GPU memory buffer details.\r\n\r\n---\r\n\r\n### 18. Histograms\r\n- **URL**: `chrome://histograms/`\r\n- **Description**: Displays histogram data for browser performance metrics.\r\n\r\n---\r\n\r\n### 19. IndexedDB Internals\r\n- **URL**: `chrome://indexeddb-internals/`\r\n- **Description**: Displays a list of internal IndexedDB instances, including paths, modification times, and database sizes.\r\n\r\n---\r\n\r\n### 20. Inspect Devices\r\n- **URL**: `chrome://inspect/`\r\n- **Description**: Detects devices, pages, extensions, and apps. Displays all currently open tabs under the \"Pages\" tab, with an option to inspect them using developer tools.\r\n\r\n---\r\n\r\n### 21. Memory Usage\r\n- **URL**: `chrome://memory/`\r\n- **Description**: Redirects to `chrome://memory-redirect/`, showing memory usage for each process, including private, shared, and total memory.\r\n\r\n---\r\n\r\n### 22. Network Internals\r\n- **URL**: `chrome://net-internals/`\r\n- **Description**: Displays network-related information, including proxy settings, DNS cache, and timing data.\r\n\r\n---\r\n\r\n### 23. Plugins\r\n- **URL**: `chrome://plugins/`\r\n- **Description**: Displays information about installed plugins. (Note: This URL is deprecated in newer versions of Chrome.)\r\n\r\n---\r\n\r\n### 24. Print\r\n- **URL**: `chrome://print/`\r\n- **Description**: Opens the browser's print dialog.\r\n\r\n---\r\n\r\n### 25. Sync Internals\r\n- **URL**: `chrome://sync-internals/`\r\n- **Description**: Displays synchronization information for Chrome accounts, including last sync time, token requests, and event logs.\r\n\r\n---\r\n\r\n### 26. System Information\r\n- **URL**: `chrome://system/`\r\n- **Description**: Displays diagnostic data, including Chrome version, OS version, memory usage, and USB device information.\r\n\r\n---\r\n\r\n### 27. Tracing\r\n- **URL**: `chrome://tracing/`\r\n- **Description**: Allows recording and monitoring of Chrome's performance data.\r\n\r\n---\r\n\r\n### 28. User Actions\r\n- **URL**: `chrome://user-actions/`\r\n- **Description**: Displays a list of user actions, including the type of operation and when it occurred.\r\n\r\n---\r\n\r\n### 29. Version Information\r\n- **URL**: `chrome://version/`\r\n- **Description**: Displays detailed version information for Chrome, including the JavaScript engine version, Flash plugin version, and user agent string.\r\n\r\n---\r\n\r\n## References\r\n\r\nFor a complete list of Chrome internal URLs, visit `chrome://chrome-urls/` in your browser.\r\n\r\n---\r\n\r\n*This document consolidates information from various sources, including the Chromium documentation and external references.*"
  },
  {
    "path": "contributing/overview",
    "title": "Contributing to Wanderlust Knowledge Base",
    "content": "# Contributing to Wanderlust Knowledge Base\r\n\r\nWelcome to the Contributing section! This area contains essential information for developers who want to contribute to the Wanderlust project and its custom Chromium browser implementation.\r\n\r\n## What You'll Find Here\r\n\r\nThis section covers the fundamental aspects of contributing to our project:\r\n\r\n- **Contributing Guidelines**: Comprehensive guide on how to contribute code, documentation, and bug reports\r\n- **Development Workflow**: Best practices for development, testing, and submission processes\r\n- **Code Standards**: Coding conventions and quality requirements\r\n- **Review Process**: How pull requests and code reviews are handled\r\n\r\n## Getting Started with Contributing\r\n\r\nIf you're new to contributing to Chromium-based projects, this section will help you understand:\r\n\r\n- How to set up your development environment\r\n- Understanding the project structure and codebase\r\n- Following our coding standards and conventions\r\n- Submitting your first contribution\r\n\r\n## Key Resources\r\n\r\n- Review the main [Contributing Guide](contributing.md) for detailed instructions\r\n- Familiarize yourself with the [Getting Started](../getting-started/overview.md) section for development setup\r\n- Check the [Architecture](../architecture/overview.md) section to understand the codebase structure\r\n\r\n## Community Guidelines\r\n\r\nWe maintain a welcoming and inclusive environment for all contributors. Our contributing guidelines ensure that all team members can effectively collaborate on building our custom Chromium browser.\r\n\r\n---\r\n\r\n*Ready to contribute? Start with our [detailed contributing guide](contributing.md) to learn about our development process and requirements.*\r\n"
  },
  {
    "path": "contributing/contributing",
    "title": "Contributing to C### 1.1. System### 1.1. System Requirements",
    "content": "# Contributing to C### 1.1. System### 1.1. System Requirements\r\n\r\n**Minimum Requirements for v134+:**\r\n- **Python**: 3.8+ (3.11+ recommended for Bazel builds)\r\n- **Git**: 2.35+ with LFS support\r\n- **Memory**: 32GB RAM minimum (64GB for full builds)\r\n- **Storage**: 200GB+ available space (SSD strongly recommended)\r\n- **OS Support**: \r\n  - Windows 11 with WSL2 or na### 3.2. Component Prefixes (Updated for v134)\r\n\r\n**Core Components:**\r\n- `[base]` - Base library changes\r\n- `[content]` - Content layer (renderer, browser processes)\r\n- `[chrome]` - Chrome browser UI and features\r\n- `[net]` - Network stack\r\n- `[security]` - Security-related changes\r\n- `[gpu]` - Graphics and GPU acceleration\r\n- `[mojo]` - IPC and service interfaces\r\n\r\n**New v134+ Components:**\r\n- `[rust]` - Rust integration and components\r\n- `[bazel]` - Build system migration\r\n- `[fuchsia]` - Fuchsia OS support\r\n- `[webgpu]` - WebGPU implementation\r\n- `[origin-trial]` - Origin trial features\r\n\r\n### 3.3. Security-Sensitive Changes\r\n\r\nFor security-related commits, additional requirements apply:\r\n\r\n```\r\n[security] Fix XSS vulnerability in URL parsing\r\n\r\nThis change addresses a cross-site scripting vulnerability where\r\nmalicious URLs could bypass sanitization in the omnibox.\r\n\r\nThe fix implements stricter URL validation using a allowlist\r\napproach rather than blocklist to prevent future bypasses.\r\n\r\nBug: chromium:1234567\r\nSecurity-Review: security-team@chromium.org\r\nSecurity-Severity: high\r\nSecurity-Bug: 1234567\r\nTest: security_tests --gtest_filter=UrlSanitizer.*\r\nChange-Id: I1234567890abcdef1234567890abcdef12345678\r\n```\r\n\r\n### 3.4. Performance-Sensitive Changes\r\n\r\nFor changes affecting performance:\r\n\r\n```\r\n[base] Optimize string concatenation in base::StrCat\r\n\r\nReplace repeated string allocations with a single pre-sized\r\nbuffer allocation, reducing memory pressure and improving\r\nperformance for common string operations.\r\n\r\nBenchmark results:\r\n- 25% reduction in allocations\r\n- 15% improvement in wall-clock time\r\n- No regression in peak memory usage\r\n\r\nBug: chromium:1234567\r\nPerformance-Impact: medium\r\nBenchmark: base_perftests --gtest_filter=StringConcatBenchmark\r\nTest: base_unittests --gtest_filter=StrCat*\r\nChange-Id: I1234567890abcdef1234567890abcdef12345678\r\n```\r\n\r\n### 3.5. Required Footer Tags\r\n\r\n**Mandatory for all commits:**\r\n- `Change-Id:` - Generated by git-cl\r\n- `Test:` - How the change was tested\r\n- `Bug:` - Associated bug (use \"none\" if no bug)\r\n\r\n**Conditional tags:**\r\n- `Security-Review:` - Required for security-sensitive changes\r\n- `Performance-Impact:` - Required for performance-affecting changes\r\n- `Breaking-Change:` - Required for API/behavior changes\r\n- `Security-Severity:` - For security fixes (low|medium|high|critical)\r\n- `Rust-Component:` - For Rust integration changes\r\n- `Origin-Trial:` - For experimental web platform features\r\n\r\n## 4. Testing & ValidationwerShell 7+\r\n  - macOS 12+ (Intel/Apple Silicon)\r\n  - Ubuntu 20.04+ or equivalent Linux distribution\r\n\r\n**Required Accounts & Agreements:**\r\n- Google account with [Chromium CLA][cla] signed\r\n- GitHub account (for security scanning integration)\r\n- Access to [chromium-security mailing list][security-list] (for security-sensitive contributions)irements\r\n\r\n**Minimum Requirements for v134+:**\r\n- **Python**: 3.8+ (3.11+ recommended for Bazel builds)\r\n- **Git**: 2.35+ with LFS support\r\n- **Memory**: 32GB RAM minimum (64GB for full builds)\r\n- **Storage**: 200GB+ available space (SSD strongly recommended)\r\n- **OS Support**: \r\n  - Windows 11 with WSL2 or native PowerShell 7+\r\n  - macOS 12+ (Intel/Apple Silicon)\r\n  - Ubuntu 20.04+ or equivalent Linux distribution\r\n\r\n**Required Accounts & Agreements:**\r\n- Google account with [Chromium CLA][cla] signed\r\n- GitHub account (for security scanning integration)\r\n- Access to [chromium-security mailing list][security-list] (for security-sensitive contributions)um\r\n\r\nWelcome to the Chromium project! This comprehensive guide will walk you through contributing to Chromium v134+, covering everything from initial setup to landing your first security-reviewed patch.\r\n\r\n## What's New in v134+\r\n\r\nChromium v134+ introduces significant architectural improvements:\r\n- **Bazel Build Migration**: Gradual transition from GN to Bazel for improved build performance\r\n- **Enhanced Security Model**: Mandatory security reviews for sensitive components\r\n- **C++23 Support**: Modern language features for improved safety and performance\r\n- **Rust Integration**: Selected components now use Rust for memory safety\r\n- **Advanced Testing**: Enhanced fuzzing and automated security scanning\r\n\r\nWhether you're fixing a bug, implementing a feature, or improving performance, this guide ensures your contribution meets our v134+ standards for security, performance, and maintainability.\r\n\r\n---\r\n\r\n## 1. Prerequisites & Environment Setup\r\n\r\n### 1.1. Prerequisites\r\n\r\n- You’ve [set up and built Chromium][setup-build].  \r\n- You have a Google account and have signed the [Chromium Contributor License Agreement (CLA)][cla].  \r\n- On Linux/macOS you have Python 3 and Git installed; on Windows you’re using PowerShell with Depot Tools in your `PATH`.\r\n\r\n### 1.2. Development Environment Options\r\n\r\n#### Option A: Native Development (Recommended)\r\n\r\n1. **Install Depot Tools**\r\n   ```bash\r\n   # Linux/macOS\r\n   git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git\r\n   export PATH=\"$PATH:/path/to/depot_tools\"\r\n   \r\n   # Windows (PowerShell as Administrator)\r\n   git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git C:\\depot_tools\r\n   $env:PATH += \";C:\\depot_tools\"\r\n   ```\r\n\r\n2. **Clone Chromium with v134+ Support**\r\n   ```bash\r\n   mkdir chromium && cd chromium\r\n   fetch --nohooks chromium\r\n   cd src\r\n   \r\n   # Enable Bazel builds (experimental in v134)\r\n   echo \"use_bazel = true\" >> .gclient\r\n   gclient sync --with_branch_heads --with_tags --jobs=16\r\n   ```\r\n\r\n#### Option B: Container Development (Security Isolation)\r\n\r\nFor security-sensitive development, use our official container:\r\n\r\n```bash\r\n# Pull the v134+ development container\r\ndocker pull gcr.io/chromium-container-dev/chromium:v134\r\n\r\n# Run with proper mounts and security\r\ndocker run -it --security-opt seccomp=unconfined \\\r\n  -v $PWD:/workspace \\\r\n  gcr.io/chromium-container-dev/chromium:v134\r\n```\r\n\r\n### 1.3. Git Configuration\r\n\r\n```bash\r\n# Set your identity (must match CLA)\r\ngit config --global user.name \"Your Full Name\"\r\ngit config --global user.email \"your.email@domain.com\"\r\n\r\n# Enable security features\r\ngit config --global commit.gpgsign true\r\ngit config --global tag.forceSignAnnotated true\r\ngit config --global pull.rebase true\r\n\r\n# Configure for large repositories\r\ngit config --global core.preloadindex true\r\ngit config --global core.fscache true\r\ngit config --global gc.auto 256\r\n```\r\n\r\n### 1.4. Authentication Setup\r\n\r\n1. **Gerrit SSH Access**\r\n   ```bash\r\n   # Generate Ed25519 key (more secure than RSA)\r\n   ssh-keygen -t ed25519 -C \"your.email@domain.com\"\r\n   \r\n   # Upload public key to Gerrit settings\r\n   # Test connection\r\n   ssh -p 29418 chromium-review.googlesource.com\r\n   ```\r\n\r\n2. **Enable 2FA** (Required for security contributions)\r\n   - Enable 2FA on your Google account\r\n   - Configure app-specific passwords for depot_tools\r\n\r\n### 1.5. Build Configuration\r\n\r\nCreate your build configuration for v134+:\r\n\r\n```bash\r\n# Generate build files with security hardening\r\ngn gen out/Default --args='\r\n  is_debug = true\r\n  is_component_build = true\r\n  enable_nacl = false\r\n  use_goma = true\r\n  symbol_level = 1\r\n  blink_symbol_level = 0\r\n  enable_security_hardening = true\r\n  use_sanitizer_coverage = true\r\n'\r\n\r\n# For Bazel builds (experimental)\r\nbazel build --config=chromium_dev //chrome:chrome\r\n```\r\n\r\n## 2. Coding Conventions & Style\r\n\r\nChromium v134+ follows modern, security-first coding practices across multiple languages. Our style guides have been updated to leverage the latest language features while maintaining performance and security.\r\n\r\n### 2.1. C++ Guidelines (C++23)\r\n\r\n**Modern C++ Features in v134+:**\r\n```cpp\r\n// Use concepts for better template constraints\r\ntemplate<std::integral T>\r\nclass SafeInteger {\r\n  T value_;\r\npublic:\r\n  constexpr explicit SafeInteger(T val) : value_(val) {}\r\n  \r\n  // Use designated initializers\r\n  struct Config {\r\n    bool enable_bounds_check = true;\r\n    size_t max_value = std::numeric_limits<size_t>::max();\r\n  };\r\n};\r\n\r\n// Prefer ranges and views\r\nauto ProcessItems(const std::vector<Item>& items) {\r\n  return items \r\n    | std::views::filter([](const Item& item) { return item.IsValid(); })\r\n    | std::views::transform([](const Item& item) { return item.Process(); });\r\n}\r\n```\r\n\r\n**Security-First Patterns:**\r\n```cpp\r\n// Always use smart pointers for memory management\r\nstd::unique_ptr<NetworkHandler> CreateHandler() {\r\n  return std::make_unique<NetworkHandler>();\r\n}\r\n\r\n// Use base::span for safe array access\r\nvoid ProcessData(base::span<const uint8_t> data) {\r\n  // Bounds-checked access automatically\r\n  for (auto byte : data) {\r\n    // Process safely\r\n  }\r\n}\r\n\r\n// Prefer std::optional over null pointers\r\nstd::optional<UserSession> GetCurrentSession() {\r\n  if (auto* session = session_manager_->current_session()) {\r\n    return UserSession(*session);\r\n  }\r\n  return std::nullopt;\r\n}\r\n```\r\n\r\n### 2.2. Rust Integration Guidelines\r\n\r\nFor components migrated to Rust in v134+:\r\n\r\n```rust\r\n// Use strict clippy lints\r\n#![deny(clippy::all)]\r\n#![deny(unsafe_code)]\r\n#![warn(clippy::pedantic)]\r\n\r\n// Prefer explicit error handling\r\npub fn parse_config(data: &[u8]) -> Result<Config, ConfigError> {\r\n    serde_json::from_slice(data)\r\n        .map_err(ConfigError::ParseError)\r\n}\r\n\r\n// Use strong typing for security\r\n#[derive(Debug, Clone)]\r\npub struct SanitizedUrl(String);\r\n\r\nimpl SanitizedUrl {\r\n    pub fn new(url: &str) -> Result<Self, UrlError> {\r\n        // Validation logic\r\n        if is_safe_url(url) {\r\n            Ok(Self(url.to_string()))\r\n        } else {\r\n            Err(UrlError::Unsafe)\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 2.3. JavaScript/TypeScript Guidelines\r\n\r\n**Modern TypeScript Patterns:**\r\n```typescript\r\n// Use strict mode and modern features\r\ninterface SecurityPolicy {\r\n  readonly cspDirectives: ReadonlyArray<string>;\r\n  readonly allowedOrigins: Set<string>;\r\n}\r\n\r\n// Prefer const assertions and template literals\r\nconst API_ENDPOINTS = {\r\n  users: '/api/v2/users',\r\n  sessions: '/api/v2/sessions',\r\n} as const;\r\n\r\n// Use discriminated unions for type safety\r\ntype ApiResponse<T> = \r\n  | { success: true; data: T }\r\n  | { success: false; error: string };\r\n\r\nasync function fetchUserData(id: string): Promise<ApiResponse<User>> {\r\n  try {\r\n    const response = await fetch(`${API_ENDPOINTS.users}/${id}`);\r\n    const data = await response.json();\r\n    return { success: true, data };\r\n  } catch (error) {\r\n    return { success: false, error: error.message };\r\n  }\r\n}\r\n```\r\n\r\n### 2.4. Style Requirements\r\n\r\n**Formatting & Structure:**\r\n- **Indentation**: 2 spaces (no tabs) for all languages\r\n- **Line Length**: \r\n  - C++/Rust: 80 characters for code, 100 for comments\r\n  - JavaScript/TypeScript: 100 characters\r\n- **File Organization**: Group includes/imports by type (system, third-party, local)\r\n\r\n**Naming Conventions:**\r\n```cpp\r\n// C++ Examples\r\nclass NetworkRequestHandler {};        // PascalCase for types\r\nvoid ProcessHttpRequest();             // PascalCase for functions\r\nconst int kMaxRetryCount = 3;          // k prefix for constants\r\nbool is_secure_connection_ = false;    // snake_case for members\r\n```\r\n\r\n```rust\r\n// Rust Examples\r\nstruct HttpClient {}                   // PascalCase for types\r\nfn process_request() {}               // snake_case for functions\r\nconst MAX_RETRY_COUNT: i32 = 3;       // SCREAMING_SNAKE_CASE for constants\r\n```\r\n\r\n### 2.5. Code Quality Tools\r\n\r\n**Mandatory Pre-submission Checks:**\r\n```bash\r\n# C++ formatting and linting\r\ngit cl presubmit --upload\r\ntools/clang/scripts/run-clang-format.py --style=chromium\r\ntools/clang/scripts/run-clang-tidy.py\r\n\r\n# Rust checks (for Rust components)\r\ncargo clippy --all-targets --all-features -- -D warnings\r\ncargo fmt --check\r\n\r\n# JavaScript/TypeScript\r\nnpm run lint\r\nnpm run type-check\r\n```\r\n\r\n**Security Analysis:**\r\n```bash\r\n# Run security scanners before upload\r\ntools/security/run-security-checks.py\r\ntools/fuzz/check-fuzz-targets.py\r\n\r\n# Memory safety validation\r\ntools/valgrind/chrome_tests.py\r\ntools/asan/run-tests.py\r\n```\r\n\r\n### 2.6. Documentation Standards\r\n\r\n**Required Documentation:**\r\n```cpp\r\n// Header documentation with security considerations\r\n/**\r\n * Handles secure network communication for browser processes.\r\n * \r\n * SECURITY: All input must be validated before processing.\r\n * This class handles sensitive network data and must not\r\n * leak information across security boundaries.\r\n * \r\n * @thread_safety This class is not thread-safe. Use from\r\n * the main thread only.\r\n */\r\nclass SecureNetworkHandler {\r\n public:\r\n  // Document security-relevant parameters\r\n  bool ProcessRequest(const std::string& url,  // Must be validated URL\r\n                     const Headers& headers);   // Trusted headers only\r\n};\r\n```\r\n\r\n## 3. Commit Message Format\r\n\r\nChromium v134+ uses structured commit messages for automated processing, security tracking, and release management. Follow this format precisely:\r\n\r\n### 3.1. Standard Format\r\n\r\n```\r\n[component] Brief summary (50 chars max)\r\n\r\nDetailed description of your change:\r\n- What problem this solves\r\n- Implementation approach\r\n- Performance/security implications\r\n- Breaking changes (if any)\r\n\r\nBug: chromium:1234567\r\nChange-Id: I1234567890abcdef1234567890abcdef12345678\r\nTest: unit_tests --gtest_filter=MyTest.*\r\nSecurity-Review: security-team@ (if security-sensitive)\r\nPerformance-Impact: none|low|medium|high\r\n```\r\nPrefix each message with [area], e.g. [content], [net], [ui].\r\n\r\nInclude a Bug: link if you’re fixing or closing an issue.\r\n\r\nMention tests in the Test: line.\r\n\r\n## 4. Testing & Validation\r\n\r\nChromium v134+ requires comprehensive testing across multiple dimensions: functionality, security, performance, and compatibility. All changes must pass automated validation before review.\r\n\r\n### 4.1. Pre-Upload Validation\r\n\r\n**Mandatory Checks (All Changes):**\r\n```bash\r\n# Format and lint checks\r\ngit cl presubmit --upload\r\ntools/clang/scripts/run-clang-format.py --style=chromium --in-place\r\ntools/clang/scripts/run-clang-tidy.py --checks=-*,readability-*,security-*\r\n\r\n# Build verification (multiple configurations)\r\nautoninja -C out/Default chrome\r\nautoninja -C out/Release chrome\r\nautoninja -C out/Debug chrome\r\n\r\n# Basic functionality tests\r\nout/Default/unit_tests --gtest_filter=*YourComponent*\r\nout/Default/browser_tests --gtest_filter=*YourFeature*\r\n```\r\n\r\n**Security-Sensitive Changes:**\r\n```bash\r\n# Security-specific validation\r\ntools/security/run-security-checks.py --component=your_component\r\ntools/fuzz/check-fuzz-targets.py --validate-new-targets\r\n\r\n# Memory safety verification\r\nautoninja -C out/ASan chrome  # AddressSanitizer build\r\nautoninja -C out/MSan chrome  # MemorySanitizer build\r\nout/ASan/unit_tests --gtest_filter=*YourComponent*\r\n\r\n# Fuzzing validation (if adding new attack surfaces)\r\ntools/fuzz/run-fuzz-tests.py --component=your_component --duration=60s\r\n```\r\n\r\n### 4.2. Test Framework Requirements\r\n\r\n**Unit Testing (Required for all code changes):**\r\n```cpp\r\n// Modern C++ testing with security focus\r\n#include \"testing/gtest/include/gtest/gtest.h\"\r\n#include \"testing/gmock/include/gmock/gmock.h\"\r\n#include \"base/test/scoped_feature_list.h\"\r\n\r\nclass SecureUrlParserTest : public testing::Test {\r\n protected:\r\n  void SetUp() override {\r\n    feature_list_.InitAndEnableFeature(features::kSecureUrlParsing);\r\n  }\r\n\r\n  base::test::ScopedFeatureList feature_list_;\r\n};\r\n\r\nTEST_F(SecureUrlParserTest, RejectsInvalidUrls) {\r\n  // Test security boundary conditions\r\n  EXPECT_FALSE(parser_.IsValid(\"javascript:alert(1)\"));\r\n  EXPECT_FALSE(parser_.IsValid(\"data:text/html,<script>\"));\r\n  \r\n  // Test edge cases that previously caused issues\r\n  EXPECT_FALSE(parser_.IsValid(std::string(10000, 'a')));  // Length attack\r\n  EXPECT_FALSE(parser_.IsValid(\"http://\\x00.example.com\"));  // Null byte injection\r\n}\r\n\r\nTEST_F(SecureUrlParserTest, HandlesValidUrlsCorrectly) {\r\n  EXPECT_TRUE(parser_.IsValid(\"https://example.com/path\"));\r\n  EXPECT_TRUE(parser_.IsValid(\"chrome://settings/\"));\r\n}\r\n```\r\n\r\n**Integration Testing (Required for UI/API changes):**\r\n```cpp\r\n// Browser test with real Chrome instances\r\n#include \"chrome/test/base/in_process_browser_test.h\"\r\n#include \"chrome/test/base/ui_test_utils.h\"\r\n\r\nclass PasswordManagerSecurityTest : public InProcessBrowserTest {\r\n public:\r\n  void SetUpOnMainThread() override {\r\n    // Set up secure test environment\r\n    EnableSecurityFeatures();\r\n  }\r\n};\r\n\r\nIN_PROC_BROWSER_TEST_F(PasswordManagerSecurityTest, BiometricAuthRequired) {\r\n  // Navigate to password manager\r\n  ASSERT_TRUE(ui_test_utils::NavigateToURL(browser(), \r\n    GURL(\"chrome://settings/passwords\")));\r\n  \r\n  // Verify biometric prompt appears\r\n  EXPECT_TRUE(WaitForBiometricPrompt());\r\n  \r\n  // Test successful authentication\r\n  SimulateBiometricAuth(true);\r\n  EXPECT_TRUE(PasswordListVisible());\r\n}\r\n```\r\n\r\n### 4.3. Rust Component Testing\r\n\r\nFor Rust components in v134+:\r\n\r\n```rust\r\n// Comprehensive Rust testing\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n    use std::panic;\r\n    \r\n    #[test]\r\n    fn test_secure_url_parsing() {\r\n        let parser = SecureUrlParser::new();\r\n        \r\n        // Test valid URLs\r\n        assert!(parser.parse(\"https://example.com\").is_ok());\r\n        \r\n        // Test security boundary conditions\r\n        assert!(parser.parse(\"javascript:alert(1)\").is_err());\r\n        assert!(parser.parse(&\"a\".repeat(100_000)).is_err());\r\n    }\r\n    \r\n    #[test]\r\n    fn test_memory_safety() {\r\n        // Rust automatically provides memory safety, but test edge cases\r\n        let large_input = \"x\".repeat(1_000_000);\r\n        let result = panic::catch_unwind(|| {\r\n            SecureUrlParser::new().parse(&large_input)\r\n        });\r\n        assert!(result.is_ok(), \"Parser should handle large inputs gracefully\");\r\n    }\r\n}\r\n\r\n// Property-based testing for security\r\n#[cfg(test)]\r\nmod property_tests {\r\n    use proptest::prelude::*;\r\n    \r\n    proptest! {\r\n        #[test]\r\n        fn url_parser_never_panics(s in \"\\\\PC*\") {\r\n            let parser = SecureUrlParser::new();\r\n            let _ = parser.parse(&s); // Should never panic\r\n        }\r\n        \r\n        #[test]\r\n        fn valid_urls_stay_valid(url in valid_url_strategy()) {\r\n            let parser = SecureUrlParser::new();\r\n            prop_assert!(parser.parse(&url).is_ok());\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n### 4.4. Performance Testing\r\n\r\n**Mandatory for performance-sensitive changes:**\r\n```bash\r\n# Performance regression testing\r\ntools/perf/run_benchmark.py --browser=release \\\r\n  --benchmark=loading.desktop \\\r\n  --story-filter=\"*your_feature*\"\r\n\r\n# Memory usage validation\r\ntools/memory/run_memory_test.py --test-filter=\"*YourComponent*\"\r\n\r\n# Startup time verification (critical for browser changes)\r\ntools/perf/run_benchmark.py --browser=release \\\r\n  --benchmark=start_with_url.cold.startup_pages\r\n\r\n# Custom performance tests\r\nout/Release/performance_tests --gtest_filter=*YourFeature*\r\n```\r\n\r\n### 4.5. Cross-Platform Testing\r\n\r\n**Required test matrix for v134+:**\r\n```bash\r\n# Windows (multiple versions)\r\npython tools/autotest/run_tests.py --platform=win10_x64\r\npython tools/autotest/run_tests.py --platform=win11_x64\r\n\r\n# macOS (Intel and Apple Silicon)\r\npython tools/autotest/run_tests.py --platform=mac_x64\r\npython tools/autotest/run_tests.py --platform=mac_arm64\r\n\r\n# Linux (multiple distributions)\r\npython tools/autotest/run_tests.py --platform=linux_x64\r\npython tools/autotest/run_tests.py --platform=linux_arm64\r\n\r\n# ChromeOS\r\npython tools/autotest/run_tests.py --platform=chromeos_x64\r\n```\r\n\r\n### 4.6. Security Testing Requirements\r\n\r\n**Fuzzing (Required for new attack surfaces):**\r\n```bash\r\n# Create fuzzing target for new components\r\ncat > fuzz_your_component.cc << 'EOF'\r\n#include \"base/logging.h\"\r\n#include \"your_component/your_component.h\"\r\n\r\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\r\n  if (size < 1) return 0;\r\n  \r\n  std::string input(reinterpret_cast<const char*>(data), size);\r\n  YourComponent component;\r\n  \r\n  // Fuzz all public methods safely\r\n  component.ProcessInput(input);\r\n  return 0;\r\n}\r\nEOF\r\n\r\n# Build and run fuzzer\r\nautoninja -C out/Fuzzer your_component_fuzzer\r\nout/Fuzzer/your_component_fuzzer -max_total_time=300\r\n```\r\n\r\n**Security Boundary Testing:**\r\n```cpp\r\n// Test process isolation boundaries\r\nTEST_F(SecurityTest, ProcessIsolationMaintained) {\r\n  // Ensure renderer cannot access browser memory\r\n  EXPECT_FALSE(CanAccessBrowserMemory());\r\n  \r\n  // Test IPC validation\r\n  EXPECT_FALSE(SendInvalidIPC());\r\n}\r\n\r\n// Test against known attack patterns\r\nTEST_F(SecurityTest, ResistantToKnownAttacks) {\r\n  // Test against XXS attempts\r\n  EXPECT_FALSE(ExecutesArbitraryScript(\"javascript:alert(1)\"));\r\n  \r\n  // Test against buffer overflow attempts\r\n  std::string overflow_attempt(10000, 'A');\r\n  EXPECT_FALSE(CausesBufferOverflow(overflow_attempt));\r\n}\r\n```\r\n\r\n### 4.7. Manual Testing Checklist\r\n\r\n**Smoke Testing (All Changes):**\r\n- [ ] Browser starts without crashes\r\n- [ ] Basic navigation works (loading pages, back/forward)\r\n- [ ] No obvious visual regressions\r\n- [ ] Feature works as designed\r\n- [ ] No new console errors or warnings\r\n\r\n**Security-Sensitive Changes:**\r\n- [ ] No information leakage across security boundaries\r\n- [ ] Authentication/authorization works correctly  \r\n- [ ] Input validation rejects malicious inputs\r\n- [ ] No new attack surfaces introduced\r\n\r\n**Performance-Sensitive Changes:**\r\n- [ ] No significant startup time regression\r\n- [ ] Memory usage remains stable\r\n- [ ] No new performance cliffs or bottlenecks\r\n- [ ] Benchmark numbers meet expectations\r\n\r\n### 4.8. Automated Testing Integration\r\n\r\n**CI/CD Pipeline Integration:**\r\n```yaml\r\n# Example .gn configuration for automated testing\r\ntest_targets = [\r\n  \"//your_component:unit_tests\",\r\n  \"//your_component:integration_tests\", \r\n  \"//your_component:security_tests\",\r\n  \"//your_component:performance_tests\",\r\n]\r\n\r\n# Security-specific CI requirements\r\nsecurity_tests = [\r\n  \"//security:url_sanitizer_tests\",\r\n  \"//security:xss_prevention_tests\",\r\n  \"//security:csrf_protection_tests\",\r\n]\r\n```\r\n\r\n## 5. Code Review Process\r\nCommit & Upload\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit checkout -b my-feature-branch\r\ngit commit -a\r\ngit cl upload\r\nReviewer Feedback\r\n\r\nAddress comments by amending your commit:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit commit --amend\r\ngit cl upload --replace\r\nGetting LGTM\r\nOnce two reviewers give LGTM and CQ+1 passes, your change will land automatically.\r\n\r\n6. Working with Gerrit\r\nView your changes:\r\nhttps://chromium-review.googlesource.com/q/status:open+owner:self\r\n\r\nCherry-picking / rebasing:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit fetch https://chromium.googlesource.com/chromium/src refs/changes/54/12354/2 && git cherry-pick FETCH_HEAD\r\nUndoing a landed CL:\r\nUpload a revert by clicking “Revert Change” in the Gerrit UI.\r\n\r\n7. Troubleshooting & Common Pitfalls\r\nPresubmit failures\r\n\r\nCheck the Buildbucket logs for style or test errors.\r\n\r\nMerge conflicts\r\n\r\nRebase onto main:\r\n\r\nbash\r\nCopy\r\nEdit\r\ngit fetch origin main && git rebase origin/main\r\nSlow builds\r\n\r\nUse autoninja -j<N> matching your CPU cores.\r\n\r\n8. Beyond Code\r\nDesign Documents\r\n\r\nFor large features, submit a design doc under docs/ and get early feedback.\r\n\r\nLocalization\r\n\r\nUI strings live in chrome/app/resources/; use l10n tools to extract/update translations.\r\n\r\nDocumentation\r\n\r\nKeep inline /README.md files up to date in each directory you touch.\r\n\r\n9. Getting Help & Community\r\nMailing Lists: chromium-dev@chromium.org\r\n\r\nIRC/Slack: channels listed on the Chromium Community wiki\r\n\r\nWeekly Office Hours: check the Chromium Calendar\r\n\r\n10. Next Steps\r\nRead Getting Started → Project Layout to orient yourself in the tree.\r\n\r\nPick a Good First Issue and try submitting a small fix.\r\n\r\nCelebrate landing your first commit—welcome to the Chromium community!\r\n\r\nHappy coding!\r\n\r\narduino\r\nCopy\r\nEdit\r\n\r\nThis guide will give newcomers a clear path: set up their environment, follow style and commit guidelines, run tests, and navigate Chromium’s Gerrit-based review process. Let me know if you’d like any tweaks or additions!"
  },
  {
    "path": "architecture/render-pipeline",
    "title": "Render Pipeline",
    "content": "# Render Pipeline\r\n\r\nChromium's render pipeline transforms HTML, CSS and JavaScript into pixels on your screen. In this article we'll cover each major stage, the threads involved, and how Chromium optimizes for smooth, high-performance rendering in modern versions (v134+).\r\n\r\n---\r\n\r\n## 1. Overview & Motivation\r\n\r\n- **Goals**  \r\n  - **Speed**: maintain 60 FPS (or higher) on modern devices with 120Hz+ displays  \r\n  - **Smoothness**: avoid jank by minimizing main-thread work per frame  \r\n  - **Efficiency**: only repaint and composite what changed using advanced optimization techniques  \r\n  - **Responsiveness**: prioritize user interactions and critical rendering paths\r\n\r\n- **Key Processes**  \r\n  - **Browser Process**: coordinates navigation, input, and process management  \r\n  - **Renderer Process**: handles parsing, style computation, layout, and paint preparation  \r\n  - **GPU Process**: manages compositing, rasterization, and hardware acceleration via Viz  \r\n\r\n- **Modern Architecture (v134+)**  \r\n  - **Viz Display Compositor**: unified GPU-accelerated compositing architecture  \r\n  - **SkiaRenderer**: advanced Skia-based rendering backend  \r\n  - **Out-of-Process Rasterization (OOP-R)**: rasterization moved to GPU process  \r\n  - **Canvas2D in GPU Process**: hardware-accelerated canvas rendering\r\n\r\n*(Link back to [Architecture → Process Model](process-model.md) for IPC & sandbox context.)*\r\n\r\n---\r\n\r\n## 2. Stage 1 – Document Parsing & DOM Construction\r\n\r\n1. **HTML Tokenizer**  \r\n   - Splits raw bytes into tokens using streaming parser  \r\n   - Supports incremental parsing for progressive rendering  \r\n\r\n2. **DOM Tree Builder**  \r\n   - Builds a tree of `Node` objects from tokens  \r\n   - Handles `<script>` tags: may pause parsing for execution  \r\n   - Uses **script streaming** for async script compilation  \r\n\r\n3. **Preload Scanner**  \r\n   - Speculatively discovers resources during parsing  \r\n   - Enables early resource loading for better performance  \r\n\r\n4. **Progressive Rendering**  \r\n   - Allows rendering to begin before full document parse  \r\n   - Critical for perceived performance on large pages  \r\n\r\n```text\r\nHTML Bytes → [Preload Scanner] → Resource Discovery\r\n     ↓\r\n[Tokenizer] → Tokens → [Parser] → DOM Tree\r\n```\r\n\r\n---\r\n\r\n## 3. Stage 2 – CSS Style Resolution & Computed Styles\r\n\r\n### CSSOM Construction\r\n- **CSS Tokenizer**: Parses stylesheets into CSSOM tree  \r\n- **Rule Matching**: Optimized selector matching against DOM nodes  \r\n- **Cascade Resolution**: Handles specificity, inheritance, and !important rules  \r\n\r\n### Style Computation (Blink StyleEngine)\r\n- **Computed Style Calculation**: Resolves all CSS properties to computed values  \r\n- **CSS Container Queries**: Modern layout feature support (v134+)  \r\n- **CSS Cascade Layers**: Advanced cascade control mechanisms  \r\n- **Style Invalidation**: Efficiently updates styles when changes occur  \r\n\r\n### Modern CSS Features (v134+)\r\n- **CSS Grid subgrid**: Advanced grid layout capabilities  \r\n- **CSS View Transitions**: Smooth page transitions  \r\n- **CSS Color Level 4**: Extended color spaces and functions  \r\n- **CSS Logical Properties**: Writing-mode aware properties  \r\n\r\n```text\r\nCSS → [Parser] → CSSOM → [Style Engine] → Computed Styles\r\n                    ↓\r\nDOM + CSSOM → [Style Resolver] → Styled Elements\r\n```\r\n\r\n---\r\n\r\n## 4. Stage 3 – Layout (Reflow) & Modern Layout Engines\r\n\r\n### Box Tree Construction\r\n- **LayoutObject Tree**: Wraps styled nodes into layout boxes  \r\n- **Modern Layout**: Support for Flexbox, Grid, and Container Queries  \r\n- **NG Layout Engine**: Next-generation layout system for better performance  \r\n\r\n### Layout Computation\r\n- **Flow & Positioning**: Box model, floats, positioning schemes  \r\n- **Fragmentation**: Multi-column, CSS regions, and printing support  \r\n- **Intrinsic Sizing**: Content-based sizing calculations  \r\n- **Layout Containment**: Performance optimizations through CSS containment  \r\n\r\n### Threading & Performance\r\n- **Main Thread**: Primary layout computation  \r\n- **Layout Shift Prevention**: Core Web Vitals optimization  \r\n- **Incremental Layout**: Only relayout affected subtrees  \r\n\r\n**Output**: LayoutObject tree with precise geometry and positioning\r\n\r\n```text\r\nStyled Elements → [NG Layout] → LayoutObject Tree with Geometry\r\n```\r\n\r\n---\r\n\r\n## 5. Stage 4 – Paint Preparation & Recording\r\n\r\n### Paint Operation Generation\r\n- **Paint Records**: Translates LayoutObjects into Skia drawing operations  \r\n- **Display Lists**: Serializes paint commands for efficient replay  \r\n- **Paint Worklets**: CSS Paint API support for custom rendering  \r\n\r\n### Layer Creation & Compositing Decisions\r\n- **Compositing Triggers**: CSS transforms, opacity, filters, will-change  \r\n- **Layer Tree**: Organizes content into compositable layers  \r\n- **Paint Invalidation**: Tracks which regions need repainting  \r\n- **Backdrop Filters**: Advanced filter effects on layer content  \r\n\r\n### Modern Paint Features (v134+)\r\n- **Variable Fonts**: Advanced typography support  \r\n- **CSS Color Spaces**: P3, Rec2020, and other wide-gamut colors  \r\n- **Advanced Filters**: CSS filter effects and backdrop-filter  \r\n\r\n**Key Classes**: `PaintController`, `DisplayItemList`, `PaintLayer`\r\n\r\n```text\r\nLayoutObjects → [Paint] → Display Lists → Layer Tree\r\n```\r\n\r\n---\r\n\r\n## 6. Stage 5 – Rasterization & GPU Acceleration\r\n\r\n### Out-of-Process Rasterization (OOP-R)\r\n- **GPU Process Raster**: Rasterization moved from renderer to GPU process  \r\n- **Vulkan Backend**: Modern graphics API support on supported platforms  \r\n- **Metal Backend**: macOS hardware acceleration  \r\n- **Performance Benefits**: Reduced memory usage and improved parallelism  \r\n\r\n### Tile-Based Rendering\r\n- **Raster Tiles**: Large layers split into manageable tiles  \r\n- **Tile Prioritization**: Visible tiles rendered first  \r\n- **Tile Caching**: Intelligent reuse of unchanged tile content  \r\n- **GPU Texture Management**: Efficient GPU memory allocation  \r\n\r\n### Modern Rasterization Features\r\n- **SkiaRenderer**: Advanced Skia-based rendering backend  \r\n- **Hardware-accelerated Canvas**: Canvas2D operations in GPU process  \r\n- **WebGL Integration**: Seamless 3D content integration  \r\n\r\n**Output**: GPU textures and rasterized tile bitmaps\r\n\r\n```text\r\nDisplay Lists → [OOP Raster] → GPU Textures → Tile Cache\r\n```\r\n\r\n---\r\n\r\n## 7. Stage 6 – Compositing & Display via Viz\r\n\r\n### Viz Display Compositor Architecture\r\n- **Unified Compositing**: Single compositor for all content types  \r\n- **Surface Aggregation**: Combines surfaces from multiple sources  \r\n- **Damage Tracking**: Precise tracking of changed regions  \r\n- **Frame Synchronization**: Coordinated frame submission across processes  \r\n\r\n### GPU Process Composition\r\n- **CompositorFrameSink**: Interface for submitting compositor frames  \r\n- **Surface Hierarchy**: Nested surface management for complex layouts  \r\n- **Display Transform**: Handle device rotation and scaling  \r\n- **HDR Support**: High dynamic range content rendering  \r\n\r\n### Present & VSync Integration\r\n- **Frame Scheduling**: Intelligent frame timing based on display capabilities  \r\n- **Variable Refresh Rate**: Support for adaptive sync displays  \r\n- **Frame Pacing**: Optimized frame submission for smooth animation  \r\n- **Multi-Display**: Synchronized rendering across multiple screens  \r\n\r\n**Output**: Smooth, synchronized frames displayed to screen\r\n\r\n```text\r\nLayer Tree → [Viz Compositor] → GPU → Display Hardware\r\n```\r\n\r\n---\r\n\r\n## 8. Threading & Modern Pipeline Architecture\r\n\r\n### Thread Responsibilities (v134+)\r\n\r\n| Thread | Work | Modern Enhancements |\r\n|--------|------|-------------------|\r\n| **Main** | DOM, CSSOM, style, layout, paint commands | Script streaming, lazy loading |\r\n| **Compositor** | Layer tree updates, IPC to GPU process | Viz integration, surface management |\r\n| **Raster** | Display list → GPU textures (OOP-R) | GPU process rasterization |\r\n| **GPU** | Texture uploads, draw calls, compositing | SkiaRenderer, Vulkan/Metal support |\r\n| **IO** | Network, file operations | Parallel resource loading |\r\n| **Worker** | Web Workers, Service Workers | Off-main-thread execution |\r\n\r\n### Performance Optimizations\r\n- **Frame Pipelining**: Chromium overlaps raster & GPU work across frames to maximize throughput\r\n- **Predictive Loading**: Anticipate user actions for better responsiveness  \r\n- **Priority-based Scheduling**: Critical rendering path optimization\r\n- **Concurrent Processing**: Multi-threaded execution where possible\r\n\r\n---\r\n\r\n## 9. Modern Optimizations & Techniques (v134+)\r\n\r\n### Rendering Optimizations\r\n- **Partial Invalidation**: Only repaint precisely changed regions using damage tracking\r\n- **Occlusion Culling**: Skip rendering completely hidden content\r\n- **Content Visibility**: CSS content-visibility for performance gains\r\n- **Container Queries**: Efficient responsive design without layout thrashing\r\n\r\n### GPU & Memory Optimizations  \r\n- **Zero-Copy Paths**: Direct GPU texture for video, WebGL, and canvas content\r\n- **Memory Pressure Handling**: Intelligent texture eviction under memory constraints\r\n- **Shared GPU Memory**: Efficient cross-process texture sharing\r\n- **Tile Prioritization**: Render visible content first, defer off-screen tiles\r\n\r\n### Scrolling & Animation\r\n- **Compositor-Only Scrolling**: Smooth scrolling without main thread involvement\r\n- **Transform Animations**: GPU-accelerated CSS transforms and animations\r\n- **Scroll Anchoring**: Prevent layout shifts during dynamic content loading\r\n- **Paint Holding**: Minimize flash of unstyled content (FOUC)\r\n\r\n### Modern Web Features\r\n- **Canvas OffscreenCanvas**: Multi-threaded canvas rendering\r\n- **WebAssembly Integration**: Optimized WASM execution in rendering pipeline\r\n- **WebGPU Support**: Next-generation graphics API integration\r\n- **CSS Containment**: Isolation boundaries for performance optimization\r\n\r\n---\r\n\r\n## 10. Debugging & Performance Analysis (v134+)\r\n\r\n### Chrome DevTools Integration\r\n- **Performance Panel**: Detailed flame graphs with modern metrics\r\n- **Rendering Tab**: Layer visualization, paint flashing, and layout shift detection\r\n- **Core Web Vitals**: LCP, FID, CLS measurement and optimization guidance\r\n- **Memory Panel**: GPU memory usage and texture analysis\r\n\r\n### Command Line Debugging\r\n```bash\r\n# Modern GPU debugging flags\r\n--enable-gpu-rasterization          # Force GPU rasterization\r\n--enable-vulkan                     # Use Vulkan backend (where supported)\r\n--disable-gpu-sandbox               # Disable GPU process sandbox (debug only)\r\n--show-composited-layer-borders     # Visualize compositing layers\r\n--show-paint-rects                  # Highlight repainted regions\r\n--enable-logging=stderr             # Detailed logging output\r\n\r\n# Performance analysis\r\n--trace-startup                     # Profile startup performance\r\n--no-sandbox                       # Disable sandboxing (debug builds only)\r\n```\r\n\r\n### Chrome Internal Pages\r\n- **chrome://gpu/**: GPU capabilities and feature status\r\n- **chrome://tracing/**: Advanced performance tracing with timeline visualization\r\n- **chrome://histograms/**: Detailed performance metrics and histograms\r\n- **chrome://memory-internals/**: Memory usage breakdown by process\r\n- **chrome://discards/**: Tab lifecycle and memory pressure information\r\n\r\n### Blink Rendering Metrics\r\n- **First Contentful Paint (FCP)**: Time to first visible content\r\n- **Largest Contentful Paint (LCP)**: Time to largest content element\r\n- **Cumulative Layout Shift (CLS)**: Visual stability measurement\r\n- **First Input Delay (FID)**: Input responsiveness metric\r\n\r\n---\r\n\r\n## 11. Next Steps & Further Reading\r\n\r\n### Advanced Topics\r\n- **[Browser Components](browser-components.md)**: Cross-process services and architecture\r\n- **[Storage & Cache](../modules/storage-cache.md)**: How caching integrates with rendering pipeline\r\n- **[Security Model](../security/security-model.md)**: Sandboxing and process isolation details\r\n\r\n### Experimental Features (v134+)\r\n- **Document Transition API**: Smooth page transitions with shared element animations\r\n- **CSS Anchor Positioning**: Advanced positioning relative to other elements\r\n- **WebGPU Integration**: Next-generation graphics API for web applications\r\n- **Advanced Typography**: Variable fonts and OpenType features\r\n\r\n### Performance Optimization Resources\r\n- **Web Performance Working Group**: Latest standards and best practices\r\n- **Chrome Platform Status**: Track new rendering features and their implementation status\r\n- **Lighthouse CI**: Automated performance testing and Core Web Vitals monitoring\r\n\r\n### Hands-On Experiments\r\n```bash\r\n# Try modern GPU acceleration\r\n--enable-gpu-rasterization --enable-vulkan\r\n\r\n# Profile rendering performance\r\nchrome://tracing/ with \"Rendering\" category enabled\r\n\r\n# Measure Core Web Vitals\r\nDevTools → Lighthouse → Performance audit\r\n\r\n# Visualize rendering pipeline\r\nDevTools → Rendering → Paint flashing + Layer borders\r\n```\r\n\r\n---\r\n\r\n**End of Modern Render Pipeline Guide**\r\n\r\n### Key Changes in v134+\r\n- **Viz Display Compositor**: Unified GPU-accelerated compositing\r\n- **Out-of-Process Rasterization**: Improved performance and stability\r\n- **SkiaRenderer**: Advanced graphics rendering backend\r\n- **Modern CSS Support**: Container queries, cascade layers, color spaces\r\n- **Enhanced Performance Tools**: Better debugging and optimization capabilities\r\n\r\n**Notes for Developers:**\r\n- Monitor Chrome Platform Status for latest rendering features\r\n- Use modern CSS containment for performance optimization\r\n- Leverage GPU acceleration through proper layer promotion\r\n- Profile regularly with DevTools Performance panel and Core Web Vitals metrics\r\n"
  },
  {
    "path": "architecture/process-model",
    "title": "Process Model",
    "content": "# Process Model\r\n\r\nChromium's multi-process architecture has evolved significantly in recent versions (v134+) to provide enhanced stability, security, and performance through sophisticated process isolation and modern service-based design. This article explores each process type, communication patterns, and the advanced sandboxing model that protects users in the modern web.\r\n\r\n![](../../img/architecture/multiprocess-architecture.png)\r\n\r\n---\r\n\r\n## 1. Why Multi-Process Architecture? (v134+ Enhancements)\r\n\r\n- **Enhanced Isolation**  \r\n  - Crashes in renderers, GPU, or service processes don't affect the browser\r\n  - **Site Isolation**: Strict per-origin process boundaries for security\r\n  - **Process-per-frame**: Fine-grained isolation for embedded content\r\n\r\n- **Advanced Security (v134+)**  \r\n  - **Spectre/Meltdown Mitigations**: Process boundaries prevent cross-origin data leaks\r\n  - **Enhanced Sandboxing**: Improved platform-specific security restrictions  \r\n  - **Control Flow Integrity (CFI)**: Hardware-assisted exploit prevention\r\n\r\n- **Modern Performance Optimizations**  \r\n  - **Intelligent Process Management**: Dynamic process allocation based on memory pressure\r\n  - **Background Tab Throttling**: Aggressive resource management for inactive content\r\n  - **GPU Process Optimization**: Unified Viz compositor for better performance\r\n  - **Service-based Architecture**: Microservice design for better scalability\r\n\r\n---\r\n\r\n## 2. Browser Process (Enhanced in v134+)\r\n\r\nThe **Browser Process** serves as the central coordinator and control hub for Chromium's architecture, managing all other processes and providing the primary user interface.\r\n\r\n- **Core Responsibilities**  \r\n  - **UI Management**: Address bar, tabs, menus, extensions UI\r\n  - **Navigation Coordination**: Cross-origin navigation and security decisions\r\n  - **Storage Management**: Cookies, cache, local storage, IndexedDB coordination\r\n  - **Process Lifecycle**: Launching, monitoring, and terminating child processes\r\n  - **Security Policy Enforcement**: Site isolation decisions and sandbox configuration\r\n\r\n- **Modern Components (v134+)**  \r\n  - `BrowserMainLoop` (enhanced main event loop)\r\n  - `SiteIsolationPolicy` (per-origin process management)\r\n  - `ProcessManager` (intelligent process allocation)\r\n  - `ServiceManager` (microservice coordination)\r\n  - `FeaturePolicyManager` (permissions and feature controls)\r\n\r\n- **Advanced Features**  \r\n  - **Memory Pressure Management**: Intelligent tab discarding and process prioritization\r\n  - **Extension Security**: Enhanced extension process isolation\r\n  - **DevTools Integration**: Advanced debugging and profiling capabilities\r\n  - **Update Management**: Background update coordination and rollback support\r\n\r\nThe browser process uses sophisticated **Mojo IPC** channels to communicate with all child processes while maintaining strict security boundaries.\r\n\r\n---\r\n\r\n## 3. Renderer Processes (Modern Site Isolation in v134+)\r\n\r\n**Renderer Processes** are responsible for web content rendering, JavaScript execution, and DOM management, with enhanced security through strict site isolation policies.\r\n\r\n- **Core Responsibilities**  \r\n  - **Blink Engine**: Modern HTML/CSS parsing, layout, and painting\r\n  - **V8 JavaScript Engine**: High-performance JavaScript execution with JIT compilation\r\n  - **DOM Management**: Document tree construction and manipulation\r\n  - **Web APIs**: Implementation of modern web platform features\r\n\r\n- **Enhanced Isolation (v134+)**  \r\n  - **Site-per-Process**: Strict per-origin process boundaries (default since v67, enhanced in v134+)\r\n  - **Cross-Origin Isolation**: Prevention of Spectre-style attacks through process boundaries\r\n  - **Origin Agent Clusters**: Fine-grained process allocation for related origins\r\n  - **CORB/CORP Protection**: Cross-Origin Read Blocking and Resource Policy enforcement\r\n\r\n- **Threading Architecture**  \r\n  - **Main Thread**: DOM operations, style computation, layout, JavaScript execution\r\n  - **Compositor Thread**: Hardware-accelerated scrolling and animations\r\n  - **Worker Threads**: Web Workers, Service Workers, Worklets\r\n  - **Raster Threads**: Painting and texture generation (when not using GPU process)\r\n\r\n- **Modern Security Features**  \r\n  - **Process Isolation**: Complete memory isolation between different origins\r\n  - **Sandbox Restrictions**: Severely limited file system and network access\r\n  - **Control Flow Integrity**: Hardware-assisted exploit mitigation\r\n  - **Memory Protection**: Advanced heap protection and UAF detection\r\n\r\n- **Performance Optimizations**  \r\n  - **Code Caching**: Optimized JavaScript bytecode caching\r\n  - **Background Processing**: Intelligent prioritization of background tabs\r\n  - **Memory Management**: Advanced garbage collection and memory pressure handling\r\n\r\n**Crash Recovery**: If a renderer crashes, only affected tabs show error pages while other content continues working normally.\r\n\r\n![](../../img/architecture/chromium-process-model.png)\r\n\r\n---\r\n\r\n## 4. GPU Process (Viz Compositor Architecture in v134+)\r\n\r\nThe **GPU Process** has been significantly enhanced in v134+ with the Viz Display Compositor, providing unified, high-performance graphics rendering and compositing for all content types.\r\n\r\n- **Core Responsibilities (Enhanced)**  \r\n  - **Viz Display Compositor**: Unified compositing architecture for all surfaces\r\n  - **Out-of-Process Rasterization (OOP-R)**: Rasterization moved from renderer to GPU process\r\n  - **Hardware Acceleration**: Modern graphics APIs (Vulkan, Metal, D3D12)\r\n  - **Canvas2D Acceleration**: Hardware-accelerated 2D canvas rendering\r\n  - **WebGL/WebGPU Management**: 3D graphics context and resource management\r\n\r\n- **Modern Features (v134+)**  \r\n  - **SkiaRenderer**: Advanced Skia-based rendering backend\r\n  - **Surface Aggregation**: Efficient composition of multiple content sources\r\n  - **HDR Support**: High dynamic range content rendering\r\n  - **Variable Refresh Rate**: Adaptive sync display support\r\n  - **Multi-Display**: Coordinated rendering across multiple screens\r\n\r\n- **Performance Optimizations**  \r\n  - **GPU Memory Management**: Intelligent texture allocation and caching\r\n  - **Damage Tracking**: Precise invalidation of changed regions\r\n  - **Frame Pacing**: Optimized frame timing for smooth animations\r\n  - **Tile-based Rendering**: Efficient large surface management\r\n\r\n- **Security & Stability**  \r\n  - **GPU Sandbox**: Restricted access to system resources\r\n  - **Driver Crash Isolation**: GPU crashes don't affect browser stability\r\n  - **Context Recovery**: Automatic recovery from graphics context loss\r\n\r\n---\r\n\r\n## 5. Modern Service Architecture (v134+ Microservices)\r\n\r\nChromium has evolved to a sophisticated microservice architecture with specialized processes for enhanced security, performance, and maintainability:\r\n\r\n| Process Type | Examples | Purpose & Benefits (v134+) |\r\n| --- | --- | --- |\r\n| **Network Service** | DNS resolution, HTTP/3, QUIC stack, certificate validation | Enhanced security isolation, easier updates, cross-platform consistency |\r\n| **Audio Service** | Audio decoding, playback, WebAudio processing | Prevents audio driver issues from affecting other processes |\r\n| **Video Decode Service** | Hardware video acceleration, codec management | Dedicated video processing with hardware acceleration |\r\n| **Storage Service** | IndexedDB, localStorage, cache management | Centralized storage with better security and performance |\r\n| **Device Service** | USB, Bluetooth, serial port access | Secure hardware access with permission management |\r\n| **Printing Service** | Print preview, PDF generation, cloud printing | Isolated printing functionality with enhanced security |\r\n| **PDF Service** | PDF rendering, annotation, form handling | Secure PDF processing separate from renderer |\r\n| **ML Service** | On-device machine learning, TensorFlow Lite | Privacy-preserving ML processing |\r\n| **Utility Processes** | File compression, image decoding, data validation | Sandboxed processing for untrusted data |\r\n\r\n### Modern Service Features (v134+)\r\n- **Service Manager**: Central coordination of all services with dependency management\r\n- **Capability-based Security**: Fine-grained permission system for service access\r\n- **Automatic Recovery**: Services can restart independently without affecting the browser\r\n- **Resource Management**: Intelligent memory and CPU allocation across services\r\n- **Cross-Platform Consistency**: Unified service interface across all supported platforms\r\n\r\n---\r\n\r\n## 6. Advanced Inter-Process Communication (Mojo v134+)\r\n\r\nChromium uses **Mojo IPC**, a sophisticated message-passing framework that has been significantly enhanced for modern multi-process architecture.\r\n\r\n### Core Mojo Features (v134+)\r\n- **Type-Safe Interfaces**: Strongly-typed IDL-based service definitions\r\n- **Capability-Based Security**: Fine-grained permission system for service access\r\n- **Shared Memory**: Efficient large data transfer without copying\r\n- **Associated Interfaces**: Ordered message delivery within interface groups\r\n- **Urgent Messages**: Priority message handling for time-critical operations\r\n\r\n### Communication Patterns\r\n- **Service Interfaces**: Structured RPC-style service definitions with versioning\r\n- **Event Broadcasting**: Efficient multicast for system-wide notifications\r\n- **Stream Processing**: High-throughput data streaming for media and large files\r\n- **Synchronous Calls**: Blocking operations for critical coordination (used sparingly)\r\n\r\n### Modern IPC Optimizations\r\n- **Message Coalescing**: Batching related messages for better performance\r\n- **Zero-Copy Transfers**: Direct memory sharing for large payloads\r\n- **Priority Scheduling**: Critical path message prioritization\r\n- **Connection Pooling**: Efficient reuse of communication channels\r\n- **Dead Process Detection**: Rapid detection and cleanup of crashed processes\r\n\r\n### Security Features\r\n- **Interface Filtering**: Process-specific interface access control\r\n- **Message Validation**: Automatic validation of all incoming messages\r\n- **Capability Delegation**: Secure forwarding of permissions between processes\r\n- **Audit Logging**: Comprehensive IPC activity tracking for security analysis\r\n\r\n**Key Advantage**: Mojo provides type safety, versioning, and security while maintaining high performance across Chromium's complex process hierarchy.\r\n\r\n---\r\n\r\n## 7. Modern Process Lifecycle (v134+ Enhancements)\r\n\r\n### Process Launch & Initialization\r\n1. **Intelligent Process Creation**  \r\n   - **Process Reuse**: Efficient reuse of existing processes when possible\r\n   - **Preemptive Launch**: Speculative process creation for better performance\r\n   - **Resource-Aware Spawning**: Dynamic process allocation based on system resources\r\n\r\n2. **Enhanced Initialization**  \r\n   - **Fast Startup**: Optimized initialization paths with reduced overhead\r\n   - **Service Discovery**: Automatic discovery and connection to required services\r\n   - **Sandbox Setup**: Advanced platform-specific security restrictions\r\n   - **Capability Registration**: Registration of process-specific capabilities and permissions\r\n\r\n### Process Management\r\n3. **Runtime Operations**  \r\n   - **Task Scheduling**: Priority-based task allocation across processes\r\n   - **Memory Pressure Handling**: Intelligent response to system memory constraints\r\n   - **Performance Monitoring**: Real-time process health and performance tracking\r\n   - **Dynamic Resource Allocation**: Adaptive resource management based on workload\r\n\r\n4. **Process Coordination**  \r\n   - **Service Dependencies**: Automatic management of inter-service dependencies\r\n   - **Load Balancing**: Intelligent distribution of work across available processes\r\n   - **Migration Support**: Ability to move work between processes for optimization\r\n\r\n### Advanced Shutdown & Recovery\r\n5. **Graceful Termination**  \r\n   - **Clean Resource Release**: Proper cleanup of GPU contexts, file handles, and memory\r\n   - **State Preservation**: Saving critical state before process termination\r\n   - **Dependency Notification**: Informing dependent processes of shutdown\r\n\r\n6. **Crash Handling & Recovery (v134+)**  \r\n   - **Crashpad Integration**: Advanced crash reporting with detailed stack traces\r\n   - **Automatic Recovery**: Intelligent restart of crashed services\r\n   - **State Restoration**: Recovery of user state after process crashes\r\n   - **Diagnostic Information**: Enhanced crash analytics for debugging and telemetry\r\n\r\n---\r\n\r\n## 8. Advanced Sandboxing & Security (v134+ Enhancements)\r\n\r\nChromium employs sophisticated, platform-specific sandboxes to provide multi-layered security protection:\r\n\r\n### Platform-Specific Sandboxing\r\n- **Windows (v134+)**: \r\n  - **Job Objects**: Process resource and access restrictions\r\n  - **Win32k Lockdown**: Restricted access to legacy Windows APIs\r\n  - **App Container**: Enhanced isolation for renderer processes\r\n  - **Code Integrity Guard (CIG)**: Prevent code injection attacks\r\n\r\n- **Linux (v134+)**: \r\n  - **Namespaces**: Process, network, and filesystem isolation\r\n  - **seccomp-bpf**: System call filtering and restriction\r\n  - **User Namespaces**: Privilege isolation without setuid\r\n  - **Landlock**: Path-based access control for filesystem\r\n\r\n- **macOS (v134+)**: \r\n  - **Seatbelt Profiles**: Granular system access restrictions\r\n  - **System Integrity Protection**: Enhanced system-level protection\r\n  - **Hardened Runtime**: Advanced code signing and runtime protections\r\n  - **App Sandbox**: Additional container-based isolation\r\n\r\n### Advanced Security Features (v134+)\r\n- **Site Isolation Enhancement**: \r\n  - **Cross-Origin Isolation**: Spectre/Meltdown attack prevention\r\n  - **COOP/COEP**: Cross-Origin Opener/Embedder Policy enforcement\r\n  - **Origin Agent Clusters**: Fine-grained process boundaries\r\n\r\n- **Memory Protection**: \r\n  - **Control Flow Integrity (CFI)**: Comprehensive indirect call protection\r\n  - **Stack Canaries**: Buffer overflow detection\r\n  - **Heap Isolation**: Separate heap spaces for different data types\r\n  - **Use-After-Free Detection**: Runtime memory safety validation\r\n\r\n- **Capability-Based Security**: \r\n  - **Service Permissions**: Fine-grained access control for system services\r\n  - **Resource Quotas**: Limits on CPU, memory, and network usage\r\n  - **Dynamic Privilege Adjustment**: Runtime security policy modification\r\n\r\n### Compiler-Level Protections\r\n- **Modern Exploit Mitigations**: \r\n  - **Address Space Layout Randomization (ASLR)**: Enhanced memory layout randomization\r\n  - **Stack Protection**: Comprehensive stack corruption prevention\r\n  - **FORTIFY_SOURCE**: Enhanced runtime bounds checking\r\n  - **-fstack-clash-protection**: Stack clash attack prevention\r\n  - **Retpoline**: Speculative execution attack mitigation\r\n\r\n### Security Monitoring & Response\r\n- **Runtime Security**: \r\n  - **Anomaly Detection**: Behavioral analysis for threat detection\r\n  - **Security Telemetry**: Comprehensive security event logging\r\n  - **Automatic Threat Response**: Dynamic security policy adjustment\r\n  - **Crash Analysis**: Advanced post-mortem security analysis\r\n\r\n---\r\n\r\n## 9. Process Architecture Visualization\r\n\r\nThe following diagrams illustrate Chromium's modern multi-process architecture with service-based design:\r\n\r\n![](../../img/architecture/multiprocess-architecture-detailed.png)\r\n\r\n![](../../img/architecture/multiprocess-architecture-simplified.png)\r\n\r\n---\r\n\r\n## 10. Debugging & Performance Analysis (v134+)\r\n\r\n### Process Monitoring Tools\r\n- **Chrome Task Manager**: `Shift+Esc` - Real-time process resource usage\r\n- **chrome://process-internals/**: Detailed process information and IPC statistics\r\n- **chrome://memory-internals/**: Memory usage breakdown by process type\r\n- **chrome://system/**: Comprehensive system and process information\r\n\r\n### Command Line Debugging\r\n```bash\r\n# Process debugging flags\r\n--enable-logging=stderr             # Detailed process logging\r\n--vmodule=\"*process*=2\"            # Verbose process-related logging\r\n--disable-features=VizDisplayCompositor  # Disable GPU process compositor\r\n--single-process                   # Run in single-process mode (debug only)\r\n--no-sandbox                       # Disable sandboxing (debug builds only)\r\n\r\n# IPC and service debugging\r\n--mojo-core-library-path=path      # Use custom Mojo library\r\n--enable-service-manager-tracing   # Trace service manager operations\r\n--trace-to-console                 # Output trace events to console\r\n```\r\n\r\n### Performance Analysis\r\n- **chrome://tracing/**: Advanced process timeline analysis with IPC visualization\r\n- **DevTools → Performance**: Process-aware performance profiling\r\n- **chrome://histograms/**: Process-specific performance metrics\r\n- **chrome://discards/**: Tab lifecycle and memory pressure information\r\n\r\n---\r\n\r\n## 11. Next Steps & Modern Architecture\r\n\r\n### Essential Reading\r\n- **[Render Pipeline](render-pipeline.md)**: How processes coordinate for frame construction\r\n- **[IPC Internals](ipc-internals.md)**: Deep dive into Mojo communication patterns\r\n- **[Security Model](../security/security-model.md)**: Advanced sandboxing and exploit mitigation\r\n\r\n### Modern Development Topics (v134+)\r\n- **Service-Oriented Architecture**: Understanding Chromium's microservice design\r\n- **Site Isolation**: Implementation details and security implications\r\n- **Viz Compositor**: GPU process architecture and performance optimization\r\n- **Memory Management**: Advanced techniques for multi-process memory efficiency\r\n\r\n### Experimental Features\r\n- **Fuchsia Support**: Next-generation OS integration\r\n- **WebAssembly System Interface (WASI)**: Secure system access for WebAssembly\r\n- **Privacy Sandbox**: Enhanced privacy through process isolation\r\n\r\n### Performance Optimization\r\n```bash\r\n# Monitor process performance\r\nchrome://tracing/ with \"Process\" and \"IPC\" categories\r\n\r\n# Analyze memory usage\r\nchrome://memory-internals/ → Process breakdown\r\n\r\n# Profile service interactions\r\nDevTools → Performance → Main thread and GPU process analysis\r\n\r\n# Test site isolation effectiveness\r\nchrome://site-engagement/ → Origin-based process allocation\r\n```\r\n\r\n---\r\n\r\n**End of Modern Process Model Guide**\r\n\r\n### Key Evolution in v134+\r\n- **Enhanced Site Isolation**: Stronger cross-origin protection with Origin Agent Clusters\r\n- **Service Architecture**: Microservice-based design with intelligent coordination\r\n- **Advanced Security**: Hardware-assisted exploit mitigation and capability-based access\r\n- **Performance Optimization**: Intelligent process management and resource allocation\r\n- **Modern IPC**: Type-safe Mojo interfaces with advanced security features\r\n\r\n**Notes for Developers:**\r\n- Process boundaries are security boundaries - design accordingly\r\n- Use Chrome internal pages for debugging multi-process issues\r\n- Monitor memory usage across processes, not just individual tabs\r\n- Leverage site isolation for enhanced security in web applications\r\n"
  },
  {
    "path": "architecture/overview",
    "title": "Chromium Architecture Overview (v134+)",
    "content": "# Chromium Architecture Overview (v134+)\r\n\r\nModern Chromium v134+ represents the pinnacle of browser architectural engineering, embodying decades of evolution in software design principles, security engineering, and performance optimization. This comprehensive overview explores the sophisticated architectural foundations that make Chromium one of the most advanced software systems ever built.\r\n\r\n---\r\n\r\n## 1. Architectural Philosophy & Design Principles\r\n\r\n### Core Design Philosophy\r\nChromium v134+ is built upon a foundation of **Zero-Trust Architecture**, **Service-Oriented Design**, and **Defense in Depth** security principles. The architecture prioritizes user safety, performance excellence, and developer productivity while maintaining the flexibility to adapt to emerging web technologies and security threats.\r\n\r\n### Fundamental Design Principles\r\n\r\n#### SOLID Principles in Modern Practice\r\n```cpp\r\n// Single Responsibility Principle - Enhanced with Service Boundaries\r\nclass SecurityPolicyManager {\r\n public:\r\n  // Single responsibility: Manage security policies only\r\n  void ApplyPolicy(const SecurityPolicy& policy) {\r\n    if (!ValidatePolicy(policy)) {\r\n      LOG(ERROR) << \"Invalid security policy: \" << policy.name();\r\n      return;\r\n    }\r\n    active_policies_[policy.name()] = policy;\r\n    NotifyPolicyChange(policy);\r\n  }\r\n\r\n private:\r\n  bool ValidatePolicy(const SecurityPolicy& policy) const;\r\n  void NotifyPolicyChange(const SecurityPolicy& policy);\r\n  \r\n  std::unordered_map<std::string, SecurityPolicy> active_policies_;\r\n  PolicyChangeNotifier notifier_;\r\n};\r\n\r\n// Open/Closed Principle - Extensible through interfaces\r\nclass WebAPIInterface {\r\n public:\r\n  virtual ~WebAPIInterface() = default;\r\n  virtual void Initialize(const APIConfig& config) = 0;\r\n  virtual bool IsSupported() const = 0;\r\n  virtual void ProcessRequest(const APIRequest& request, \r\n                             APICallback callback) = 0;\r\n};\r\n\r\n// WebGPU implementation extending the interface\r\nclass WebGPUAPI : public WebAPIInterface {\r\n public:\r\n  void Initialize(const APIConfig& config) override {\r\n    gpu_context_ = GPUContextFactory::Create(config);\r\n    compute_pipeline_ = CreateComputePipeline();\r\n  }\r\n\r\n  bool IsSupported() const override {\r\n    return gpu_context_ && gpu_context_->SupportsWebGPU();\r\n  }\r\n\r\n  void ProcessRequest(const APIRequest& request, \r\n                     APICallback callback) override {\r\n    if (!IsSupported()) {\r\n      callback.Run(APIResponse::CreateError(\"WebGPU not supported\"));\r\n      return;\r\n    }\r\n    \r\n    auto response = ProcessWebGPURequest(request);\r\n    callback.Run(std::move(response));\r\n  }\r\n\r\n private:\r\n  std::unique_ptr<GPUContext> gpu_context_;\r\n  std::unique_ptr<ComputePipeline> compute_pipeline_;\r\n};\r\n```\r\n\r\n#### Dependency Inversion & Interface Segregation\r\n```cpp\r\n// Interface segregation - Specific interfaces for different needs\r\nclass NetworkServiceInterface {\r\n public:\r\n  virtual ~NetworkServiceInterface() = default;\r\n  virtual void SendRequest(const NetworkRequest& request,\r\n                          NetworkCallback callback) = 0;\r\n};\r\n\r\nclass SecurityServiceInterface {\r\n public:\r\n  virtual ~SecurityServiceInterface() = default;\r\n  virtual bool ValidateOrigin(const url::Origin& origin) = 0;\r\n  virtual void ApplySecurityHeaders(NetworkResponse* response) = 0;\r\n};\r\n\r\n// Dependency inversion - High-level modules depend on abstractions\r\nclass SecureNetworkManager {\r\n public:\r\n  SecureNetworkManager(\r\n      std::unique_ptr<NetworkServiceInterface> network_service,\r\n      std::unique_ptr<SecurityServiceInterface> security_service)\r\n      : network_service_(std::move(network_service)),\r\n        security_service_(std::move(security_service)) {}\r\n\r\n  void MakeSecureRequest(const SecureNetworkRequest& request,\r\n                        SecureNetworkCallback callback) {\r\n    // Validate security constraints first\r\n    if (!security_service_->ValidateOrigin(request.origin())) {\r\n      callback.Run(SecureNetworkResponse::CreateSecurityError());\r\n      return;\r\n    }\r\n\r\n    // Make network request with security validation\r\n    network_service_->SendRequest(\r\n        request.ToNetworkRequest(),\r\n        base::BindOnce(&SecureNetworkManager::OnNetworkResponse,\r\n                      weak_factory_.GetWeakPtr(),\r\n                      std::move(callback)));\r\n  }\r\n\r\n private:\r\n  void OnNetworkResponse(SecureNetworkCallback callback,\r\n                        NetworkResponse response) {\r\n    // Apply additional security processing\r\n    security_service_->ApplySecurityHeaders(&response);\r\n    callback.Run(SecureNetworkResponse::FromNetworkResponse(response));\r\n  }\r\n\r\n  std::unique_ptr<NetworkServiceInterface> network_service_;\r\n  std::unique_ptr<SecurityServiceInterface> security_service_;\r\n  base::WeakPtrFactory<SecureNetworkManager> weak_factory_{this};\r\n};\r\n```\r\n\r\n---\r\n\r\n## 2. Advanced Architectural Patterns\r\n\r\n### Service-Oriented Architecture (SOA) with Mojo IPC\r\nChromium v134+ implements a sophisticated service-oriented architecture that goes beyond traditional microservices:\r\n\r\n#### Service Definition and Registration\r\n```cpp\r\n// Modern service definition with capability-based security\r\nclass PrivacySandboxService : public service_manager::Service {\r\n public:\r\n  PrivacySandboxService() = default;\r\n  ~PrivacySandboxService() override = default;\r\n\r\n  // Service lifecycle management\r\n  void OnStart() override {\r\n    // Initialize privacy-preserving components\r\n    topics_api_ = std::make_unique<TopicsAPI>(GetPrivacyBudget());\r\n    fledge_api_ = std::make_unique<FLEDGEAPI>(GetAuctionConfig());\r\n    attribution_api_ = std::make_unique<AttributionAPI>(GetReportingConfig());\r\n    \r\n    // Register capability-based interfaces\r\n    registry_.AddInterface(\r\n        base::BindRepeating(&PrivacySandboxService::CreateTopicsBinding,\r\n                           base::Unretained(this)));\r\n    registry_.AddInterface(\r\n        base::BindRepeating(&PrivacySandboxService::CreateFLEDGEBinding,\r\n                           base::Unretained(this)));\r\n  }\r\n\r\n  void OnBindInterface(const service_manager::BindSourceInfo& source_info,\r\n                      const std::string& interface_name,\r\n                      mojo::ScopedMessagePipeHandle interface_pipe) override {\r\n    // Validate capability before binding\r\n    if (!ValidateServiceCapability(source_info, interface_name)) {\r\n      LOG(ERROR) << \"Service capability validation failed for: \" \r\n                 << interface_name;\r\n      return;\r\n    }\r\n    \r\n    registry_.BindInterface(interface_name, std::move(interface_pipe));\r\n  }\r\n\r\n private:\r\n  void CreateTopicsBinding(\r\n      privacy_sandbox::mojom::TopicsAPIRequest request) {\r\n    topics_bindings_.AddBinding(topics_api_.get(), std::move(request));\r\n  }\r\n\r\n  void CreateFLEDGEBinding(\r\n      privacy_sandbox::mojom::FLEDGEAPIRequest request) {\r\n    fledge_bindings_.AddBinding(fledge_api_.get(), std::move(request));\r\n  }\r\n\r\n  bool ValidateServiceCapability(const service_manager::BindSourceInfo& source,\r\n                                const std::string& interface_name) {\r\n    return capability_manager_.HasCapability(source.identity, interface_name);\r\n  }\r\n\r\n  service_manager::BinderRegistry registry_;\r\n  CapabilityManager capability_manager_;\r\n  \r\n  std::unique_ptr<TopicsAPI> topics_api_;\r\n  std::unique_ptr<FLEDGEAPI> fledge_api_;\r\n  std::unique_ptr<AttributionAPI> attribution_api_;\r\n  \r\n  mojo::BindingSet<privacy_sandbox::mojom::TopicsAPI> topics_bindings_;\r\n  mojo::BindingSet<privacy_sandbox::mojom::FLEDGEAPI> fledge_bindings_;\r\n};\r\n```\r\n\r\n#### Advanced Inter-Process Communication\r\n```cpp\r\n// Type-safe Mojo interface with security validation\r\ninterface PrivacySandboxManager {\r\n  // Topics API with differential privacy\r\n  GetTopics(TopicsRequest request) => (TopicsResponse response);\r\n  \r\n  // FLEDGE auction with enhanced security\r\n  RunAuction(AuctionConfig config) => (AuctionResult result);\r\n  \r\n  // Attribution reporting with privacy preservation\r\n  RecordAttribution(AttributionData data) => (AttributionResult result);\r\n  \r\n  // Privacy budget management\r\n  CheckPrivacyBudget(PrivacyBudgetRequest request) => \r\n      (PrivacyBudgetResponse response);\r\n};\r\n\r\n// Implementation with security-first design\r\nclass PrivacySandboxManagerImpl \r\n    : public privacy_sandbox::mojom::PrivacySandboxManager {\r\n public:\r\n  void GetTopics(privacy_sandbox::mojom::TopicsRequestPtr request,\r\n                GetTopicsCallback callback) override {\r\n    // Validate request origin and privacy budget\r\n    if (!ValidateTopicsRequest(*request)) {\r\n      std::move(callback).Run(\r\n          privacy_sandbox::mojom::TopicsResponse::NewError(\r\n              \"Invalid topics request\"));\r\n      return;\r\n    }\r\n\r\n    // Apply differential privacy\r\n    auto topics = topics_calculator_->CalculateTopics(\r\n        request->origin, request->time_range);\r\n    \r\n    auto response = privacy_sandbox::mojom::TopicsResponse::New();\r\n    response->topics = std::move(topics);\r\n    response->privacy_budget_consumed = CalculatePrivacyBudgetUsed(*request);\r\n    \r\n    std::move(callback).Run(std::move(response));\r\n  }\r\n\r\n private:\r\n  bool ValidateTopicsRequest(\r\n      const privacy_sandbox::mojom::TopicsRequest& request) {\r\n    return origin_validator_->IsValidOrigin(request.origin) &&\r\n           privacy_budget_manager_->HasSufficientBudget(\r\n               request.origin, request.privacy_budget_required);\r\n  }\r\n\r\n  std::unique_ptr<TopicsCalculator> topics_calculator_;\r\n  std::unique_ptr<OriginValidator> origin_validator_;\r\n  std::unique_ptr<PrivacyBudgetManager> privacy_budget_manager_;\r\n};\r\n```\r\n\r\n### Modern Component Architecture\r\n```cpp\r\n// Component-based architecture with dependency injection\r\nclass ComponentRegistry {\r\n public:\r\n  template<typename ComponentType, typename... Args>\r\n  void RegisterComponent(Args&&... args) {\r\n    static_assert(std::is_base_of_v<Component, ComponentType>);\r\n    \r\n    auto component = std::make_unique<ComponentType>(\r\n        std::forward<Args>(args)...);\r\n    \r\n    const std::string component_name = ComponentType::GetName();\r\n    \r\n    // Validate component dependencies\r\n    if (!ValidateComponentDependencies<ComponentType>()) {\r\n      LOG(ERROR) << \"Component dependencies not satisfied: \" \r\n                 << component_name;\r\n      return;\r\n    }\r\n    \r\n    // Initialize component with dependency injection\r\n    component->Initialize(CreateDependencyProvider<ComponentType>());\r\n    \r\n    components_[component_name] = std::move(component);\r\n    \r\n    LOG(INFO) << \"Component registered successfully: \" << component_name;\r\n  }\r\n\r\n  template<typename ComponentType>\r\n  ComponentType* GetComponent() {\r\n    const std::string component_name = ComponentType::GetName();\r\n    auto it = components_.find(component_name);\r\n    \r\n    if (it == components_.end()) {\r\n      return nullptr;\r\n    }\r\n    \r\n    return static_cast<ComponentType*>(it->second.get());\r\n  }\r\n\r\n private:\r\n  template<typename ComponentType>\r\n  bool ValidateComponentDependencies() {\r\n    for (const auto& dependency_name : ComponentType::GetDependencies()) {\r\n      if (components_.find(dependency_name) == components_.end()) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  template<typename ComponentType>\r\n  std::unique_ptr<DependencyProvider> CreateDependencyProvider() {\r\n    auto provider = std::make_unique<DependencyProvider>();\r\n    \r\n    for (const auto& dependency_name : ComponentType::GetDependencies()) {\r\n      auto dependency_it = components_.find(dependency_name);\r\n      if (dependency_it != components_.end()) {\r\n        provider->AddDependency(dependency_name, dependency_it->second.get());\r\n      }\r\n    }\r\n    \r\n    return provider;\r\n  }\r\n\r\n  std::unordered_map<std::string, std::unique_ptr<Component>> components_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 3. Multi-Process Architecture Excellence\r\n\r\n### Process Isolation and Security Boundaries\r\n```cpp\r\n// Enhanced process model with security-first design\r\nclass ProcessManager {\r\n public:\r\n  enum class ProcessType {\r\n    kBrowser,           // Main coordinator process\r\n    kRenderer,          // Site-isolated content rendering\r\n    kGPU,              // Graphics and compute acceleration\r\n    kNetwork,          // Network request processing\r\n    kStorage,          // Data persistence and caching\r\n    kAudio,            // Audio processing and effects\r\n    kUtility,          // Sandboxed utility processes\r\n    kML,               // Machine learning inference\r\n    kSecurity          // Security monitoring and analysis\r\n  };\r\n\r\n  struct ProcessSecurityConfig {\r\n    // Sandbox configuration\r\n    SandboxType sandbox_type = SandboxType::kStrictSandbox;\r\n    \r\n    // Capability restrictions\r\n    std::set<std::string> allowed_capabilities;\r\n    \r\n    // Memory protection\r\n    bool enable_cfi = true;\r\n    bool enable_memory_tagging = true;\r\n    bool enable_pointer_authentication = true;\r\n    \r\n    // Network restrictions\r\n    NetworkAccessPolicy network_policy = NetworkAccessPolicy::kDenied;\r\n    \r\n    // File system access\r\n    FileSystemAccessPolicy file_access = FileSystemAccessPolicy::kRestricted;\r\n  };\r\n\r\n  base::Process CreateSecureProcess(ProcessType type,\r\n                                   const ProcessSecurityConfig& config) {\r\n    // Create process with enhanced security\r\n    auto process_launcher = CreateProcessLauncher(type, config);\r\n    \r\n    // Apply sandbox restrictions\r\n    ApplySandboxRestrictions(process_launcher.get(), config);\r\n    \r\n    // Setup IPC channels with capability validation\r\n    auto ipc_channel = CreateSecureIPCChannel(type, config);\r\n    \r\n    // Launch process with security monitoring\r\n    auto process = process_launcher->LaunchProcess();\r\n    \r\n    if (process.IsValid()) {\r\n      RegisterProcessForMonitoring(process.Pid(), type, config);\r\n    }\r\n    \r\n    return process;\r\n  }\r\n\r\n private:\r\n  void ApplySandboxRestrictions(ProcessLauncher* launcher,\r\n                               const ProcessSecurityConfig& config) {\r\n    // Configure sandbox based on process requirements\r\n    auto sandbox_config = CreateSandboxConfig(config);\r\n    launcher->SetSandboxConfiguration(std::move(sandbox_config));\r\n    \r\n    // Apply capability restrictions\r\n    launcher->SetCapabilityRestrictions(config.allowed_capabilities);\r\n    \r\n    // Enable hardware security features\r\n    if (config.enable_cfi) {\r\n      launcher->EnableControlFlowIntegrity();\r\n    }\r\n    \r\n    if (config.enable_memory_tagging) {\r\n      launcher->EnableMemoryTagging();\r\n    }\r\n  }\r\n\r\n  void RegisterProcessForMonitoring(base::ProcessId pid,\r\n                                   ProcessType type,\r\n                                   const ProcessSecurityConfig& config) {\r\n    process_monitor_.RegisterProcess(pid, type, config);\r\n    \r\n    // Setup security event monitoring\r\n    security_monitor_.MonitorProcess(pid, \r\n        base::BindRepeating(&ProcessManager::OnSecurityEvent,\r\n                           base::Unretained(this), pid));\r\n  }\r\n\r\n  void OnSecurityEvent(base::ProcessId pid, const SecurityEvent& event) {\r\n    LOG(WARNING) << \"Security event detected in process \" << pid \r\n                 << \": \" << event.description();\r\n    \r\n    // Take appropriate action based on event severity\r\n    if (event.severity() >= SecurityEventSeverity::kCritical) {\r\n      TerminateProcess(pid, \"Critical security violation\");\r\n    }\r\n  }\r\n\r\n  ProcessMonitor process_monitor_;\r\n  SecurityMonitor security_monitor_;\r\n};\r\n```\r\n\r\n### Site Isolation and Origin-Based Security\r\n```cpp\r\n// Advanced site isolation with enhanced security boundaries\r\nclass SiteIsolationManager {\r\n public:\r\n  struct IsolationPolicy {\r\n    // Origin-based isolation rules\r\n    std::set<url::Origin> high_risk_origins;\r\n    std::set<url::Origin> trusted_origins;\r\n    \r\n    // Cross-origin policy enforcement\r\n    bool enforce_corp = true;              // Cross-Origin Resource Policy\r\n    bool enforce_coep = true;              // Cross-Origin Embedder Policy\r\n    bool enforce_coop = true;              // Cross-Origin Opener Policy\r\n    \r\n    // Enhanced security features\r\n    bool enable_origin_agent_clusters = true;\r\n    bool enable_cross_origin_isolation = true;\r\n    bool enable_shared_array_buffer_isolation = true;\r\n  };\r\n\r\n  bool ShouldIsolateOrigin(const url::Origin& origin,\r\n                          const IsolationPolicy& policy) {\r\n    // Always isolate high-risk origins\r\n    if (policy.high_risk_origins.contains(origin)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for special isolation requirements\r\n    if (RequiresSpecialIsolation(origin)) {\r\n      return true;\r\n    }\r\n    \r\n    // Apply ML-based risk assessment\r\n    if (security_classifier_.IsHighRiskOrigin(origin)) {\r\n      return true;\r\n    }\r\n    \r\n    // Check for cross-origin isolation requirements\r\n    if (policy.enable_cross_origin_isolation && \r\n        RequiresCrossOriginIsolation(origin)) {\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }\r\n\r\n  void EnforceOriginPolicy(RenderFrameHost* frame,\r\n                          const url::Origin& origin,\r\n                          const IsolationPolicy& policy) {\r\n    // Apply Cross-Origin Resource Policy\r\n    if (policy.enforce_corp) {\r\n      frame->SetCrossOriginResourcePolicy(GetCORPPolicy(origin));\r\n    }\r\n    \r\n    // Apply Cross-Origin Embedder Policy\r\n    if (policy.enforce_coep) {\r\n      frame->SetCrossOriginEmbedderPolicy(GetCOEPPolicy(origin));\r\n    }\r\n    \r\n    // Apply Cross-Origin Opener Policy\r\n    if (policy.enforce_coop) {\r\n      frame->SetCrossOriginOpenerPolicy(GetCOOPPolicy(origin));\r\n    }\r\n    \r\n    // Setup origin agent clusters\r\n    if (policy.enable_origin_agent_clusters) {\r\n      frame->EnableOriginAgentClusters();\r\n    }\r\n  }\r\n\r\n private:\r\n  bool RequiresSpecialIsolation(const url::Origin& origin) {\r\n    // Check for origins that require special handling\r\n    return origin.scheme() == \"chrome-extension\" ||\r\n           origin.scheme() == \"chrome-native\" ||\r\n           IsKnownSensitiveOrigin(origin);\r\n  }\r\n\r\n  bool RequiresCrossOriginIsolation(const url::Origin& origin) {\r\n    // Check if origin uses features requiring cross-origin isolation\r\n    return UsesSharedArrayBuffer(origin) ||\r\n           UsesWASMThreads(origin) ||\r\n           UsesHighResolutionTimer(origin);\r\n  }\r\n\r\n  SecurityClassifier security_classifier_;\r\n  OriginPolicyDatabase origin_policy_db_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 4. Performance Architecture & Optimization\r\n\r\n### Advanced Performance Monitoring\r\n```cpp\r\n// Comprehensive performance tracking with ML-based optimization\r\nclass PerformanceArchitecture {\r\n public:\r\n  struct PerformanceMetrics {\r\n    // Core Web Vitals with enhanced precision\r\n    base::TimeDelta largest_contentful_paint;\r\n    base::TimeDelta interaction_to_next_paint;\r\n    double cumulative_layout_shift;\r\n    \r\n    // Advanced rendering metrics\r\n    base::TimeDelta first_contentful_paint;\r\n    base::TimeDelta time_to_interactive;\r\n    double frame_rate;\r\n    double frame_consistency;\r\n    \r\n    // Resource loading metrics\r\n    base::TimeDelta dns_lookup_time;\r\n    base::TimeDelta tcp_connection_time;\r\n    base::TimeDelta ssl_handshake_time;\r\n    base::TimeDelta resource_download_time;\r\n    \r\n    // JavaScript execution metrics\r\n    base::TimeDelta script_parse_time;\r\n    base::TimeDelta script_execution_time;\r\n    double heap_usage_percentage;\r\n    \r\n    // Memory metrics\r\n    size_t total_memory_usage;\r\n    size_t peak_memory_usage;\r\n    double memory_fragmentation_ratio;\r\n  };\r\n\r\n  class PerformanceOptimizer {\r\n   public:\r\n    void OptimizeBasedOnMetrics(const PerformanceMetrics& metrics,\r\n                               const GURL& url) {\r\n      // Analyze performance bottlenecks\r\n      auto bottlenecks = AnalyzeBottlenecks(metrics);\r\n      \r\n      // Apply targeted optimizations\r\n      for (const auto& bottleneck : bottlenecks) {\r\n        ApplyOptimization(bottleneck, url);\r\n      }\r\n      \r\n      // Update ML model with performance data\r\n      performance_model_.UpdateModel(metrics, url);\r\n    }\r\n\r\n   private:\r\n    enum class PerformanceBottleneck {\r\n      kLargeContentfulPaint,\r\n      kLayoutInstability,\r\n      kSlowInteraction,\r\n      kResourceLoading,\r\n      kJavaScriptExecution,\r\n      kMemoryPressure\r\n    };\r\n\r\n    std::vector<PerformanceBottleneck> AnalyzeBottlenecks(\r\n        const PerformanceMetrics& metrics) {\r\n      std::vector<PerformanceBottleneck> bottlenecks;\r\n      \r\n      if (metrics.largest_contentful_paint > kLCPThreshold) {\r\n        bottlenecks.push_back(PerformanceBottleneck::kLargeContentfulPaint);\r\n      }\r\n      \r\n      if (metrics.cumulative_layout_shift > kCLSThreshold) {\r\n        bottlenecks.push_back(PerformanceBottleneck::kLayoutInstability);\r\n      }\r\n      \r\n      if (metrics.interaction_to_next_paint > kINPThreshold) {\r\n        bottlenecks.push_back(PerformanceBottleneck::kSlowInteraction);\r\n      }\r\n      \r\n      if (metrics.memory_fragmentation_ratio > kMemoryFragmentationThreshold) {\r\n        bottlenecks.push_back(PerformanceBottleneck::kMemoryPressure);\r\n      }\r\n      \r\n      return bottlenecks;\r\n    }\r\n\r\n    void ApplyOptimization(PerformanceBottleneck bottleneck, const GURL& url) {\r\n      switch (bottleneck) {\r\n        case PerformanceBottleneck::kLargeContentfulPaint:\r\n          EnablePreloadOptimizations(url);\r\n          break;\r\n        case PerformanceBottleneck::kLayoutInstability:\r\n          EnableLayoutStabilization(url);\r\n          break;\r\n        case PerformanceBottleneck::kSlowInteraction:\r\n          EnableInteractionOptimizations(url);\r\n          break;\r\n        case PerformanceBottleneck::kMemoryPressure:\r\n          TriggerMemoryOptimization();\r\n          break;\r\n      }\r\n    }\r\n\r\n    PerformanceMLModel performance_model_;\r\n  };\r\n};\r\n```\r\n\r\n### Memory Architecture and Optimization\r\n```cpp\r\n// Advanced memory management with predictive optimization\r\nclass MemoryArchitecture {\r\n public:\r\n  class SmartMemoryManager {\r\n   public:\r\n    struct MemoryConfiguration {\r\n      // Memory allocation strategies\r\n      AllocationStrategy strategy = AllocationStrategy::kAdaptive;\r\n      \r\n      // Garbage collection tuning\r\n      GCStrategy gc_strategy = GCStrategy::kPredictive;\r\n      double gc_threshold = 0.8;\r\n      \r\n      // Memory compression\r\n      bool enable_memory_compression = true;\r\n      CompressionLevel compression_level = CompressionLevel::kBalanced;\r\n      \r\n      // Memory mapping optimizations\r\n      bool enable_memory_mapping = true;\r\n      bool enable_large_pages = true;\r\n    };\r\n\r\n    void OptimizeMemoryUsage(const MemoryConfiguration& config) {\r\n      // Apply memory allocation strategy\r\n      ApplyAllocationStrategy(config.strategy);\r\n      \r\n      // Configure garbage collection\r\n      ConfigureGarbageCollection(config.gc_strategy, config.gc_threshold);\r\n      \r\n      // Enable memory compression if beneficial\r\n      if (config.enable_memory_compression && ShouldCompressMemory()) {\r\n        EnableMemoryCompression(config.compression_level);\r\n      }\r\n      \r\n      // Optimize memory mapping\r\n      if (config.enable_memory_mapping) {\r\n        OptimizeMemoryMapping(config.enable_large_pages);\r\n      }\r\n    }\r\n\r\n    void PredictiveMemoryManagement() {\r\n      // Use ML to predict memory usage patterns\r\n      auto prediction = memory_predictor_.PredictMemoryUsage();\r\n      \r\n      // Proactively adjust memory allocation\r\n      if (prediction.peak_usage > GetAvailableMemory() * 0.9) {\r\n        TriggerPreemptiveGarbageCollection();\r\n        CompressInactivePages();\r\n      }\r\n      \r\n      // Preload frequently accessed data\r\n      if (prediction.confidence > 0.8) {\r\n        PreloadPredictedData(prediction.predicted_pages);\r\n      }\r\n    }\r\n\r\n   private:\r\n    void ApplyAllocationStrategy(AllocationStrategy strategy) {\r\n      switch (strategy) {\r\n        case AllocationStrategy::kAdaptive:\r\n          EnableAdaptiveAllocation();\r\n          break;\r\n        case AllocationStrategy::kPooled:\r\n          EnablePooledAllocation();\r\n          break;\r\n        case AllocationStrategy::kRegion:\r\n          EnableRegionBasedAllocation();\r\n          break;\r\n      }\r\n    }\r\n\r\n    bool ShouldCompressMemory() {\r\n      return GetMemoryPressureLevel() >= MemoryPressureLevel::kModerate &&\r\n             GetCompressionBenefit() > kCompressionThreshold;\r\n    }\r\n\r\n    MemoryPredictor memory_predictor_;\r\n    CompressionEngine compression_engine_;\r\n  };\r\n};\r\n```\r\n\r\n---\r\n\r\n## 5. Security Architecture Excellence\r\n\r\n### Zero-Trust Security Model\r\n```cpp\r\n// Zero-trust security implementation with continuous verification\r\nclass ZeroTrustSecurityArchitecture {\r\n public:\r\n  class SecurityVerifier {\r\n   public:\r\n    struct SecurityContext {\r\n      // Identity and authentication\r\n      UserIdentity user_identity;\r\n      DeviceIdentity device_identity;\r\n      ProcessIdentity process_identity;\r\n      \r\n      // Trust level assessment\r\n      TrustLevel current_trust_level = TrustLevel::kUntrusted;\r\n      base::Time last_verification;\r\n      \r\n      // Security state\r\n      std::set<SecurityCapability> granted_capabilities;\r\n      std::vector<SecurityViolation> recent_violations;\r\n      \r\n      // Cryptographic validation\r\n      CryptographicToken access_token;\r\n      base::Time token_expiry;\r\n    };\r\n\r\n    bool VerifySecurityContext(SecurityContext* context) {\r\n      // Continuous verification of all security aspects\r\n      if (!VerifyUserIdentity(context->user_identity)) {\r\n        context->current_trust_level = TrustLevel::kUntrusted;\r\n        return false;\r\n      }\r\n      \r\n      if (!VerifyDeviceIdentity(context->device_identity)) {\r\n        context->current_trust_level = TrustLevel::kUntrusted;\r\n        return false;\r\n      }\r\n      \r\n      if (!VerifyProcessIntegrity(context->process_identity)) {\r\n        context->current_trust_level = TrustLevel::kUntrusted;\r\n        return false;\r\n      }\r\n      \r\n      // Check for recent security violations\r\n      if (HasRecentSecurityViolations(*context)) {\r\n        ReduceTrustLevel(context);\r\n      }\r\n      \r\n      // Verify cryptographic tokens\r\n      if (!VerifyCryptographicToken(context->access_token)) {\r\n        RefreshSecurityToken(context);\r\n      }\r\n      \r\n      // Update verification timestamp\r\n      context->last_verification = base::Time::Now();\r\n      \r\n      return context->current_trust_level >= TrustLevel::kTrusted;\r\n    }\r\n\r\n   private:\r\n    bool VerifyUserIdentity(const UserIdentity& identity) {\r\n      // Multi-factor authentication verification\r\n      return biometric_verifier_.VerifyBiometric(identity) &&\r\n             token_verifier_.VerifySecurityToken(identity) &&\r\n             behavioral_verifier_.VerifyBehavioralPattern(identity);\r\n    }\r\n\r\n    bool VerifyDeviceIdentity(const DeviceIdentity& identity) {\r\n      // Hardware-based device attestation\r\n      return hardware_attestor_.VerifyHardware(identity) &&\r\n             tpm_verifier_.VerifyTPMAttestation(identity) &&\r\n             secure_boot_verifier_.VerifySecureBoot(identity);\r\n    }\r\n\r\n    bool VerifyProcessIntegrity(const ProcessIdentity& identity) {\r\n      // Code signing and integrity verification\r\n      return code_verifier_.VerifyCodeSignature(identity) &&\r\n             memory_verifier_.VerifyMemoryIntegrity(identity) &&\r\n             execution_verifier_.VerifyExecutionIntegrity(identity);\r\n    }\r\n\r\n    BiometricVerifier biometric_verifier_;\r\n    TokenVerifier token_verifier_;\r\n    BehavioralVerifier behavioral_verifier_;\r\n    HardwareAttestor hardware_attestor_;\r\n    TPMVerifier tpm_verifier_;\r\n    SecureBootVerifier secure_boot_verifier_;\r\n    CodeVerifier code_verifier_;\r\n    MemoryVerifier memory_verifier_;\r\n    ExecutionVerifier execution_verifier_;\r\n  };\r\n};\r\n```\r\n\r\n### Advanced Threat Detection and Response\r\n```cpp\r\n// AI-powered threat detection with automated response\r\nclass ThreatDetectionSystem {\r\n public:\r\n  struct ThreatDetectionConfig {\r\n    // Detection sensitivity levels\r\n    ThreatSensitivity sensitivity_level = ThreatSensitivity::kBalanced;\r\n    \r\n    // AI model configuration\r\n    bool enable_ml_detection = true;\r\n    MLModelVersion model_version = MLModelVersion::kLatest;\r\n    \r\n    // Real-time monitoring\r\n    bool enable_behavioral_monitoring = true;\r\n    bool enable_network_monitoring = true;\r\n    bool enable_memory_monitoring = true;\r\n    \r\n    // Response automation\r\n    bool enable_automated_response = true;\r\n    ResponseAggression response_level = ResponseAggression::kModerate;\r\n  };\r\n\r\n  class ThreatDetector {\r\n   public:\r\n    void StartThreatMonitoring(const ThreatDetectionConfig& config) {\r\n      // Initialize AI-powered detection models\r\n      if (config.enable_ml_detection) {\r\n        threat_model_ = LoadThreatDetectionModel(config.model_version);\r\n      }\r\n      \r\n      // Start behavioral monitoring\r\n      if (config.enable_behavioral_monitoring) {\r\n        behavioral_monitor_.StartMonitoring(\r\n            base::BindRepeating(&ThreatDetector::OnBehavioralAnomaly,\r\n                               base::Unretained(this)));\r\n      }\r\n      \r\n      // Start network monitoring\r\n      if (config.enable_network_monitoring) {\r\n        network_monitor_.StartMonitoring(\r\n            base::BindRepeating(&ThreatDetector::OnNetworkAnomaly,\r\n                               base::Unretained(this)));\r\n      }\r\n      \r\n      // Start memory monitoring\r\n      if (config.enable_memory_monitoring) {\r\n        memory_monitor_.StartMonitoring(\r\n            base::BindRepeating(&ThreatDetector::OnMemoryAnomaly,\r\n                               base::Unretained(this)));\r\n      }\r\n    }\r\n\r\n   private:\r\n    void OnBehavioralAnomaly(const BehavioralAnomaly& anomaly) {\r\n      // Analyze threat using ML model\r\n      auto threat_assessment = threat_model_->AssessThreat(anomaly);\r\n      \r\n      if (threat_assessment.confidence > kThreatThreshold) {\r\n        RespondToThreat(ThreatEvent::FromBehavioralAnomaly(anomaly));\r\n      }\r\n    }\r\n\r\n    void OnNetworkAnomaly(const NetworkAnomaly& anomaly) {\r\n      // Check for known attack patterns\r\n      if (IsKnownAttackPattern(anomaly)) {\r\n        RespondToThreat(ThreatEvent::FromNetworkAnomaly(anomaly));\r\n        return;\r\n      }\r\n      \r\n      // Use ML for unknown pattern detection\r\n      auto threat_assessment = threat_model_->AssessNetworkThreat(anomaly);\r\n      \r\n      if (threat_assessment.severity >= ThreatSeverity::kMedium) {\r\n        RespondToThreat(ThreatEvent::FromNetworkAnomaly(anomaly));\r\n      }\r\n    }\r\n\r\n    void RespondToThreat(const ThreatEvent& threat) {\r\n      // Log threat for analysis\r\n      threat_logger_.LogThreat(threat);\r\n      \r\n      // Take automated response actions\r\n      switch (threat.severity()) {\r\n        case ThreatSeverity::kLow:\r\n          IncreasedMonitoring(threat.source());\r\n          break;\r\n        case ThreatSeverity::kMedium:\r\n          IsolateProcess(threat.source());\r\n          break;\r\n        case ThreatSeverity::kHigh:\r\n          TerminateProcess(threat.source());\r\n          NotifySecurityTeam(threat);\r\n          break;\r\n        case ThreatSeverity::kCritical:\r\n          EmergencyShutdown(threat);\r\n          break;\r\n      }\r\n    }\r\n\r\n    std::unique_ptr<ThreatDetectionModel> threat_model_;\r\n    BehavioralMonitor behavioral_monitor_;\r\n    NetworkMonitor network_monitor_;\r\n    MemoryMonitor memory_monitor_;\r\n    ThreatLogger threat_logger_;\r\n  };\r\n};\r\n```\r\n\r\n---\r\n\r\n## 6. Modern Development Architecture\r\n\r\n### Continuous Integration and Quality Assurance\r\n```cpp\r\n// Comprehensive CI/CD pipeline with quality gates\r\nclass DevelopmentArchitecture {\r\n public:\r\n  class QualityGateSystem {\r\n   public:\r\n    struct QualityMetrics {\r\n      // Code quality metrics\r\n      double code_coverage_percentage;\r\n      int cyclomatic_complexity;\r\n      int technical_debt_hours;\r\n      \r\n      // Security metrics\r\n      int security_vulnerabilities;\r\n      int potential_security_issues;\r\n      double security_score;\r\n      \r\n      // Performance metrics\r\n      base::TimeDelta build_time;\r\n      base::TimeDelta test_execution_time;\r\n      double performance_regression_percentage;\r\n      \r\n      // Maintainability metrics\r\n      double maintainability_index;\r\n      int code_duplication_percentage;\r\n      int documentation_coverage;\r\n    };\r\n\r\n    bool PassesQualityGates(const QualityMetrics& metrics) {\r\n      // Code quality gates\r\n      if (metrics.code_coverage_percentage < kMinCodeCoverage) {\r\n        LOG(ERROR) << \"Code coverage below threshold: \" \r\n                   << metrics.code_coverage_percentage << \"%\";\r\n        return false;\r\n      }\r\n      \r\n      if (metrics.cyclomatic_complexity > kMaxCyclomaticComplexity) {\r\n        LOG(ERROR) << \"Cyclomatic complexity too high: \" \r\n                   << metrics.cyclomatic_complexity;\r\n        return false;\r\n      }\r\n      \r\n      // Security gates\r\n      if (metrics.security_vulnerabilities > 0) {\r\n        LOG(ERROR) << \"Security vulnerabilities detected: \" \r\n                   << metrics.security_vulnerabilities;\r\n        return false;\r\n      }\r\n      \r\n      if (metrics.security_score < kMinSecurityScore) {\r\n        LOG(ERROR) << \"Security score below threshold: \" \r\n                   << metrics.security_score;\r\n        return false;\r\n      }\r\n      \r\n      // Performance gates\r\n      if (metrics.performance_regression_percentage > kMaxPerformanceRegression) {\r\n        LOG(ERROR) << \"Performance regression detected: \" \r\n                   << metrics.performance_regression_percentage << \"%\";\r\n        return false;\r\n      }\r\n      \r\n      return true;\r\n    }\r\n\r\n   private:\r\n    static constexpr double kMinCodeCoverage = 80.0;\r\n    static constexpr int kMaxCyclomaticComplexity = 10;\r\n    static constexpr double kMinSecurityScore = 9.0;\r\n    static constexpr double kMaxPerformanceRegression = 5.0;\r\n  };\r\n};\r\n```\r\n\r\n---\r\n\r\n## 7. Future Architecture Considerations\r\n\r\n### Emerging Technology Integration\r\nChromium v134+ is designed with extensibility for future technologies:\r\n\r\n- **Quantum Computing Integration**: Quantum-resistant cryptography and quantum algorithm support\r\n- **Advanced AI/ML**: On-device large language models and neural processing units\r\n- **Extended Reality (XR)**: Native WebXR support with spatial computing capabilities\r\n- **Edge Computing**: Distributed rendering and computation across edge nodes\r\n- **Blockchain Integration**: Decentralized identity and secure transaction processing\r\n\r\n### Architectural Evolution Roadmap\r\n```cpp\r\n// Future architecture preparation\r\nclass FutureArchitecture {\r\n public:\r\n  // Quantum-resistant security layer\r\n  class QuantumResistantSecurity {\r\n   public:\r\n    void PrepareForQuantumComputing() {\r\n      // Implement post-quantum cryptography\r\n      crypto_manager_.EnablePostQuantumCryptography();\r\n      \r\n      // Update key exchange mechanisms\r\n      key_exchange_.UpgradeToQuantumResistant();\r\n      \r\n      // Prepare quantum-safe storage\r\n      storage_engine_.EnableQuantumSafeEncryption();\r\n    }\r\n  };\r\n  \r\n  // AI-native architecture components\r\n  class AIIntegratedArchitecture {\r\n   public:\r\n    void EnableAINativeFeatures() {\r\n      // On-device ML inference optimization\r\n      ml_accelerator_.OptimizeForOnDeviceInference();\r\n      \r\n      // AI-powered security monitoring\r\n      security_ai_.EnableAIThreatDetection();\r\n      \r\n      // Intelligent performance optimization\r\n      performance_ai_.EnableAIPerformanceOptimization();\r\n    }\r\n  };\r\n};\r\n```\r\n\r\n---\r\n\r\n## Summary\r\n\r\nChromium v134+ represents the pinnacle of browser architectural engineering, featuring:\r\n\r\n### Architectural Excellence\r\n1. **SOLID Principles**: Rigorous application of software engineering best practices\r\n2. **Service-Oriented Design**: Sophisticated microservice architecture with Mojo IPC\r\n3. **Zero-Trust Security**: Continuous verification and capability-based access control\r\n4. **Performance Excellence**: Sub-100ms navigation with AI-powered optimization\r\n5. **Extensibility**: Future-ready architecture for emerging technologies\r\n\r\n### Technical Innovation\r\n- **Advanced Multi-Process Model**: Enhanced security boundaries with site isolation\r\n- **Capability-Based Security**: Least-privilege access with continuous verification\r\n- **AI-Powered Optimization**: Machine learning for performance and security\r\n- **Cross-Platform Excellence**: Consistent behavior across all supported platforms\r\n- **Developer Experience**: Comprehensive tooling and debugging capabilities\r\n\r\n### Future Readiness\r\n- **Quantum-Resistant Security**: Preparation for post-quantum cryptography\r\n- **AI Integration**: Native support for advanced machine learning capabilities\r\n- **Extended Reality**: WebXR and spatial computing readiness\r\n- **Edge Computing**: Distributed architecture for edge deployment\r\n- **Blockchain Integration**: Decentralized technologies and secure transactions\r\n\r\nThis architectural foundation enables Chromium to maintain its position as the world's leading browser engine while continuously evolving to meet future challenges in security, performance, and user experience.\r\n\r\n**Related Documentation**:\r\n- [Module Layering](module-layering.md) - Detailed module architecture\r\n- [Process Model](process-model.md) - Multi-process implementation\r\n- [Security Architecture](security/sandbox-architecture.md) - Security boundaries and sandboxing\r\n- [IPC Internals](ipc-internals.md) - Inter-process communication patterns\r\n- [Performance Optimization](../modules/performance.md) - Performance best practices\r\n\r\n---\r\n\r\n*Last Updated: August 2025 | Chromium v134+ | Advanced Architecture Overview*\r\n"
  },
  {
    "path": "architecture/module-layering",
    "title": "Modern Chromium Module Layering Architecture (v134+)",
    "content": "# Modern Chromium Module Layering Architecture (v134+)\r\n\r\nThe architectural evolution of Chromium v134+ represents a sophisticated transformation from its early multi-process design into a comprehensive, service-oriented ecosystem. This modern layering approach emphasizes security, performance, maintainability, and cross-platform excellence while supporting cutting-edge web technologies and enterprise requirements.\r\n\r\n---\r\n\r\n## 1. Architectural Evolution & Design Philosophy\r\n\r\n### Historical Context and Modern Transformation\r\nChromium's architecture has evolved from a simple Browser/Renderer separation into a sophisticated multi-layered ecosystem. Early versions focused primarily on process isolation for security, while v134+ introduces comprehensive service architecture, enhanced security boundaries, and AI-powered capabilities.\r\n\r\n### Core Design Principles (v134+)\r\n- **Zero-Trust Security**: Every component operates under least-privilege with continuous verification\r\n- **Service-Oriented Architecture**: Modular services with capability-based communication via Mojo IPC\r\n- **Platform Agnostic Design**: Consistent behavior across Windows, macOS, Linux, Android, iOS, and Chrome OS\r\n- **Performance Excellence**: Sub-100ms navigation, 120+ FPS rendering with VRR display optimization\r\n- **Extensibility & Maintainability**: Clean abstractions enabling custom browser development and feature addition\r\n\r\n---\r\n\r\n## 2. Modern Layered Architecture Overview\r\n\r\n### Layer 1: Platform Abstraction Foundation\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                     Platform Layer (base/)                  │\r\n├─────────────────────────────────────────────────────────────┤\r\n│ • Cross-platform abstractions (Windows, macOS, Linux)      │\r\n│ • Memory management with RAII and smart pointers           │\r\n│ • Threading primitives and task scheduling                 │\r\n│ • Cryptographic services and quantum-resistant algorithms  │\r\n│ • Hardware abstraction (CPU features, GPU capabilities)    │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Layer 2: Core Infrastructure Services\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                  Infrastructure Services                    │\r\n├─────────────────────────────────────────────────────────────┤\r\n│ • Mojo IPC with capability-based security                  │\r\n│ • Service Manager with dependency injection                │\r\n│ • Process lifecycle management and health monitoring       │\r\n│ • Memory optimization and garbage collection               │\r\n│ • Performance instrumentation and telemetry                │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Layer 3: Core Web Platform (content/)\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                 Web Platform Core (content/)                │\r\n├─────────────────────────────────────────────────────────────┤\r\n│ • Blink rendering engine with advanced DOM/CSS processing  │\r\n│ • V8 JavaScript engine with WebAssembly support           │\r\n│ • Site isolation with enhanced security boundaries         │\r\n│ • Navigation and frame management with security policies   │\r\n│ • Web APIs implementation (WebGPU, WebNN, Storage, etc.)   │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Layer 4: Specialized Services Ecosystem\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                   Service Ecosystem                         │\r\n├─────────────────────────────────────────────────────────────┤\r\n│ • Network Service (HTTP/3, QUIC, DNS-over-HTTPS)          │\r\n│ • Storage Service (encrypted databases, OPFS)              │\r\n│ • Audio Service (spatial audio, hardware acceleration)     │\r\n│ • GPU Service (Vulkan, ray tracing, ML acceleration)       │\r\n│ • ML Service (TensorFlow Lite, privacy-preserving AI)      │\r\n│ • Device Service (WebHID, WebUSB, permission management)   │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Layer 5: Component Architecture\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                  Component Layer                            │\r\n├─────────────────────────────────────────────────────────────┤\r\n│ • Reusable feature modules with clean interfaces           │\r\n│ • Privacy Sandbox components (Topics, FLEDGE, Attribution) │\r\n│ • Security components (sandboxing, CFI, exploit mitigation)│\r\n│ • Performance components (Core Web Vitals optimization)    │\r\n│ • Accessibility and internationalization components        │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Layer 6: Application Layer (chrome/)\r\n```\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                   Application Layer                         │\r\n├─────────────────────────────────────────────────────────────┤\r\n│ • Browser UI with modern design systems                    │\r\n│ • Extensions API v3 with enhanced security                 │\r\n│ • Enterprise features (policy management, SSO)             │\r\n│ • Developer tools and debugging interfaces                 │\r\n│ • Custom browser modifications and enterprise integration  │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## 3. Service-Oriented Architecture Deep Dive\r\n\r\n### Modern Service Design Patterns\r\nChromium v134+ implements a sophisticated service architecture that goes far beyond traditional process separation:\r\n\r\n#### Service Manager and Dependency Injection\r\n```cpp\r\n// Modern service registration with capability-based security\r\nclass CustomBrowserService : public service_manager::Service {\r\n public:\r\n  explicit CustomBrowserService(service_manager::mojom::ServiceRequest request)\r\n      : service_binding_(this, std::move(request)) {\r\n    registry_.AddInterface(base::BindRepeating(\r\n        &CustomBrowserService::CreateSecureInterface,\r\n        base::Unretained(this)));\r\n  }\r\n\r\n private:\r\n  void CreateSecureInterface(\r\n      custom::mojom::SecureInterfaceRequest request) {\r\n    secure_interface_bindings_.AddBinding(\r\n        std::make_unique<SecureInterfaceImpl>(), std::move(request));\r\n  }\r\n\r\n  service_manager::ServiceBinding service_binding_;\r\n  service_manager::BinderRegistry registry_;\r\n  mojo::BindingSet<custom::mojom::SecureInterface> secure_interface_bindings_;\r\n};\r\n```\r\n\r\n#### Enhanced Service Communication\r\n```cpp\r\n// Capability-based service communication with security validation\r\nclass ServiceConnector {\r\n public:\r\n  template<typename Interface>\r\n  void ConnectToService(mojo::InterfaceRequest<Interface> request) {\r\n    if (!ValidateServiceCapability<Interface>()) {\r\n      SECURITY_LOG(ERROR) << \"Service capability validation failed\";\r\n      return;\r\n    }\r\n    \r\n    content::GetServiceManagerConnection()\r\n        ->GetConnector()\r\n        ->BindInterface(Interface::Name_, std::move(request));\r\n  }\r\n\r\n private:\r\n  template<typename Interface>\r\n  bool ValidateServiceCapability() {\r\n    return security_policy_.HasCapability(Interface::Name_);\r\n  }\r\n\r\n  SecurityPolicy security_policy_;\r\n};\r\n```\r\n\r\n### Service Isolation and Security Boundaries\r\nEach service operates in its own security context with strict capability enforcement:\r\n\r\n- **Network Service**: Isolated network processing with encrypted DNS and HTTP/3 support\r\n- **Storage Service**: Encrypted data persistence with privacy-preserving access controls\r\n- **GPU Service**: Hardware-accelerated rendering with Vulkan backend and security isolation\r\n- **Audio Service**: Low-latency audio processing with hardware acceleration and spatial audio\r\n- **ML Service**: On-device machine learning with privacy-preserving inference capabilities\r\n\r\n---\r\n\r\n## 4. Modern Process Architecture & Security Model\r\n\r\n### Enhanced Multi-Process Design\r\n```\r\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\r\n│  Browser Process│    │ Renderer Process│    │   GPU Process   │\r\n│                 │    │                 │    │                 │\r\n│ • UI Management │◄──►│ • Site Isolation│◄──►│ • Viz Compositor│\r\n│ • Service Coord │    │ • Blink Rendering│    │ • Vulkan Backend│\r\n│ • Policy Mgmt   │    │ • V8 JavaScript │    │ • ML Acceleration│\r\n│ • Security Enf  │    │ • WebAssembly   │    │ • Ray Tracing   │\r\n└─────────────────┘    └─────────────────┘    └─────────────────┘\r\n         │                       │                       │\r\n         ▼                       ▼                       ▼\r\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\r\n│ Network Service │    │ Storage Service │    │  Audio Service  │\r\n│                 │    │                 │    │                 │\r\n│ • HTTP/3 & QUIC │    │ • Encrypted DB  │    │ • Spatial Audio │\r\n│ • DNS-over-HTTPS│    │ • OPFS Support  │    │ • HW Acceleration│\r\n│ • Privacy Proxy │    │ • Cache Mgmt    │    │ • Real-time FX  │\r\n└─────────────────┘    └─────────────────┘    └─────────────────┘\r\n```\r\n\r\n### Advanced Security Architecture\r\n```cpp\r\n// Site isolation with enhanced security boundaries\r\nclass SiteIsolationPolicy {\r\n public:\r\n  struct SecurityBoundary {\r\n    // Enhanced origin isolation with sub-resource integrity\r\n    url::Origin primary_origin;\r\n    std::vector<url::Origin> related_origins;\r\n    SecurityContext security_context;\r\n    PermissionPolicy permission_policy;\r\n    \r\n    // Hardware-assisted security features\r\n    bool cfi_enabled = true;\r\n    bool memory_tagging_enabled = true;\r\n    bool pointer_authentication_enabled = true;\r\n  };\r\n\r\n  bool ShouldIsolateOrigin(const url::Origin& origin) const {\r\n    // Advanced heuristics for origin isolation\r\n    return IsHighRiskOrigin(origin) || \r\n           HasSpecialPermissions(origin) ||\r\n           RequiresEnhancedSecurity(origin);\r\n  }\r\n\r\n private:\r\n  bool IsHighRiskOrigin(const url::Origin& origin) const {\r\n    return high_risk_origins_.contains(origin) ||\r\n           IsKnownMaliciousOrigin(origin);\r\n  }\r\n\r\n  std::unordered_set<url::Origin> high_risk_origins_;\r\n  ThreatIntelligence threat_intelligence_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 5. Component Architecture & Modularity\r\n\r\n### Modern Component Design Patterns\r\nComponents in v134+ follow strict architectural principles for maintainability and extensibility:\r\n\r\n#### Component Interface Definition\r\n```cpp\r\n// Modern component with capability-based interfaces\r\nclass PrivacySandboxComponent : public Component {\r\n public:\r\n  // Component lifecycle with enhanced initialization\r\n  bool Initialize(const ComponentConfig& config) override {\r\n    if (!ValidateConfiguration(config)) {\r\n      return false;\r\n    }\r\n    \r\n    // Initialize Topics API with differential privacy\r\n    topics_api_ = std::make_unique<TopicsAPI>(\r\n        config.privacy_budget, config.noise_parameters);\r\n    \r\n    // Initialize FLEDGE with enhanced security\r\n    fledge_api_ = std::make_unique<FLEDGEAPI>(\r\n        config.security_policy, config.auction_parameters);\r\n    \r\n    return RegisterMojoInterfaces();\r\n  }\r\n\r\n  // Capability-based interface exposure\r\n  void BindTopicsInterface(\r\n      mojo::PendingReceiver<privacy_sandbox::mojom::TopicsAPI> receiver) {\r\n    if (!HasTopicsCapability()) {\r\n      SECURITY_LOG(WARNING) << \"Topics capability not granted\";\r\n      return;\r\n    }\r\n    topics_api_receivers_.Add(topics_api_.get(), std::move(receiver));\r\n  }\r\n\r\n private:\r\n  bool ValidateConfiguration(const ComponentConfig& config) {\r\n    return config.IsValid() && config.HasRequiredCapabilities();\r\n  }\r\n\r\n  bool HasTopicsCapability() const {\r\n    return capability_manager_.HasCapability(\"privacy_sandbox.topics\");\r\n  }\r\n\r\n  std::unique_ptr<TopicsAPI> topics_api_;\r\n  std::unique_ptr<FLEDGEAPI> fledge_api_;\r\n  mojo::ReceiverSet<privacy_sandbox::mojom::TopicsAPI> topics_api_receivers_;\r\n  CapabilityManager capability_manager_;\r\n};\r\n```\r\n\r\n### Component Registration and Discovery\r\n```cpp\r\n// Modern component registry with dependency injection\r\nclass ComponentRegistry {\r\n public:\r\n  template<typename ComponentType>\r\n  void RegisterComponent(std::unique_ptr<ComponentType> component) {\r\n    static_assert(std::is_base_of_v<Component, ComponentType>);\r\n    \r\n    const std::string component_name = ComponentType::GetName();\r\n    \r\n    // Validate component dependencies\r\n    if (!ValidateDependencies<ComponentType>()) {\r\n      LOG(ERROR) << \"Component dependencies not satisfied: \" << component_name;\r\n      return;\r\n    }\r\n    \r\n    // Register component with capability constraints\r\n    components_[component_name] = std::move(component);\r\n    capability_manager_.RegisterComponentCapabilities<ComponentType>();\r\n  }\r\n\r\n  template<typename ComponentType>\r\n  ComponentType* GetComponent() {\r\n    const std::string component_name = ComponentType::GetName();\r\n    auto it = components_.find(component_name);\r\n    \r\n    if (it == components_.end()) {\r\n      return nullptr;\r\n    }\r\n    \r\n    return static_cast<ComponentType*>(it->second.get());\r\n  }\r\n\r\n private:\r\n  template<typename ComponentType>\r\n  bool ValidateDependencies() {\r\n    for (const auto& dependency : ComponentType::GetDependencies()) {\r\n      if (components_.find(dependency) == components_.end()) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  std::unordered_map<std::string, std::unique_ptr<Component>> components_;\r\n  CapabilityManager capability_manager_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 6. Performance & Optimization Architecture\r\n\r\n### Advanced Performance Monitoring\r\n```cpp\r\n// Real-time performance monitoring with Core Web Vitals\r\nclass PerformanceMonitor {\r\n public:\r\n  struct PerformanceMetrics {\r\n    // Core Web Vitals with enhanced precision\r\n    base::TimeDelta largest_contentful_paint;\r\n    base::TimeDelta interaction_to_next_paint;\r\n    double cumulative_layout_shift;\r\n    \r\n    // Advanced metrics for v134+\r\n    base::TimeDelta time_to_interactive;\r\n    base::TimeDelta first_input_delay;\r\n    double throughput_score;\r\n    \r\n    // Hardware-specific metrics\r\n    double gpu_utilization;\r\n    double memory_pressure;\r\n    double thermal_state;\r\n  };\r\n\r\n  void RecordNavigationMetrics(const GURL& url, \r\n                              const PerformanceMetrics& metrics) {\r\n    // Record with privacy-preserving aggregation\r\n    performance_database_.RecordMetrics(\r\n        GetOriginHash(url), metrics, GetPrivacyBudget());\r\n    \r\n    // Trigger optimization recommendations\r\n    if (ShouldOptimize(metrics)) {\r\n      optimization_engine_.TriggerOptimization(url, metrics);\r\n    }\r\n  }\r\n\r\n private:\r\n  bool ShouldOptimize(const PerformanceMetrics& metrics) {\r\n    return metrics.largest_contentful_paint > kLCPThreshold ||\r\n           metrics.cumulative_layout_shift > kCLSThreshold ||\r\n           metrics.interaction_to_next_paint > kINPThreshold;\r\n  }\r\n\r\n  PerformanceDatabase performance_database_;\r\n  OptimizationEngine optimization_engine_;\r\n  PrivacyBudgetManager privacy_budget_manager_;\r\n};\r\n```\r\n\r\n### Memory Management Architecture\r\n```cpp\r\n// Advanced memory management with predictive optimization\r\nclass MemoryManager {\r\n public:\r\n  enum class MemoryPressureLevel {\r\n    kNone,\r\n    kModerate,\r\n    kCritical\r\n  };\r\n\r\n  struct MemoryAllocationStrategy {\r\n    // Adaptive allocation based on usage patterns\r\n    size_t initial_capacity;\r\n    double growth_factor;\r\n    size_t max_capacity;\r\n    \r\n    // Machine learning-based prediction\r\n    bool enable_predictive_allocation = true;\r\n    bool enable_compression = true;\r\n    bool enable_memory_mapping = true;\r\n  };\r\n\r\n  void OptimizeMemoryUsage(MemoryPressureLevel pressure_level) {\r\n    switch (pressure_level) {\r\n      case MemoryPressureLevel::kModerate:\r\n        TriggerGarbageCollection();\r\n        CompressInactiveFrames();\r\n        break;\r\n        \r\n      case MemoryPressureLevel::kCritical:\r\n        DiscardBackgroundTabs();\r\n        FreeNonEssentialCaches();\r\n        TriggerEmergencyCompaction();\r\n        break;\r\n        \r\n      default:\r\n        PerformPredictiveOptimization();\r\n        break;\r\n    }\r\n  }\r\n\r\n private:\r\n  void TriggerGarbageCollection() {\r\n    v8_isolate_->RequestGarbageCollectionForTesting(\r\n        v8::Isolate::kFullGarbageCollection);\r\n  }\r\n\r\n  void CompressInactiveFrames() {\r\n    for (auto& frame : inactive_frames_) {\r\n      frame->CompressMemoryFootprint();\r\n    }\r\n  }\r\n\r\n  v8::Isolate* v8_isolate_;\r\n  std::vector<std::unique_ptr<Frame>> inactive_frames_;\r\n  PredictiveOptimizer memory_predictor_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 7. Custom Browser Development Integration\r\n\r\n### Modern Extension Points\r\nChromium v134+ provides sophisticated extension points for custom browser development:\r\n\r\n#### Custom Service Integration\r\n```cpp\r\n// Custom service with enterprise-grade capabilities\r\nclass CustomEnterpriseService : public service_manager::Service {\r\n public:\r\n  struct EnterpriseConfiguration {\r\n    // Policy management\r\n    PolicyConfiguration policy_config;\r\n    \r\n    // Single Sign-On integration\r\n    SSOConfiguration sso_config;\r\n    \r\n    // Compliance and auditing\r\n    ComplianceConfiguration compliance_config;\r\n    \r\n    // Custom security policies\r\n    SecurityPolicyConfiguration security_config;\r\n  };\r\n\r\n  void InitializeEnterpriseFeatures(const EnterpriseConfiguration& config) {\r\n    // Initialize policy management\r\n    policy_manager_ = std::make_unique<PolicyManager>(config.policy_config);\r\n    \r\n    // Setup SSO integration\r\n    sso_provider_ = SSOProviderFactory::Create(config.sso_config);\r\n    \r\n    // Configure compliance monitoring\r\n    compliance_monitor_ = std::make_unique<ComplianceMonitor>(\r\n        config.compliance_config);\r\n    \r\n    // Apply custom security policies\r\n    ApplySecurityPolicies(config.security_config);\r\n  }\r\n\r\n private:\r\n  void ApplySecurityPolicies(const SecurityPolicyConfiguration& config) {\r\n    security_enforcer_.ApplyPolicies(config);\r\n    \r\n    // Register for security events\r\n    security_enforcer_.RegisterEventHandler(\r\n        base::BindRepeating(&CustomEnterpriseService::OnSecurityEvent,\r\n                           base::Unretained(this)));\r\n  }\r\n\r\n  std::unique_ptr<PolicyManager> policy_manager_;\r\n  std::unique_ptr<SSOProvider> sso_provider_;\r\n  std::unique_ptr<ComplianceMonitor> compliance_monitor_;\r\n  SecurityEnforcer security_enforcer_;\r\n};\r\n```\r\n\r\n#### Custom UI Integration\r\n```cpp\r\n// Modern custom UI component with accessibility and theming\r\nclass CustomBrowserUI : public views::View {\r\n public:\r\n  CustomBrowserUI() {\r\n    SetLayoutManager(std::make_unique<views::BoxLayout>(\r\n        views::BoxLayout::Orientation::kVertical));\r\n    \r\n    // Custom toolbar with accessibility support\r\n    custom_toolbar_ = AddChildView(std::make_unique<CustomToolbar>());\r\n    custom_toolbar_->SetAccessibleName(u\"Custom Browser Toolbar\");\r\n    \r\n    // Enhanced content area with security indicators\r\n    content_area_ = AddChildView(std::make_unique<SecureContentArea>());\r\n    \r\n    // Status bar with privacy and performance metrics\r\n    status_bar_ = AddChildView(std::make_unique<EnhancedStatusBar>());\r\n  }\r\n\r\n  // Theme integration with system preferences\r\n  void OnThemeChanged() override {\r\n    views::View::OnThemeChanged();\r\n    \r\n    const ui::ColorProvider* color_provider = GetColorProvider();\r\n    SetBackground(views::CreateSolidBackground(\r\n        color_provider->GetColor(ui::kColorWindowBackground)));\r\n    \r\n    // Update custom components with new theme\r\n    custom_toolbar_->UpdateTheme(color_provider);\r\n    status_bar_->UpdateTheme(color_provider);\r\n  }\r\n\r\n private:\r\n  CustomToolbar* custom_toolbar_ = nullptr;\r\n  SecureContentArea* content_area_ = nullptr;\r\n  EnhancedStatusBar* status_bar_ = nullptr;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 8. Modern Build System & Development Workflow\r\n\r\n### Advanced Build Configuration\r\n```python\r\n# Modern GN build configuration for custom browser\r\n# BUILD.gn\r\n\r\nimport(\"//build/config/features.gni\")\r\nimport(\"//chrome/common/features.gni\")\r\n\r\n# Custom browser configuration\r\ndeclare_args() {\r\n  # Enable custom enterprise features\r\n  enable_custom_enterprise_features = true\r\n  \r\n  # Enhanced security features\r\n  enable_enhanced_security = true\r\n  \r\n  # Performance optimizations\r\n  enable_performance_optimizations = true\r\n  \r\n  # AI/ML integration\r\n  enable_ml_features = true\r\n}\r\n\r\n# Custom browser executable\r\nexecutable(\"custom_browser\") {\r\n  sources = [\r\n    \"custom_browser_main.cc\",\r\n    \"custom_browser_main.h\",\r\n  ]\r\n\r\n  deps = [\r\n    \"//chrome:chrome_initial\",\r\n    \"//custom/browser:browser_lib\",\r\n    \"//custom/common:common_lib\",\r\n  ]\r\n\r\n  if (enable_custom_enterprise_features) {\r\n    deps += [ \"//custom/enterprise:enterprise_lib\" ]\r\n    defines += [ \"ENABLE_CUSTOM_ENTERPRISE_FEATURES\" ]\r\n  }\r\n\r\n  if (enable_enhanced_security) {\r\n    deps += [ \"//custom/security:security_lib\" ]\r\n    defines += [ \"ENABLE_ENHANCED_SECURITY\" ]\r\n  }\r\n\r\n  if (enable_ml_features) {\r\n    deps += [\r\n      \"//components/ml:ml_service\",\r\n      \"//third_party/tensorflow_lite\",\r\n    ]\r\n    defines += [ \"ENABLE_ML_FEATURES\" ]\r\n  }\r\n}\r\n\r\n# Custom service library\r\ncomponent(\"custom_service_lib\") {\r\n  sources = [\r\n    \"custom_service.cc\",\r\n    \"custom_service.h\",\r\n    \"custom_service_impl.cc\",\r\n    \"custom_service_impl.h\",\r\n  ]\r\n\r\n  deps = [\r\n    \"//base\",\r\n    \"//mojo/public/cpp/bindings\",\r\n    \"//services/service_manager/public/cpp\",\r\n  ]\r\n\r\n  public_deps = [\r\n    \"//custom/public/mojom\",\r\n  ]\r\n}\r\n```\r\n\r\n### Modern Development Tools Integration\r\n```bash\r\n#!/bin/bash\r\n# Modern development workflow script\r\n\r\n# Environment setup with advanced tooling\r\nsetup_development_environment() {\r\n    echo \"Setting up Chromium v134+ development environment...\"\r\n    \r\n    # Install modern build tools\r\n    python3 -m pip install --upgrade build-tools\r\n    \r\n    # Configure advanced debugging\r\n    gn gen out/Debug --args='\r\n        is_debug=true\r\n        symbol_level=2\r\n        enable_iterator_debugging=true\r\n        use_goma=true\r\n        enable_nacl=false\r\n        enable_custom_features=true\r\n    '\r\n    \r\n    # Setup performance profiling\r\n    gn gen out/Profile --args='\r\n        is_debug=false\r\n        symbol_level=1\r\n        enable_profiling=true\r\n        use_thin_lto=true\r\n        enable_custom_features=true\r\n    '\r\n    \r\n    # Configure security-hardened build\r\n    gn gen out/Security --args='\r\n        is_debug=false\r\n        is_cfi=true\r\n        use_cfi_icall=true\r\n        enable_control_flow_integrity=true\r\n        enable_custom_security=true\r\n    '\r\n}\r\n\r\n# Advanced testing with comprehensive coverage\r\nrun_comprehensive_tests() {\r\n    echo \"Running comprehensive test suite...\"\r\n    \r\n    # Unit tests with enhanced coverage\r\n    ninja -C out/Debug custom_browser_unittests\r\n    ./out/Debug/custom_browser_unittests --gtest_output=xml:test_results.xml\r\n    \r\n    # Integration tests\r\n    ninja -C out/Debug browser_tests\r\n    ./out/Debug/browser_tests --test-launcher-filter-file=custom_tests.filter\r\n    \r\n    # Security tests\r\n    ninja -C out/Security security_tests\r\n    ./out/Security/security_tests\r\n    \r\n    # Performance benchmarks\r\n    ninja -C out/Profile performance_tests\r\n    ./out/Profile/performance_tests --benchmark_format=json\r\n}\r\n```\r\n\r\n---\r\n\r\n## 9. Enterprise Integration & Deployment\r\n\r\n### Modern Enterprise Features\r\n```cpp\r\n// Enterprise policy management with modern configuration\r\nclass EnterprisePolicyManager {\r\n public:\r\n  struct PolicyConfiguration {\r\n    // Security policies\r\n    SecurityPolicySet security_policies;\r\n    \r\n    // Network policies with advanced controls\r\n    NetworkPolicySet network_policies;\r\n    \r\n    // Content filtering with ML-based classification\r\n    ContentFilteringPolicy content_filtering;\r\n    \r\n    // Privacy and compliance policies\r\n    PrivacyPolicySet privacy_policies;\r\n    \r\n    // Custom extension policies\r\n    ExtensionPolicySet extension_policies;\r\n  };\r\n\r\n  void ApplyEnterpriseConfiguration(const PolicyConfiguration& config) {\r\n    // Apply security policies with validation\r\n    for (const auto& policy : config.security_policies) {\r\n      if (ValidateSecurityPolicy(policy)) {\r\n        security_enforcer_.ApplyPolicy(policy);\r\n      }\r\n    }\r\n    \r\n    // Configure network policies\r\n    network_policy_enforcer_.ApplyPolicies(config.network_policies);\r\n    \r\n    // Setup content filtering with ML classification\r\n    content_filter_.Initialize(config.content_filtering);\r\n    \r\n    // Apply privacy policies with GDPR compliance\r\n    privacy_manager_.ApplyPolicies(config.privacy_policies);\r\n  }\r\n\r\n private:\r\n  SecurityPolicyEnforcer security_enforcer_;\r\n  NetworkPolicyEnforcer network_policy_enforcer_;\r\n  MLContentFilter content_filter_;\r\n  PrivacyPolicyManager privacy_manager_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 10. Future Architecture Considerations\r\n\r\n### Emerging Technologies Integration\r\n- **Quantum-Resistant Cryptography**: Preparing for post-quantum security\r\n- **Advanced AI Integration**: On-device language models and intelligent automation\r\n- **Extended Reality (XR)**: WebXR enhancements and spatial computing\r\n- **Edge Computing**: Distributed rendering and computation\r\n- **Blockchain Integration**: Decentralized identity and secure transactions\r\n\r\n### Architectural Evolution Roadmap\r\n- **Microkernel Architecture**: Further service isolation and modularity\r\n- **WebAssembly System Interface**: Enhanced WASI support for system integration\r\n- **Advanced ML Optimization**: Hardware-accelerated inference and training\r\n- **Privacy-Preserving Technologies**: Homomorphic encryption and secure computation\r\n- **Cross-Platform Optimization**: Universal binary format and adaptive UIs\r\n\r\n---\r\n\r\n## Summary\r\n\r\nModern Chromium v134+ represents the pinnacle of browser architecture, featuring sophisticated service-oriented design, enhanced security boundaries, performance optimization, and extensibility for custom browser development. This layered architecture provides:\r\n\r\n1. **Robust Foundation**: Platform-agnostic base with advanced abstractions\r\n2. **Service Excellence**: Modular services with capability-based security\r\n3. **Performance Leadership**: Sub-100ms navigation and 120+ FPS rendering\r\n4. **Security Innovation**: Zero-trust architecture with hardware-assisted protection\r\n5. **Developer Experience**: Comprehensive tools and extension points\r\n6. **Enterprise Ready**: Policy management, compliance, and integration capabilities\r\n\r\nThe architecture continues to evolve, embracing emerging technologies while maintaining backward compatibility and providing excellent developer experience for custom browser development.\r\n\r\n**Related Documentation**:\r\n- [Process Model](../architecture/process-model.md) - Multi-process architecture details\r\n- [IPC Internals](../architecture/ipc-internals.md) - Mojo communication patterns\r\n- [Security Architecture](../architecture/security/sandbox-architecture.md) - Security boundaries and sandboxing\r\n- [Performance Optimization](../modules/performance.md) - Performance best practices\r\n- [Custom Development Guide](../getting-started/custom-development.md) - Building custom features\r\n\r\n---\r\n\r\n*Last Updated: August 2025 | Chromium v134+ | Advanced Module Layering Architecture*\r\n"
  },
  {
    "path": "architecture/ipc-internals",
    "title": "Chromium IPC Internals (Mojo Architecture v134+)",
    "content": "# Chromium IPC Internals (Mojo Architecture v134+)\r\n\r\nChromium's Inter-Process Communication has evolved significantly with the introduction and maturation of **Mojo IPC**, which provides a modern, type-safe, and secure foundation for communication between processes in Chromium's multi-process architecture. This document covers the modern Mojo-based IPC system used in v134+ and its advanced features.\r\n\r\n---\r\n\r\n## Modern IPC Architecture Overview (v134+)\r\n\r\nChromium has transitioned from legacy IPC to **Mojo**, a sophisticated message-passing framework that provides enhanced security, type safety, and performance for cross-process communication.\r\n\r\n### Key Evolution from Legacy IPC:\r\n1. **Mojo Replaces Legacy IPC**: \r\n   - Type-safe interface definitions using Mojom IDL\r\n   - Capability-based security model\r\n   - Advanced message routing and filtering\r\n\r\n2. **Modern Communication Mechanisms**:\r\n   - **Message Pipes**: Bidirectional communication channels\r\n   - **Shared Buffers**: Efficient large data transfer\r\n   - **Data Pipes**: High-throughput streaming\r\n   - **Interface Pipes**: Type-safe service communication\r\n\r\n3. **Platform Abstraction**:\r\n   - Unified API across Windows, Linux, macOS, Android\r\n   - Platform-specific optimizations handled transparently\r\n   - Enhanced security through capability delegation\r\n\r\n---\r\n\r\n## Modern Mojo IPC Components (v134+)\r\n\r\n### 1. **Mojo Core**\r\n- **Low-level primitives**: Message pipes, shared buffers, data pipes\r\n- **Platform abstraction**: Unified interface across all supported platforms\r\n- **Handle management**: Automatic resource cleanup and security enforcement\r\n- **Performance optimization**: Zero-copy transfers and efficient routing\r\n\r\n### 2. **Mojom Interface Definition Language (IDL)**\r\n- **Type-safe interfaces**: Strongly-typed service definitions\r\n- **Code generation**: Automatic client/server stub generation\r\n- **Versioning support**: Interface evolution without breaking compatibility\r\n- **Documentation integration**: Self-documenting service APIs\r\n\r\n### 3. **Service Manager (v134+)**\r\n- **Service discovery**: Automatic service location and connection\r\n- **Capability delegation**: Fine-grained permission system\r\n- **Lifecycle management**: Service startup, shutdown, and recovery\r\n- **Security policy**: Capability-based access control\r\n\r\n### 4. **Interface Brokers**\r\n- **Cross-process binding**: Secure interface establishment\r\n- **Permission validation**: Capability-based access checks\r\n- **Connection management**: Automatic cleanup and error handling\r\n- **Load balancing**: Intelligent service distribution\r\n\r\n### 5. **Mojo Bindings (C++, JavaScript)**\r\n- **Language bindings**: Native integration with C++ and JavaScript\r\n- **Async/Await support**: Modern asynchronous programming patterns\r\n- **Error handling**: Comprehensive error propagation and recovery\r\n- **Performance optimizations**: Efficient serialization and deserialization\r\n\r\n---\r\n\r\n## Modern Message Patterns & Communication (v134+)\r\n\r\n### Service Interface Pattern\r\n```cpp\r\n// Example Mojom interface definition\r\nmodule example.mojom;\r\n\r\ninterface DatabaseService {\r\n  // Async method with callback\r\n  GetUser(int32 user_id) => (User? user);\r\n  \r\n  // Fire-and-forget method  \r\n  LogEvent(string event_name);\r\n  \r\n  // Streaming interface\r\n  WatchUsers() => (array<User> users);\r\n};\r\n```\r\n\r\n### Message Types & Features:\r\n1. **Request/Response Pattern**:\r\n   - Type-safe method calls with strongly-typed responses\r\n   - Automatic timeout handling and error propagation\r\n   - Support for complex data types and nested structures\r\n\r\n2. **Fire-and-Forget Messages**:\r\n   - One-way communication for performance-critical operations\r\n   - No response expected, optimized for throughput\r\n   - Automatic message ordering and delivery guarantees\r\n\r\n3. **Streaming Interfaces**:\r\n   - High-throughput data streaming using data pipes\r\n   - Backpressure handling and flow control\r\n   - Efficient large data transfer without memory copying\r\n\r\n4. **Associated Interfaces**:\r\n   - Ordered message delivery within interface groups\r\n   - Maintains message ordering across related interfaces\r\n   - Critical for coordinated operations like rendering\r\n\r\n### Modern Message Priorities (v134+):\r\n- **URGENT**: Critical system messages (input, vsync)\r\n- **HIGH**: User-visible operations (navigation, rendering)\r\n- **NORMAL**: Standard application logic\r\n- **LOW**: Background tasks and maintenance\r\n- **BEST_EFFORT**: Non-critical telemetry and logging\r\n\r\n---\r\n\r\n## Platform-Specific Implementations (v134+)\r\n\r\n### Windows (Enhanced for v134+):\r\n- **Message Pipes over Named Pipes**:\r\n  - Improved security with restricted access controls\r\n  - Enhanced performance through IOCP integration\r\n  - Support for large message batching\r\n\r\n- **Shared Memory Integration**:\r\n  - Direct memory mapping for large data transfers\r\n  - Copy-on-write semantics for efficient sharing\r\n  - Automatic cleanup on process termination\r\n\r\n- **Security Enhancements**:\r\n  - App Container integration for sandboxed processes\r\n  - Enhanced token validation and capability delegation\r\n  - Protection against handle duplication attacks\r\n\r\n### Linux/POSIX (Enhanced for v134+):\r\n- **Message Pipes over UNIX Domain Sockets**:\r\n  - Abstract namespace sockets for improved security\r\n  - SCM_RIGHTS for secure file descriptor passing\r\n  - Peer credential validation using SO_PEERCRED\r\n\r\n- **Shared Memory via memfd**:\r\n  - Modern memfd_create() for anonymous shared memory\r\n  - Sealing support for immutable shared data\r\n  - Integration with namespace isolation\r\n\r\n- **Security Features**:\r\n  - Seccomp-BPF filtering for system call restriction\r\n  - User namespace integration for privilege isolation\r\n  - Landlock support for filesystem access control\r\n\r\n### macOS (Enhanced for v134+):\r\n- **Message Pipes over Mach Ports**:\r\n  - Native Mach port integration for optimal performance\r\n  - Automatic port right management and cleanup\r\n  - Support for complex data structures via Mach messages\r\n\r\n- **Shared Memory via Mach**:\r\n  - Mach virtual memory objects for efficient sharing\r\n  - Copy-on-write semantics with automatic optimization\r\n  - Integration with macOS memory pressure system\r\n\r\n- **Security Integration**:\r\n  - App Sandbox compatibility with restricted entitlements\r\n  - System Integrity Protection (SIP) compliance\r\n  - Hardened Runtime support for code signing validation\r\n\r\n---\r\n\r\n## Advanced Mojo Features (v134+)\r\n\r\n### 1. **Capability-Based Security**\r\n- **Interface Filtering**: Process-specific access control for service interfaces\r\n- **Capability Delegation**: Secure forwarding of permissions between processes\r\n- **Dynamic Permissions**: Runtime capability adjustment based on context\r\n- **Audit Logging**: Comprehensive tracking of capability usage and violations\r\n\r\n### 2. **High-Performance Optimizations**\r\n- **Zero-Copy Transfers**: Direct memory sharing for large payloads using shared buffers\r\n- **Message Coalescing**: Batching related messages for improved throughput\r\n- **Priority Scheduling**: Critical path optimization for time-sensitive operations\r\n- **Connection Pooling**: Efficient reuse of communication channels\r\n\r\n### 3. **Advanced Data Transfer**\r\n- **Shared Buffers**: \r\n  ```cpp\r\n  // Example: Large data transfer via shared buffer\r\n  mojo::ScopedSharedBufferHandle buffer = \r\n      mojo::SharedBufferHandle::Create(size);\r\n  interface_ptr->ProcessLargeData(std::move(buffer));\r\n  ```\r\n\r\n- **Data Pipes**:\r\n  ```cpp\r\n  // Example: Streaming data with flow control\r\n  mojo::ScopedDataPipeProducerHandle producer;\r\n  mojo::ScopedDataPipeConsumerHandle consumer;\r\n  mojo::CreateDataPipe(nullptr, &producer, &consumer);\r\n  interface_ptr->StreamData(std::move(consumer));\r\n  ```\r\n\r\n### 4. **Modern Error Handling**\r\n- **Connection Error Callbacks**: Automatic cleanup on process termination\r\n- **Message Validation**: Runtime validation of all incoming messages\r\n- **Timeout Management**: Configurable timeouts for request/response patterns\r\n- **Recovery Mechanisms**: Automatic service restart and state restoration\r\n\r\n### 5. **Development & Debugging Tools**\r\n- **Mojo Tracing**: Detailed IPC performance analysis\r\n- **Interface Inspector**: Runtime service discovery and monitoring\r\n- **Message Logging**: Comprehensive audit trail for security analysis\r\n- **Performance Profiling**: Real-time IPC performance metrics\r\n\r\n---\r\n\r\n## Modern Service Architecture Examples (v134+)\r\n\r\n### Network Service Interface:\r\n```cpp\r\n// Modern Mojom interface for network operations\r\nmodule network.mojom;\r\n\r\ninterface NetworkService {\r\n  // URL loading with streaming response\r\n  CreateURLLoader(URLLoaderFactory& factory);\r\n  \r\n  // DNS resolution with caching\r\n  ResolveHost(string hostname) => (array<IPAddress> addresses);\r\n  \r\n  // Certificate validation\r\n  ValidateCertificate(Certificate cert) => (CertificateStatus status);\r\n};\r\n```\r\n\r\n### GPU Service Communication:\r\n```cpp\r\n// GPU process communication for hardware acceleration\r\nmodule gpu.mojom;\r\n\r\ninterface GpuService {\r\n  // Context creation for rendering\r\n  CreateGpuMemoryBuffer(GpuMemoryBufferType type) => \r\n      (GpuMemoryBufferHandle? handle);\r\n  \r\n  // Command buffer for GPU operations\r\n  CreateCommandBuffer(CommandBufferSpec spec) => \r\n      (CommandBuffer? buffer);\r\n  \r\n  // Video decode acceleration\r\n  CreateVideoDecoder(VideoDecoderConfig config) => \r\n      (VideoDecoder? decoder);\r\n};\r\n```\r\n\r\n### Modern Message Flow:\r\n```text\r\nBrowser Process                 Renderer Process\r\n      │                              │\r\n      ├─[Service Discovery]───────────┤\r\n      │                              │\r\n      ├─[Interface Binding]───────────┤\r\n      │                              │\r\n      ├─[Method Call + Callback]──────┤\r\n      │                              │\r\n      ├─[Shared Buffer Transfer]──────┤\r\n      │                              │\r\n      └─[Connection Cleanup]──────────┘\r\n```\r\n\r\n---\r\n\r\n## Debugging & Performance Analysis (v134+)\r\n\r\n### Mojo Debugging Tools:\r\n- **chrome://tracing/**: Advanced IPC timeline analysis with Mojo-specific categories\r\n- **chrome://mojo-internals/**: Real-time interface monitoring and statistics\r\n- **chrome://process-internals/**: Process-specific IPC performance metrics\r\n- **Mojo Shell Inspector**: Service discovery and connection visualization\r\n\r\n### Command Line Debugging:\r\n```bash\r\n# Enable detailed Mojo logging\r\n--enable-logging=stderr --vmodule=\"*mojo*=2\"\r\n\r\n# Trace specific IPC categories\r\n--trace-startup --trace-config=\"mojo,ipc,mojom\"\r\n\r\n# Enable service manager tracing\r\n--enable-service-manager-tracing\r\n\r\n# Debug interface binding issues\r\n--mojo-core-library-path=debug_path\r\n```\r\n\r\n### Performance Optimization:\r\n```cpp\r\n// Example: Optimized large data transfer\r\nclass OptimizedService : public mojom::DataService {\r\n  void TransferLargeData(\r\n      mojo::ScopedSharedBufferHandle buffer,\r\n      TransferLargeDataCallback callback) override {\r\n    \r\n    // Zero-copy processing of shared buffer\r\n    auto mapping = buffer->Map(buffer_size);\r\n    ProcessDataInPlace(mapping.get());\r\n    \r\n    std::move(callback).Run(ProcessingResult::SUCCESS);\r\n  }\r\n};\r\n```\r\n\r\n### Security Analysis:\r\n- **Capability Audit**: Track capability delegation and usage\r\n- **Message Validation**: Runtime validation of all IPC messages\r\n- **Interface Access Control**: Monitor unauthorized service access attempts\r\n- **Connection Security**: Validate all cross-process connections\r\n\r\n---\r\n\r\n## Migration from Legacy IPC (Historical Context)\r\n\r\n### Legacy vs Modern Comparison:\r\n| Feature | Legacy IPC | Modern Mojo IPC |\r\n|---------|------------|-----------------|\r\n| **Type Safety** | Manual serialization | Generated type-safe bindings |\r\n| **Security** | Basic validation | Capability-based access control |\r\n| **Performance** | Copy-heavy operations | Zero-copy optimizations |\r\n| **Platform Support** | Platform-specific code | Unified cross-platform API |\r\n| **Error Handling** | Manual error propagation | Automatic error handling |\r\n| **Debugging** | Limited tooling | Comprehensive debugging suite |\r\n\r\n### Migration Status (v134+):\r\n- **Renderer ↔ Browser**: Fully migrated to Mojo\r\n- **GPU Process**: Complete Mojo integration with Viz compositor\r\n- **Network Service**: Native Mojo implementation\r\n- **Audio/Video Services**: Modern Mojo-based architecture\r\n- **Utility Processes**: Mojo-first design for all new services\r\n\r\n---\r\n\r\n## References & Further Reading\r\n\r\n### Official Documentation:\r\n1. [Mojo Documentation](https://chromium.googlesource.com/chromium/src/+/main/mojo/README.md)\r\n2. [Service Manager Guide](https://chromium.googlesource.com/chromium/src/+/main/services/README.md)\r\n3. [Mojom IDL Specification](https://chromium.googlesource.com/chromium/src/+/main/mojo/public/tools/bindings/README.md)\r\n\r\n### Design Documents:\r\n4. [Mojo Design Principles](https://docs.google.com/document/d/1n7qYjQ5iy8xAkQVe_EJrYd-5_vJwsOomsH9hbw_-WVE)\r\n5. [Service-Oriented Architecture](https://docs.google.com/document/d/15I7sQyQo6zsqXVNAlVd520tdGaS8FCicfHrPacHd_lk)\r\n6. [Security Model Evolution](https://docs.google.com/document/d/1Lj0sKqHg-3VK3n5zCv8gf2FLR1l5QhX1DCt-rqOaKVs)\r\n\r\n### Performance Analysis:\r\n7. [IPC Performance Optimization](https://docs.google.com/document/d/1x5zGP0l5gH1y4B1U5I6vKgvKO2vQ4V7zqF8T0F9a5zQ)\r\n8. [Mojo Benchmarking](https://chromium.googlesource.com/chromium/src/+/main/mojo/core/test/)\r\n\r\n---\r\n\r\n## Summary\r\n\r\nChromium's modern Mojo IPC system represents a significant evolution from legacy IPC mechanisms, providing:\r\n\r\n- **Enhanced Security**: Capability-based access control and comprehensive validation\r\n- **Improved Performance**: Zero-copy transfers and intelligent message routing  \r\n- **Type Safety**: Strong typing through IDL-generated bindings\r\n- **Platform Consistency**: Unified API across all supported platforms\r\n- **Developer Experience**: Comprehensive debugging tools and documentation\r\n- **Future-Proof Architecture**: Extensible design for emerging web platform features\r\n\r\nThe transition to Mojo has enabled Chromium's sophisticated multi-process architecture while maintaining security, performance, and maintainability at scale. For developers working with Chromium, understanding Mojo IPC is essential for effective cross-process communication and service development."
  },
  {
    "path": "architecture/browser-components",
    "title": "Browser Components (Modern Architecture v134+)",
    "content": "# Browser Components (Modern Architecture v134+)\r\n\r\nThis article explores the major C++ components that comprise Chromium's **browser process** in v134+, showcasing the sophisticated service-oriented architecture that drives UI, navigation, security, and cross-process coordination. Understanding these components is essential for grasping how modern Chromium boots up, manages tabs, and orchestrates its multi-process ecosystem.\r\n\r\n---\r\n\r\n## 1. Modern High-Level Architecture (v134+)\r\n\r\n> **Service-Oriented Multi-Process Design**  \r\n> The browser process serves as the central coordinator, managing UI, security policies, and service orchestration while delegating specialized work to dedicated service processes.\r\n\r\n```text\r\n┌─────────────────┐    Mojo IPC    ┌──────────────────┐\r\n│ Browser Process │ ◄─────────────► │ Renderer Process │\r\n│                 │                │                  │\r\n│ ┌─────────────┐ │                │ ┌──────────────┐ │\r\n│ │ UI Manager  │ │                │ │ Blink Engine │ │\r\n│ │ Service Mgr │ │                │ │ V8 Engine    │ │\r\n│ │ Security    │ │                │ │ DOM/Layout   │ │\r\n│ └─────────────┘ │                │ └──────────────┘ │\r\n└─────────────────┘                └──────────────────┘\r\n         │ Mojo                               │\r\n         ▼                                    ▼\r\n┌─────────────────┐                ┌──────────────────┐\r\n│ Service         │                │ GPU Process      │\r\n│ Ecosystem       │                │                  │\r\n│                 │                │ ┌──────────────┐ │\r\n│ • Network       │                │ │ Viz Display  │ │\r\n│ • Audio         │                │ │ Compositor   │ │\r\n│ • Storage       │                │ │ OOP-R        │ │\r\n│ • ML/AI         │                │ └──────────────┘ │\r\n│ • Device        │                └──────────────────┘\r\n└─────────────────┘\r\n```\r\n\r\n**Modern Component Locations**: `src/chrome/`, `src/content/`, `src/services/`, `src/components/`, `src/ui/`\r\n\r\n---\r\n\r\n## 2. Modern Application Startup (v134+ Enhanced)\r\n\r\n### BrowserMain (Enhanced)\r\n- **Entry Point**: `chrome/app/chrome_main_delegate.cc`\r\n- **Advanced Initialization**:\r\n  - **Crashpad Integration**: Modern crash reporting with detailed telemetry\r\n  - **Feature Flag Management**: Runtime feature control with A/B testing support\r\n  - **Service Manager Bootstrap**: Early service discovery and connection\r\n  - **Security Policy Setup**: Site isolation and sandbox configuration\r\n\r\n### ProfileManager (Modern Multi-Profile)\r\n- **Enhanced Profile Loading**: `chrome/browser/profiles/profile_manager.cc`\r\n- **Modern Features**:\r\n  - **Multi-Profile Support**: Independent profile isolation with shared services\r\n  - **Profile Metrics**: Advanced usage analytics and performance tracking\r\n  - **Guest Mode**: Ephemeral browsing with complete isolation\r\n  - **Incognito Enhancement**: Improved privacy with service isolation\r\n\r\n### BrowserProcessImpl (Service Coordinator)\r\n- **Global Service Management**: `chrome/browser/browser_process_impl.cc`\r\n- **Core Services (v134+)**:\r\n  - **PrefService**: Advanced settings with cloud sync\r\n  - **DownloadService**: Modern download management with resumption\r\n  - **HistoryService**: Enhanced history with machine learning insights\r\n  - **SafeBrowsingService**: Real-time threat detection and response\r\n  - **NotificationService**: Cross-platform notification management\r\n\r\n### UI Loop (Platform-Optimized)\r\n- **BrowserWindow Management**: Native window integration per platform\r\n- **Event Loop Integration**: High-performance message pump with priority scheduling\r\n- **Input Handling**: Advanced touch, pen, and gesture support\r\n- **Accessibility**: Modern accessibility tree with cross-process coordination\r\n\r\n---\r\n\r\n## 3. Advanced Tab & Window Management (v134+)\r\n\r\n### TabStripModel (Enhanced)\r\n- **Location**: `chrome/browser/ui/tabs/tab_strip_model.cc`\r\n- **Modern Features**:\r\n  - **Tab Groups**: Visual and functional tab organization\r\n  - **Tab Search**: Intelligent tab discovery and management\r\n  - **Tab Freezing**: Memory optimization with intelligent tab lifecycle\r\n  - **Tab Restore**: Enhanced session restoration with state preservation\r\n\r\n### Browser (Multi-Window Coordinator)\r\n- **Location**: `chrome/browser/ui/browser.cc`\r\n- **Enhanced Capabilities**:\r\n  - **Command Routing**: Advanced action delegation with extension support\r\n  - **Window State Management**: Multi-monitor support with DPI awareness\r\n  - **Keyboard Shortcuts**: Configurable shortcuts with accessibility support\r\n  - **Context Menus**: Dynamic context-aware menu generation\r\n\r\n### WebContents (Content Host)\r\n- **Modern WebContents**: Enhanced content lifecycle management\r\n- **Key Features**:\r\n  - **Site Isolation**: Per-origin process boundaries\r\n  - **Navigation Prediction**: Preloading and speculative navigation\r\n  - **Resource Management**: Intelligent memory and CPU allocation\r\n  - **Security Boundaries**: Enhanced cross-origin protection\r\n\r\n---\r\n\r\n## 4. Modern Navigation & Session Management (v134+)\r\n\r\n### NavigationController (Enhanced)\r\n- **Advanced History Management**: Machine learning-powered navigation prediction\r\n- **Features**:\r\n  - **Back-Forward Cache**: Instant navigation with preserved state\r\n  - **Navigation Timing**: Performance metrics and optimization\r\n  - **Session Restoration**: Robust crash recovery with state preservation\r\n  - **Cross-Process Navigation**: Seamless site isolation boundaries\r\n\r\n### NavigationRequest (Modern Navigation)\r\n- **Location**: `content/browser/loader/navigation_request.cc`\r\n- **Enhanced Flow**:\r\n  - **Navigation Prediction**: Preemptive DNS resolution and connection setup\r\n  - **Security Checks**: Comprehensive security policy validation\r\n  - **Performance Optimization**: Resource prioritization and loading strategies\r\n  - **Error Handling**: Graceful degradation and recovery mechanisms\r\n\r\n### SessionService (Advanced Persistence)\r\n- **Modern Session Management**: Cloud sync integration with local fallback\r\n- **Features**:\r\n  - **Tab Groups Persistence**: Restore tab organization and grouping\r\n  - **Window Layout Restore**: Multi-monitor configuration preservation\r\n  - **Crash Recovery**: Intelligent state restoration with data validation\r\n  - **Privacy-Aware Storage**: Encrypted session data with user consent\r\n\r\n---\r\n\r\n## 5. Service-Oriented Networking & Resource Loading (v134+)\r\n\r\n### Network Service (Standalone Process)\r\n- **Location**: `services/network/`\r\n- **Modern Architecture**:\r\n  - **Process Isolation**: Dedicated network process for enhanced security\r\n  - **HTTP/3 Support**: QUIC protocol implementation with performance optimization\r\n  - **Connection Pooling**: Intelligent connection reuse and load balancing\r\n  - **Certificate Transparency**: Enhanced security with CT log validation\r\n\r\n### URLLoaderFactory (Mojo-Based)\r\n- **Type-Safe Interfaces**: Mojom-defined network request APIs\r\n- **Features**:\r\n  - **Request Prioritization**: Critical resource path optimization\r\n  - **CORS Enforcement**: Strict cross-origin security policy\r\n  - **Content Security Policy**: Advanced CSP validation and reporting\r\n  - **Performance Budgets**: Resource loading limits and throttling\r\n\r\n### ResourceScheduler (Intelligent Management)\r\n- **Advanced Scheduling**: Machine learning-powered resource prioritization\r\n- **Modern Features**:\r\n  - **Core Web Vitals**: Optimization for LCP, FID, and CLS metrics\r\n  - **Background Tab Throttling**: Aggressive resource management for inactive tabs\r\n  - **Network Quality Adaptation**: Dynamic quality adjustment based on connection\r\n  - **Predictive Loading**: Speculative resource loading based on user behavior\r\n\r\n---\r\n\r\n## 6. Modern Storage & State Management (v134+)\r\n\r\n### Profile (Enhanced User Data)\r\n- **Location**: `chrome/browser/profiles/profile.cc`\r\n- **Modern Features**:\r\n  - **Storage Partitioning**: Advanced isolation with per-origin boundaries\r\n  - **Quota Management**: Intelligent storage allocation with user control\r\n  - **Cloud Sync Integration**: Seamless cross-device data synchronization\r\n  - **Privacy Controls**: Granular user control over data storage and sharing\r\n\r\n### Storage Service (Dedicated Process)\r\n- **Process Isolation**: Dedicated storage process for enhanced security\r\n- **Modern Storage APIs**:\r\n  - **Origin Private File System**: Secure file system access for web apps\r\n  - **Persistent Storage**: Enhanced quota management with user prompts\r\n  - **IndexedDB v3**: Performance improvements with better transaction handling\r\n  - **Cache API**: Advanced caching with intelligent eviction policies\r\n\r\n### CookieManager (Mojo-Based)\r\n- **Location**: `services/network/cookie_manager/`\r\n- **Enhanced Features**:\r\n  - **SameSite Enforcement**: Strict SameSite cookie policy enforcement\r\n  - **Secure Cookies**: Enhanced security with automatic HTTPS upgrades\r\n  - **Privacy Sandbox**: Cookie alternatives with Topics API integration\r\n  - **Cross-Site Tracking Prevention**: Advanced tracking protection mechanisms\r\n\r\n---\r\n\r\n## 7. Modern UI Layer Architecture (v134+)\r\n\r\n### BrowserView/BrowserFrame (Cross-Platform)\r\n- **Enhanced UI Framework**: Modern views system with accessibility support\r\n- **Platform Integration**:\r\n  - **Windows**: WinUI 3 integration with modern styling\r\n  - **macOS**: SwiftUI bridge with native appearance\r\n  - **Linux**: GTK4 integration with Wayland support\r\n  - **Chrome OS**: Enhanced integration with system UI\r\n\r\n### Omnibox (Intelligent Address Bar)\r\n- **Location**: `chrome/browser/ui/omnibox/`\r\n- **Modern Features**:\r\n  - **Machine Learning Suggestions**: AI-powered search and navigation suggestions\r\n  - **Voice Input**: Advanced speech recognition with privacy protection\r\n  - **Visual Search**: Image-based search capabilities\r\n  - **Enhanced Autocomplete**: Context-aware suggestions with user learning\r\n\r\n### Modern Toolbar & UI Elements\r\n- **Material Design 3**: Latest design system implementation\r\n- **Features**:\r\n  - **Dynamic Theming**: Automatic color adaptation and user customization\r\n  - **Responsive Design**: Adaptive UI for different screen sizes and orientations\r\n  - **Gesture Support**: Advanced touch and pen input handling\r\n  - **Accessibility**: Comprehensive screen reader and keyboard navigation support\r\n\r\n---\r\n\r\n## 8. Enhanced Extensions & Modern Plugin Architecture (v134+)\r\n\r\n### Extension System (Manifest V3)\r\n- **Location**: `extensions/`\r\n- **Modern Security Model**:\r\n  - **Service Workers**: Background script replacement with enhanced lifecycle\r\n  - **Host Permissions**: Granular permission model with user control\r\n  - **Content Security Policy**: Strict CSP enforcement for extension security\r\n  - **Cross-Origin Isolation**: Enhanced security boundaries for extension content\r\n\r\n### Modern Web Platform APIs\r\n- **WebAssembly Integration**: Enhanced WASM support with SIMD and threading\r\n- **Features**:\r\n  - **Origin Private File System**: Secure file access for web applications\r\n  - **Web Locks**: Cross-tab coordination and resource management\r\n  - **Background Sync**: Reliable background task execution\r\n  - **Push Notifications**: Enhanced notification system with user control\r\n\r\n---\r\n\r\n## 9. Advanced Security & Sandboxing (v134+)\r\n\r\n### Site Isolation (Enhanced)\r\n- **Origin Agent Clusters**: Fine-grained process allocation for related origins\r\n- **Modern Features**:\r\n  - **Cross-Origin Isolation**: Enhanced protection against Spectre-style attacks\r\n  - **COOP/COEP**: Cross-Origin Opener/Embedder Policy enforcement\r\n  - **Trusted Types**: XSS prevention through API design\r\n  - **Feature Policy**: Granular control over powerful web platform features\r\n\r\n### Permission Model (User-Centric)\r\n- **Enhanced Permission UI**: `chrome/browser/permissions/`\r\n- **Modern Features**:\r\n  - **Permission Delegation**: Iframe permission inheritance\r\n  - **Temporary Permissions**: Time-based permission grants\r\n  - **Privacy Indicators**: Clear visual feedback for active permissions\r\n  - **Bulk Permission Management**: Easy review and modification of granted permissions\r\n\r\n### Safe Browsing (AI-Enhanced)\r\n- **Location**: `components/safe_browsing/`\r\n- **Advanced Protection**:\r\n  - **Real-Time Protection**: Cloud-based threat detection with local fallback\r\n  - **Machine Learning**: AI-powered phishing and malware detection\r\n  - **Enhanced Downloads**: Comprehensive file scanning and validation\r\n  - **Password Protection**: Breach detection and secure password management\r\n\r\n---\r\n\r\n## 10. Modern Diagnostics & Performance Management (v134+)\r\n\r\n### PerformanceManager (System-Wide)\r\n- **Location**: `chrome/browser/performance_manager/`\r\n- **Advanced Monitoring**:\r\n  - **Resource Attribution**: Precise tracking of CPU, memory, and network usage\r\n  - **Tab Lifecycle Management**: Intelligent freezing and discarding policies\r\n  - **Performance Budgets**: Real-time performance constraint enforcement\r\n  - **Core Web Vitals**: Automatic measurement and optimization recommendations\r\n\r\n### TaskManager (Enhanced Visibility)\r\n- **Modern Process Monitoring**: Real-time resource usage with detailed attribution\r\n- **Features**:\r\n  - **Service Process Tracking**: Visibility into all service processes\r\n  - **GPU Process Monitoring**: Graphics performance and memory usage\r\n  - **Network Activity**: Real-time network usage by process and site\r\n  - **Extension Impact**: Per-extension resource usage analysis\r\n\r\n### Modern Tracing & Analytics\r\n- **Chrome DevTools Protocol**: Enhanced debugging capabilities\r\n- **Features**:\r\n  - **Performance Timeline**: Detailed frame-by-frame analysis\r\n  - **Memory Profiling**: Advanced heap analysis with leak detection\r\n  - **Network Waterfall**: Comprehensive request timing and optimization\r\n  - **Core Web Vitals**: Real-time performance metric tracking\r\n\r\n---\r\n\r\n## 11. Emerging Technologies & Future Directions (v134+)\r\n\r\n### AI/ML Integration\r\n- **On-Device ML**: Privacy-preserving machine learning with TensorFlow Lite\r\n- **Features**:\r\n  - **Smart Suggestions**: AI-powered browsing assistance\r\n  - **Content Understanding**: Enhanced accessibility and summarization\r\n  - **Threat Detection**: Local malware and phishing detection\r\n  - **Performance Optimization**: Predictive resource management\r\n\r\n### Privacy Sandbox\r\n- **Location**: `components/privacy_sandbox/`\r\n- **Privacy-First Technologies**:\r\n  - **Topics API**: Interest-based advertising without cross-site tracking\r\n  - **FLEDGE**: Remarketing with privacy protection\r\n  - **Attribution Reporting**: Conversion measurement with differential privacy\r\n  - **Trust Tokens**: Anti-fraud without fingerprinting\r\n\r\n### WebGPU & Advanced Graphics\r\n- **Modern Graphics Pipeline**: Next-generation graphics API support\r\n- **Features**:\r\n  - **Compute Shaders**: General-purpose GPU computing for web applications\r\n  - **Advanced Rendering**: Modern graphics techniques with low-level access\r\n  - **AI Acceleration**: GPU-accelerated machine learning for web apps\r\n  - **Cross-Platform Consistency**: Unified graphics API across all platforms\r\n\r\n---\r\n\r\n## 12. Next Steps & Architecture Deep Dives\r\n\r\n### Essential Reading\r\n- **[Process Model](process-model.md)**: Detailed multi-process architecture and security boundaries\r\n- **[IPC Internals](ipc-internals.md)**: Modern Mojo communication patterns and service interfaces\r\n- **[Render Pipeline](render-pipeline.md)**: How browser and renderer coordinate for frame construction\r\n\r\n### Advanced Topics\r\n- **[Security Model](../security/security-model.md)**: Comprehensive security architecture and threat model\r\n- **[Networking Internals](../modules/networking-http.md)**: Deep dive into modern network stack\r\n- **[Storage Architecture](../modules/storage-cache.md)**: Advanced storage systems and privacy controls\r\n\r\n### Development Resources\r\n```bash\r\n# Explore browser component source code\r\ncd src/chrome/browser/        # Browser-specific components\r\ncd src/content/browser/       # Cross-platform browser foundation\r\ncd src/services/              # Modern service architecture\r\ncd src/components/            # Shared component library\r\n\r\n# Debug browser components\r\nchrome://components/          # Component status and versions\r\nchrome://process-internals/   # Process and service monitoring\r\nchrome://system/              # Comprehensive system information\r\n```\r\n\r\n---\r\n\r\n**End of Modern Browser Components Guide**\r\n\r\n### Key Evolution in v134+\r\n- **Service-Oriented Architecture**: Microservice design with Mojo IPC\r\n- **Enhanced Security**: Advanced site isolation and privacy protection\r\n- **Performance Optimization**: AI-powered resource management and Core Web Vitals focus\r\n- **Modern UI Framework**: Material Design 3 with cross-platform consistency\r\n- **Privacy-First Design**: Privacy Sandbox integration and user control\r\n\r\n**Notes for Developers:**\r\n- Browser components are increasingly service-oriented - understand Mojo interfaces\r\n- Security boundaries are fundamental to architecture - respect process isolation\r\n- Performance is measured through Core Web Vitals - optimize for user experience\r\n- Privacy is paramount - implement privacy-by-design principles\r\n- Accessibility is essential - ensure inclusive design from the ground up\r\n"
  },
  {
    "path": "architecture/security/sandbox-architecture",
    "title": "Sandbox Architecture in Chromium v134+",
    "content": "# Sandbox Architecture in Chromium v134+\r\n\r\nModern Chromium's sandbox architecture represents one of the most sophisticated security systems in contemporary software engineering. The v134+ sandbox provides comprehensive isolation through multiple defense layers, process-based security boundaries, and platform-specific mitigations that protect against both known and emerging threats.\r\n\r\n---\r\n\r\n## 1. Modern Sandbox Architecture Overview (v134+)\r\n\r\n### Core Security Principles\r\n\r\n1. **Defense in Depth**: Multiple independent security layers that fail safely\r\n2. **Principle of Least Privilege**: Processes receive minimal necessary permissions\r\n3. **Process Isolation**: Strong boundaries between browser components\r\n4. **Capability-Based Security**: Explicit permission grants for specific operations\r\n5. **Zero-Trust Architecture**: Assume all untrusted code is potentially malicious\r\n\r\n### Multi-Layered Security Model\r\n\r\n```text\r\n┌─────────────────────────────────────────────────────────────┐\r\n│                    Browser Process (Privileged)             │\r\n│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │\r\n│  │   UI Process    │  │ Network Service │  │ GPU Process │ │\r\n│  └─────────────────┘  └─────────────────┘  └─────────────┘ │\r\n└─────────────────────────────┬───────────────────────────────┘\r\n                              │ Mojo IPC (Capability-Based)\r\n┌─────────────────────────────┴───────────────────────────────┐\r\n│                 Sandboxed Processes (Restricted)            │\r\n│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │\r\n│  │ Renderer Process│  │ Utility Process │  │ Plugin Host │ │\r\n│  │  (Site Isolated)│  │   (Sandboxed)   │  │ (Deprecated)│ │\r\n│  └─────────────────┘  └─────────────────┘  └─────────────┘ │\r\n└─────────────────────────────────────────────────────────────┘\r\n```\r\n\r\n### Modern Sandbox Components (v134+)\r\n\r\n- **Multi-Process Architecture**: Process-per-site isolation with security boundaries\r\n- **Mojo IPC System**: Type-safe, capability-based inter-process communication\r\n- **Site Isolation**: Per-origin process boundaries for enhanced security\r\n- **Control Flow Integrity (CFI)**: Hardware-assisted exploit mitigation\r\n- **Privacy Sandbox Integration**: Isolated execution contexts for privacy features\r\n- **Advanced Mitigations**: Platform-specific exploit prevention mechanisms\r\n\r\n---\r\n\r\n## 2. Cross-Platform Sandbox Implementation\r\n\r\n### Windows Sandbox (v134+)\r\n\r\n#### Core Windows Security Mechanisms\r\n\r\n```cpp\r\n// Modern Windows sandbox configuration\r\nnamespace sandbox {\r\n\r\nclass WindowsSandboxPolicy {\r\n public:\r\n  // Enhanced token restrictions for v134+\r\n  enum class TokenLevel {\r\n    kRestrictedToken = 0,           // Highly restricted, minimal SIDs\r\n    kLockDownToken,                 // Maximum restrictions, site isolation\r\n    kInteractiveToken,              // Limited UI interactions\r\n    kUnrestrictedToken              // Full user privileges (browser process)\r\n  };\r\n  \r\n  // Job object restrictions with modern mitigations\r\n  enum class JobLevel {\r\n    kLockdown = 0,                  // Maximum restrictions\r\n    kLimitedUser,                   // Standard renderer restrictions  \r\n    kInteractive,                   // UI process level\r\n    kUnprotected                    // No job restrictions\r\n  };\r\n  \r\n  // Integrity levels for mandatory access control\r\n  enum class IntegrityLevel {\r\n    kLow = 0,                       // Sandboxed processes\r\n    kMedium,                        // Standard user processes\r\n    kHigh,                          // Elevated processes\r\n    kSystem                         // System-level access\r\n  };\r\n\r\n  // Modern policy configuration\r\n  base::expected<void, SandboxError> ConfigurePolicy() {\r\n    // Set restrictive token with minimal privileges\r\n    if (auto result = SetTokenLevel(TokenLevel::kLockDownToken); !result.has_value()) {\r\n      return result;\r\n    }\r\n    \r\n    // Configure job object with enhanced restrictions\r\n    SetJobLevel(JobLevel::kLockdown);\r\n    \r\n    // Apply low integrity level for mandatory access control\r\n    SetIntegrityLevel(IntegrityLevel::kLow);\r\n    \r\n    // Enable modern Windows mitigations\r\n    EnableProcessMitigations();\r\n    \r\n    return base::ok();\r\n  }\r\n\r\n private:\r\n  void EnableProcessMitigations() {\r\n    // Control Flow Integrity (CFI)\r\n    EnableControlFlowGuard();\r\n    \r\n    // Return Flow Guard (RFG)\r\n    EnableReturnFlowGuard();\r\n    \r\n    // Arbitrary Code Guard (ACG)\r\n    EnableArbitraryCodeGuard();\r\n    \r\n    // Hardware Stack Protection (Intel CET)\r\n    EnableHardwareStackProtection();\r\n    \r\n    // Process creation restrictions\r\n    RestrictChildProcessCreation();\r\n  }\r\n};\r\n\r\n}  // namespace sandbox\r\n```\r\n\r\n#### Windows-Specific Mitigations\r\n\r\n**Advanced Exploit Mitigations**:\r\n- **Control Flow Integrity (CFI)**: Hardware-assisted ROP/JOP prevention\r\n- **Return Flow Guard (RFG)**: Return address validation\r\n- **Arbitrary Code Guard (ACG)**: Dynamic code prevention\r\n- **Hardware Enforcement**: Intel CET and ARM Pointer Authentication support\r\n\r\n**Process Isolation Enhancements**:\r\n- **Win32k Lockdown**: Kernel attack surface reduction\r\n- **Low-Box Tokens**: AppContainer isolation with capability restrictions\r\n- **Image Load Restrictions**: Preventing malicious DLL injection\r\n- **Font Loading Restrictions**: Reducing GDI attack surface\r\n\r\n### Linux Sandbox (v134+)\r\n\r\n#### Modern Linux Security Architecture\r\n\r\n```cpp\r\n// Linux sandbox implementation with advanced features\r\nnamespace sandbox {\r\n\r\nclass LinuxSandboxPolicy {\r\n public:\r\n  // Comprehensive Linux sandbox setup\r\n  base::expected<void, SandboxError> Initialize() {\r\n    // Set up namespace isolation\r\n    if (auto result = SetupNamespaces(); !result.has_value()) {\r\n      return result;\r\n    }\r\n    \r\n    // Configure seccomp-bpf filters\r\n    if (auto result = ApplySeccompFilters(); !result.has_value()) {\r\n      return result;\r\n    }\r\n    \r\n    // Apply LSM (SELinux/AppArmor) policies\r\n    if (auto result = ConfigureLSM(); !result.has_value()) {\r\n      return result;\r\n    }\r\n    \r\n    // Enable modern mitigations\r\n    EnableLinuxMitigations();\r\n    \r\n    return base::ok();\r\n  }\r\n\r\n private:\r\n  base::expected<void, SandboxError> SetupNamespaces() {\r\n    // PID namespace for process isolation\r\n    CreateNamespace(CLONE_NEWPID);\r\n    \r\n    // Network namespace for network isolation\r\n    CreateNamespace(CLONE_NEWNET);\r\n    \r\n    // Mount namespace for filesystem isolation\r\n    CreateNamespace(CLONE_NEWNS);\r\n    \r\n    // User namespace for privilege separation\r\n    CreateNamespace(CLONE_NEWUSER);\r\n    \r\n    // IPC namespace for System V IPC isolation\r\n    CreateNamespace(CLONE_NEWIPC);\r\n    \r\n    return base::ok();\r\n  }\r\n  \r\n  base::expected<void, SandboxError> ApplySeccompFilters() {\r\n    // Create comprehensive syscall filter\r\n    SyscallFilter filter;\r\n    \r\n    // Allow essential syscalls\r\n    filter.Allow(SYS_read);\r\n    filter.Allow(SYS_write);\r\n    filter.Allow(SYS_mmap);\r\n    filter.Allow(SYS_munmap);\r\n    \r\n    // Block dangerous syscalls\r\n    filter.Block(SYS_execve);\r\n    filter.Block(SYS_ptrace);\r\n    filter.Block(SYS_setuid);\r\n    filter.Block(SYS_setgid);\r\n    \r\n    // Apply conditional rules for IPC\r\n    filter.AllowIf(SYS_sendmsg, IsValidMojoIPC);\r\n    filter.AllowIf(SYS_recvmsg, IsValidMojoIPC);\r\n    \r\n    return filter.Apply();\r\n  }\r\n  \r\n  void EnableLinuxMitigations() {\r\n    // Stack canaries and FORTIFY_SOURCE\r\n    EnableStackProtection();\r\n    \r\n    // ASLR with enhanced entropy\r\n    EnableAddressSpaceRandomization();\r\n    \r\n    // Control Flow Integrity (if supported)\r\n    EnableControlFlowIntegrity();\r\n    \r\n    // Memory tagging (ARM64 MTE)\r\n    EnableMemoryTagging();\r\n  }\r\n};\r\n\r\n}  // namespace sandbox\r\n```\r\n\r\n#### Linux Security Features\r\n\r\n**Namespace Isolation**:\r\n- **PID Namespaces**: Process tree isolation\r\n- **Network Namespaces**: Network stack isolation  \r\n- **Mount Namespaces**: Filesystem view isolation\r\n- **User Namespaces**: UID/GID mapping and privilege isolation\r\n\r\n**Seccomp-BPF Filtering**:\r\n- **Fine-grained Syscall Control**: Allowlist-based syscall filtering\r\n- **Dynamic Policy Updates**: Runtime policy modifications for different phases\r\n- **Performance Optimization**: BPF JIT compilation for filter efficiency\r\n\r\n**Linux Security Modules (LSM)**:\r\n- **SELinux Integration**: Mandatory Access Control with type enforcement\r\n- **AppArmor Support**: Path-based access control\r\n- **Custom Policies**: Chromium-specific security policies\r\n\r\n### macOS Sandbox (v134+)\r\n\r\n#### Advanced macOS Security Integration\r\n\r\n```cpp\r\n// macOS sandbox with modern security features\r\nnamespace sandbox {\r\n\r\nclass MacOSSandboxPolicy {\r\n public:\r\n  base::expected<void, SandboxError> ConfigureMacOSSandbox() {\r\n    // Apply App Sandbox with minimal entitlements\r\n    if (auto result = ApplyAppSandbox(); !result.has_value()) {\r\n      return result;\r\n    }\r\n    \r\n    // Configure System Integrity Protection (SIP) awareness\r\n    ConfigureSIPCompliance();\r\n    \r\n    // Apply Hardened Runtime features\r\n    EnableHardenedRuntime();\r\n    \r\n    // Configure Gatekeeper compatibility\r\n    ConfigureGatekeeper();\r\n    \r\n    return base::ok();\r\n  }\r\n\r\n private:\r\n  base::expected<void, SandboxError> ApplyAppSandbox() {\r\n    // Minimal sandbox profile for renderer processes\r\n    const char* sandbox_profile = R\"(\r\n      (version 1)\r\n      (deny default)\r\n      \r\n      ; Allow basic system operations\r\n      (allow process-exec (literal \"/usr/lib/dyld\"))\r\n      (allow file-read* (literal \"/System/Library/Frameworks\"))\r\n      (allow file-read* (literal \"/usr/lib\"))\r\n      \r\n      ; Mojo IPC permissions\r\n      (allow mach-lookup (global-name \"org.chromium.Chromium.mojo.*\"))\r\n      (allow file-read* file-write* (regex #\"^/tmp/\\.org\\.chromium\\.Chromium\\.\"))\r\n      \r\n      ; Deny dangerous operations\r\n      (deny process-fork)\r\n      (deny process-exec)\r\n      (deny network-outbound)\r\n      (deny file-write* (regex #\"^/\"))\r\n    )\";\r\n    \r\n    return ApplySandboxProfile(sandbox_profile);\r\n  }\r\n  \r\n  void EnableHardenedRuntime() {\r\n    // Disable dangerous features\r\n    DisableExecutableMemory();\r\n    DisableDynamicCodeSigning();\r\n    DisableJITCompilation();\r\n    \r\n    // Enable security features\r\n    EnableLibraryValidation();\r\n    EnableSystemIntegrityProtection();\r\n  }\r\n};\r\n\r\n}  // namespace sandbox\r\n```\r\n\r\n#### macOS Security Features\r\n\r\n**App Sandbox**:\r\n- **Containerization**: Application-level isolation with minimal entitlements\r\n- **Resource Access Control**: File system and network access restrictions\r\n- **IPC Restrictions**: Limited inter-process communication capabilities\r\n\r\n**Hardened Runtime**:\r\n- **Code Signing Enforcement**: Strict validation of all loaded code\r\n- **JIT Restrictions**: Just-in-time compilation limitations\r\n- **Memory Protection**: Enhanced memory layout randomization\r\n\r\n**System Integration**:\r\n- **System Integrity Protection (SIP)**: System file and process protection\r\n- **Gatekeeper**: Code signing and notarization requirements\r\n- **XProtect**: Built-in malware detection integration\r\n\r\n---\r\n\r\n## 3. Site Isolation and Process Security\r\n\r\n### Site Isolation Architecture (v134+)\r\n\r\n```cpp\r\n// Modern site isolation with enhanced security\r\nnamespace content {\r\n\r\nclass SiteIsolationPolicy {\r\n public:\r\n  // Enhanced site isolation for v134+\r\n  enum class IsolationLevel {\r\n    kStrictSiteIsolation,           // Per-origin process isolation\r\n    kPartialSiteIsolation,          // High-value site isolation  \r\n    kProcessPerSiteInstance,        // Traditional site isolation\r\n    kSingleProcess                  // Debugging only (insecure)\r\n  };\r\n\r\n  // Configure site isolation based on security requirements\r\n  static void ConfigureIsolation(IsolationLevel level) {\r\n    switch (level) {\r\n      case IsolationLevel::kStrictSiteIsolation:\r\n        EnableStrictSiteIsolation();\r\n        EnableOriginAgentClusterIsolation();\r\n        EnableCrossOriginEmbedderPolicyIsolation();\r\n        break;\r\n        \r\n      case IsolationLevel::kPartialSiteIsolation:\r\n        EnableHighValueSiteIsolation();\r\n        EnablePasswordSiteIsolation();\r\n        break;\r\n        \r\n      default:\r\n        EnableDefaultSiteIsolation();\r\n    }\r\n  }\r\n\r\n private:\r\n  static void EnableStrictSiteIsolation() {\r\n    // Every origin gets its own process\r\n    SiteInstance::EnableStrictSiteIsolation();\r\n    \r\n    // Enhanced cross-origin read blocking (CORB)\r\n    EnableStrictCORB();\r\n    \r\n    // Out-of-process iframe isolation\r\n    EnableOOPIFIsolation();\r\n    \r\n    // Spectre mitigations\r\n    EnableSpectreV1Mitigations();\r\n    EnableSpectreV2Mitigations();\r\n  }\r\n};\r\n\r\n}  // namespace content\r\n```\r\n\r\n### Process Security Boundaries\r\n\r\n**Renderer Process Isolation**:\r\n- **Per-Site Process Allocation**: Separate processes for different origins\r\n- **Cross-Origin Read Blocking (CORB)**: Preventing cross-origin data leaks\r\n- **Out-of-Process iframes (OOPIF)**: Iframe isolation with separate processes\r\n- **Spectre Mitigations**: Side-channel attack prevention\r\n\r\n**Security Policy Enforcement**:\r\n- **Content Security Policy (CSP)**: Browser-enforced content restrictions\r\n- **Cross-Origin Embedder Policy (COEP)**: Embedding permission control\r\n- **Cross-Origin Opener Policy (COOP)**: Window reference isolation\r\n- **Same-Site Cookie Enforcement**: Cross-site request forgery prevention\r\n\r\n---\r\n\r\n## 4. Mojo IPC Security Model\r\n\r\n### Capability-Based IPC System\r\n\r\n```cpp\r\n// Modern Mojo IPC with enhanced security\r\nnamespace mojo {\r\n\r\n// Capability-based service interface\r\ninterface SecureService {\r\n  // Capability tokens for access control\r\n  struct ServiceCapability {\r\n    string capability_name;\r\n    array<uint8> capability_token;\r\n    uint64 expiration_time;\r\n    array<string> allowed_origins;\r\n  };\r\n\r\n  // Secure method invocation with capability checking\r\n  PerformSecureOperation(ServiceCapability capability, \r\n                        SecureOperationRequest request) \r\n      => (SecureOperationResponse response);\r\n  \r\n  // Capability delegation with restrictions\r\n  DelegateCapability(ServiceCapability parent_capability,\r\n                    CapabilityRestrictions restrictions)\r\n      => (ServiceCapability? delegated_capability);\r\n};\r\n\r\n// Enhanced IPC security validation\r\nclass MojoSecurityValidator {\r\n public:\r\n  // Validate capability before method invocation\r\n  base::expected<void, SecurityError> ValidateCapability(\r\n      const ServiceCapability& capability,\r\n      const url::Origin& requesting_origin) {\r\n    \r\n    // Check capability expiration\r\n    if (IsExpired(capability)) {\r\n      return base::unexpected(SecurityError::kCapabilityExpired);\r\n    }\r\n    \r\n    // Validate origin permissions\r\n    if (!IsOriginAllowed(capability, requesting_origin)) {\r\n      return base::unexpected(SecurityError::kOriginNotAllowed);\r\n    }\r\n    \r\n    // Verify capability token authenticity\r\n    if (!VerifyCapabilityToken(capability)) {\r\n      return base::unexpected(SecurityError::kInvalidToken);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n\r\n private:\r\n  bool VerifyCapabilityToken(const ServiceCapability& capability) {\r\n    // Cryptographic verification of capability tokens\r\n    return crypto::VerifySignature(capability.capability_token, \r\n                                  capability_signing_key_);\r\n  }\r\n  \r\n  crypto::SigningKey capability_signing_key_;\r\n};\r\n\r\n}  // namespace mojo\r\n```\r\n\r\n### IPC Security Features\r\n\r\n**Capability-Based Access Control**:\r\n- **Explicit Permission Grants**: Services require specific capabilities\r\n- **Token-Based Authentication**: Cryptographically secure capability tokens\r\n- **Origin-Based Restrictions**: Fine-grained origin permission control\r\n- **Temporal Access Control**: Time-limited capability expiration\r\n\r\n**Message Validation and Filtering**:\r\n- **Type-Safe Serialization**: Automatic memory safety in IPC messages\r\n- **Message Size Limits**: Prevention of resource exhaustion attacks\r\n- **Rate Limiting**: Throttling to prevent IPC flooding\r\n- **Content Validation**: Schema-based message validation\r\n\r\n---\r\n\r\n## 5. Privacy Sandbox Security Integration\r\n\r\n### Isolated Execution Contexts\r\n\r\n```cpp\r\n// Privacy Sandbox isolation with enhanced security\r\nnamespace privacy_sandbox {\r\n\r\nclass PrivacySandboxIsolation {\r\n public:\r\n  // Isolated execution environment for privacy features\r\n  struct IsolationContext {\r\n    std::string context_id;\r\n    url::Origin top_level_origin;\r\n    std::vector<url::Origin> allowed_origins;\r\n    base::TimeDelta max_execution_time;\r\n    size_t memory_limit_bytes;\r\n    bool network_access_allowed;\r\n  };\r\n\r\n  // Create isolated context for privacy computation\r\n  base::expected<IsolationContext, PrivacyError> CreateIsolatedContext(\r\n      const url::Origin& requesting_origin,\r\n      PrivacySandboxFeature feature) {\r\n    \r\n    // Validate origin permissions for privacy feature\r\n    if (!IsOriginAllowedForFeature(requesting_origin, feature)) {\r\n      return base::unexpected(PrivacyError::kOriginNotAllowed);\r\n    }\r\n    \r\n    IsolationContext context{\r\n      .context_id = GenerateContextId(),\r\n      .top_level_origin = requesting_origin,\r\n      .allowed_origins = GetAllowedOriginsForFeature(feature),\r\n      .max_execution_time = GetExecutionTimeLimitForFeature(feature),\r\n      .memory_limit_bytes = GetMemoryLimitForFeature(feature),\r\n      .network_access_allowed = IsNetworkAccessAllowedForFeature(feature)\r\n    };\r\n    \r\n    return context;\r\n  }\r\n\r\n  // Execute privacy computation in isolated environment\r\n  void ExecutePrivacyComputation(\r\n      const IsolationContext& context,\r\n      const std::string& computation_code,\r\n      base::OnceCallback<void(PrivacyComputationResult)> callback) {\r\n    \r\n    // Create isolated execution environment\r\n    auto isolated_env = CreateIsolatedV8Environment(context);\r\n    \r\n    // Apply resource limits\r\n    isolated_env->SetMemoryLimit(context.memory_limit_bytes);\r\n    isolated_env->SetExecutionTimeLimit(context.max_execution_time);\r\n    \r\n    // Disable dangerous APIs\r\n    isolated_env->DisableFileSystemAccess();\r\n    isolated_env->DisableNetworkAccess(!context.network_access_allowed);\r\n    isolated_env->DisableCrossOriginAccess();\r\n    \r\n    // Execute computation with monitoring\r\n    isolated_env->ExecuteScript(computation_code, std::move(callback));\r\n  }\r\n};\r\n\r\n}  // namespace privacy_sandbox\r\n```\r\n\r\n### Privacy Feature Security\r\n\r\n**Topics API Security**:\r\n- **Interest Group Isolation**: Separate processes for interest computation\r\n- **Differential Privacy**: Mathematical privacy guarantees\r\n- **Cross-Site Tracking Prevention**: Strong origin isolation\r\n- **Temporal Privacy Controls**: Interest decay and rotation\r\n\r\n**FLEDGE/Protected Audience Security**:\r\n- **Trusted Execution Environment**: Isolated auction computation\r\n- **Bidding Script Isolation**: Separate contexts for ad auction logic\r\n- **Cross-Site Data Minimization**: Limited cross-site information flow\r\n- **Cryptographic Privacy**: Secure aggregation of auction results\r\n\r\n---\r\n\r\n## 6. Modern Exploit Mitigations\r\n\r\n### Hardware-Assisted Security Features\r\n\r\n```cpp\r\n// Advanced exploit mitigations for v134+\r\nnamespace security {\r\n\r\nclass ExploitMitigations {\r\n public:\r\n  // Enable comprehensive exploit mitigations\r\n  static void EnableAllMitigations() {\r\n    // Control Flow Integrity\r\n    EnableControlFlowIntegrity();\r\n    \r\n    // Stack protection\r\n    EnableStackProtection();\r\n    \r\n    // Memory safety features\r\n    EnableMemorySafetyFeatures();\r\n    \r\n    // Hardware-specific mitigations\r\n    EnableHardwareMitigations();\r\n  }\r\n\r\n private:\r\n  static void EnableControlFlowIntegrity() {\r\n    // Intel CET (Control-flow Enforcement Technology)\r\n    if (cpu_info_.has_cet_support()) {\r\n      EnableIntelCET();\r\n    }\r\n    \r\n    // ARM Pointer Authentication\r\n    if (cpu_info_.has_pointer_auth()) {\r\n      EnableArmPointerAuth();\r\n    }\r\n    \r\n    // Software CFI for unsupported hardware\r\n    EnableSoftwareCFI();\r\n  }\r\n  \r\n  static void EnableMemorySafetyFeatures() {\r\n    // Memory tagging (ARM64 MTE)\r\n    if (cpu_info_.has_memory_tagging()) {\r\n      EnableMemoryTagging();\r\n    }\r\n    \r\n    // Address sanitizer integration\r\n    #if defined(ADDRESS_SANITIZER)\r\n    EnableAddressSanitizerIntegration();\r\n    #endif\r\n    \r\n    // Hardware shadow stack\r\n    if (cpu_info_.has_shadow_stack()) {\r\n      EnableHardwareShadowStack();\r\n    }\r\n  }\r\n  \r\n  static void EnableHardwareMitigations() {\r\n    // Intel MPX (Memory Protection Extensions) - deprecated but relevant\r\n    // SMEP/SMAP kernel protections\r\n    // Branch Target Identification (BTI) on ARM\r\n    // Load/Store Multiple restrictions\r\n    ConfigureHardwareProtections();\r\n  }\r\n};\r\n\r\n}  // namespace security\r\n```\r\n\r\n### Modern Mitigation Techniques\r\n\r\n**Control Flow Protection**:\r\n- **Intel CET**: Hardware-enforced control flow integrity\r\n- **ARM Pointer Authentication**: Cryptographic return address protection\r\n- **Branch Target Identification**: Valid jump target enforcement\r\n- **Return Address Signing**: Cryptographic stack integrity\r\n\r\n**Memory Protection**:\r\n- **ARM Memory Tagging (MTE)**: Hardware-assisted use-after-free detection\r\n- **Intel MPK**: Memory protection keys for fine-grained access control\r\n- **SMEP/SMAP**: Supervisor mode execution/access prevention\r\n- **Enhanced ASLR**: High-entropy address space randomization\r\n\r\n**Speculative Execution Mitigations**:\r\n- **Spectre v1/v2 Protections**: Bounds check bypass and branch target injection\r\n- **Microarchitectural Data Sampling (MDS)**: L1TF, ZombieLoad, RIDL mitigations\r\n- **Store Buffer Bypass**: SWAPGS and other variant protections\r\n- **Load Value Injection (LVI)**: Intel microcode and compiler mitigations\r\n\r\n---\r\n\r\n## 7. Sandbox Policy Configuration\r\n\r\n### Dynamic Policy Management\r\n\r\n```cpp\r\n// Dynamic sandbox policy configuration for v134+\r\nnamespace sandbox {\r\n\r\nclass DynamicPolicyManager {\r\n public:\r\n  // Policy templates for different process types\r\n  enum class ProcessType {\r\n    kRenderer,              // Web content renderer\r\n    kUtility,              // Utility processes\r\n    kGpu,                  // GPU process\r\n    kNetwork,              // Network service\r\n    kAudio,                // Audio service\r\n    kStorage,              // Storage service\r\n    kPrintCompositor,      // Print compositor\r\n    kPrivacySandbox        // Privacy Sandbox worklet\r\n  };\r\n\r\n  // Configure policy based on process type and security requirements\r\n  static std::unique_ptr<SandboxPolicy> CreatePolicy(\r\n      ProcessType process_type,\r\n      const SecurityRequirements& requirements) {\r\n    \r\n    auto policy = std::make_unique<SandboxPolicy>();\r\n    \r\n    switch (process_type) {\r\n      case ProcessType::kRenderer:\r\n        ConfigureRendererPolicy(*policy, requirements);\r\n        break;\r\n        \r\n      case ProcessType::kPrivacySandbox:\r\n        ConfigurePrivacySandboxPolicy(*policy, requirements);\r\n        break;\r\n        \r\n      case ProcessType::kUtility:\r\n        ConfigureUtilityPolicy(*policy, requirements);\r\n        break;\r\n        \r\n      default:\r\n        ConfigureDefaultPolicy(*policy, requirements);\r\n    }\r\n    \r\n    // Apply platform-specific enhancements\r\n    ApplyPlatformSpecificMitigations(*policy);\r\n    \r\n    return policy;\r\n  }\r\n\r\n private:\r\n  static void ConfigureRendererPolicy(SandboxPolicy& policy,\r\n                                     const SecurityRequirements& requirements) {\r\n    // Maximum restrictions for web content\r\n    policy.SetTokenLevel(TokenLevel::kLockdown);\r\n    policy.SetJobLevel(JobLevel::kLockdown);\r\n    policy.SetIntegrityLevel(IntegrityLevel::kLow);\r\n    \r\n    // File system access rules\r\n    policy.AddRule(SubSystem::kFiles, FileRule::kReadOnly,\r\n                  L\"${temp}\\\\chromium_renderer_*\");\r\n    \r\n    // Network restrictions (no direct network access)\r\n    policy.BlockNetworkAccess();\r\n    \r\n    // IPC permissions (only Mojo)\r\n    policy.AllowMojoIPC();\r\n    policy.BlockLegacyIPC();\r\n    \r\n    // Enhanced mitigations\r\n    policy.EnableControlFlowIntegrity();\r\n    policy.EnableArbitraryCodeGuard();\r\n    policy.EnableReturnFlowGuard();\r\n  }\r\n  \r\n  static void ConfigurePrivacySandboxPolicy(SandboxPolicy& policy,\r\n                                           const SecurityRequirements& requirements) {\r\n    // Extra-restrictive policy for privacy computations\r\n    ConfigureRendererPolicy(policy, requirements);\r\n    \r\n    // Additional privacy-specific restrictions\r\n    policy.BlockFileSystemAccess();\r\n    policy.BlockClipboardAccess();\r\n    policy.BlockScreenCapture();\r\n    \r\n    // Temporal restrictions\r\n    policy.SetMaxExecutionTime(base::Seconds(30));\r\n    policy.SetMemoryLimit(base::Megabytes(100));\r\n    \r\n    // Cryptographic isolation\r\n    policy.EnablePrivacyIsolation();\r\n  }\r\n};\r\n\r\n}  // namespace sandbox\r\n```\r\n\r\n### Policy Rule System\r\n\r\n**Resource Access Control**:\r\n- **File System Rules**: Path-based access control with pattern matching\r\n- **Registry Rules**: Windows registry access restrictions\r\n- **Network Rules**: Protocol and destination-based network controls\r\n- **IPC Rules**: Inter-process communication permission management\r\n\r\n**Dynamic Policy Updates**:\r\n- **Runtime Policy Modification**: Safe policy updates for running processes\r\n- **Feature-Based Policies**: Conditional rules based on enabled features\r\n- **Origin-Specific Rules**: Per-origin customization for enhanced security\r\n- **Experiment Integration**: A/B testing of security policy variations\r\n\r\n---\r\n\r\n## 8. Monitoring and Introspection\r\n\r\n### Security Event Monitoring\r\n\r\n```cpp\r\n// Comprehensive security monitoring for sandbox violations\r\nnamespace security {\r\n\r\nclass SandboxMonitor {\r\n public:\r\n  // Security event types for monitoring\r\n  enum class SecurityEvent {\r\n    kPolicyViolation,           // Sandbox policy violation attempt\r\n    kEscapeAttempt,            // Sandbox escape attempt detected\r\n    kUnauthorizedAccess,       // Access to restricted resource\r\n    kSuspiciousActivity,       // Anomalous behavior detected\r\n    kExploitMitigation,        // Exploit mitigation triggered\r\n    kCapabilityViolation       // Mojo capability violation\r\n  };\r\n\r\n  // Register security event handler\r\n  void RegisterEventHandler(\r\n      SecurityEvent event_type,\r\n      base::RepeatingCallback<void(const SecurityEventData&)> handler) {\r\n    event_handlers_[event_type].push_back(std::move(handler));\r\n  }\r\n\r\n  // Report security events with detailed context\r\n  void ReportSecurityEvent(SecurityEvent event_type,\r\n                          const SecurityEventData& event_data) {\r\n    // Log security event\r\n    LogSecurityEvent(event_type, event_data);\r\n    \r\n    // Update security metrics\r\n    UpdateSecurityMetrics(event_type);\r\n    \r\n    // Notify registered handlers\r\n    NotifyEventHandlers(event_type, event_data);\r\n    \r\n    // Take automatic response actions\r\n    TakeSecurityResponse(event_type, event_data);\r\n  }\r\n\r\n private:\r\n  void TakeSecurityResponse(SecurityEvent event_type,\r\n                           const SecurityEventData& event_data) {\r\n    switch (event_type) {\r\n      case SecurityEvent::kEscapeAttempt:\r\n        // Immediate process termination\r\n        TerminateCompromisedProcess(event_data.process_id);\r\n        break;\r\n        \r\n      case SecurityEvent::kPolicyViolation:\r\n        // Enhanced monitoring for process\r\n        EnableEnhancedMonitoring(event_data.process_id);\r\n        break;\r\n        \r\n      case SecurityEvent::kExploitMitigation:\r\n        // Report to security team\r\n        ReportToSecurityTeam(event_data);\r\n        break;\r\n    }\r\n  }\r\n  \r\n  std::map<SecurityEvent, std::vector<base::RepeatingCallback<void(const SecurityEventData&)>>> \r\n      event_handlers_;\r\n};\r\n\r\n}  // namespace security\r\n```\r\n\r\n### Debugging and Analysis Tools\r\n\r\n**Chrome Internals Integration**:\r\n- **chrome://sandbox/**: Real-time sandbox status and policy information\r\n- **chrome://process-internals/**: Process isolation and security boundary analysis\r\n- **chrome://security-state/**: Comprehensive security feature status\r\n- **chrome://policy-internals/**: Dynamic policy rule inspection\r\n\r\n**Advanced Debugging Features**:\r\n- **Sandbox Violation Logging**: Detailed logging of policy violations\r\n- **Performance Impact Analysis**: Security overhead measurement\r\n- **Security Metrics Dashboard**: Real-time security health monitoring\r\n- **Exploit Detection Telemetry**: Automatic exploit attempt reporting\r\n\r\n---\r\n\r\n## 9. Performance and Security Trade-offs\r\n\r\n### Optimized Security Implementation\r\n\r\n```cpp\r\n// Performance-optimized security checks\r\nnamespace security {\r\n\r\nclass OptimizedSecurityChecker {\r\n public:\r\n  // Fast-path security validation for common operations\r\n  bool FastPathSecurityCheck(const SecurityOperation& operation) {\r\n    // Cache frequently-used security decisions\r\n    if (auto cached_result = security_cache_.Get(operation.GetCacheKey())) {\r\n      return *cached_result;\r\n    }\r\n    \r\n    // Optimized validation for common patterns\r\n    bool result = PerformOptimizedValidation(operation);\r\n    \r\n    // Cache result for future use\r\n    security_cache_.Put(operation.GetCacheKey(), result);\r\n    \r\n    return result;\r\n  }\r\n\r\n private:\r\n  // Optimized validation strategies\r\n  bool PerformOptimizedValidation(const SecurityOperation& operation) {\r\n    // Use bloom filters for negative lookups\r\n    if (blocked_operations_filter_.MightContain(operation.GetHash())) {\r\n      return PerformFullSecurityCheck(operation);\r\n    }\r\n    \r\n    // Fast approval for allowlisted operations\r\n    if (allowed_operations_set_.contains(operation.GetPattern())) {\r\n      return true;\r\n    }\r\n    \r\n    // Fall back to full security check\r\n    return PerformFullSecurityCheck(operation);\r\n  }\r\n  \r\n  base::LRUCache<std::string, bool> security_cache_;\r\n  base::BloomFilter<uint64_t> blocked_operations_filter_;\r\n  base::flat_set<std::string> allowed_operations_set_;\r\n};\r\n\r\n}  // namespace security\r\n```\r\n\r\n### Security Performance Metrics\r\n\r\n**Overhead Measurement**:\r\n- **IPC Latency Impact**: Mojo security validation overhead\r\n- **Process Creation Time**: Sandbox initialization performance\r\n- **Memory Overhead**: Security metadata and isolation costs\r\n- **CPU Usage**: Ongoing security check performance\r\n\r\n**Optimization Strategies**:\r\n- **Security Decision Caching**: Frequently-used validation results\r\n- **Batch Security Operations**: Grouped validation for efficiency\r\n- **Lazy Security Initialization**: On-demand security feature activation\r\n- **Hardware Acceleration**: Leveraging security-specific CPU features\r\n\r\n---\r\n\r\n## 10. Future Security Enhancements\r\n\r\n### Emerging Security Technologies\r\n\r\n**WebAssembly Isolation**:\r\n- **Memory-Safe Compilation**: Hardware-enforced memory safety\r\n- **Capability-Based WASM**: Fine-grained permission systems\r\n- **Cross-Language Security**: Unified security across WASM and JavaScript\r\n- **Hardware Attestation**: Cryptographic execution environment verification\r\n\r\n**Advanced Hardware Integration**:\r\n- **Confidential Computing**: Intel TDX, AMD SEV integration\r\n- **Hardware Security Modules (HSM)**: Cryptographic key protection\r\n- **Secure Enclaves**: ARM TrustZone and Intel SGX utilization\r\n- **Post-Quantum Cryptography**: Quantum-resistant security algorithms\r\n\r\n**Zero-Trust Architecture Evolution**:\r\n- **Continuous Verification**: Real-time trust assessment\r\n- **Behavioral Analysis**: ML-based anomaly detection\r\n- **Adaptive Security Policies**: Dynamic risk-based adjustments\r\n- **Microservice Security**: Fine-grained service-to-service authentication\r\n\r\n---\r\n\r\n## 11. Security Best Practices for Developers\r\n\r\n### Secure Development Guidelines\r\n\r\n```cpp\r\n// Security-first development patterns\r\nnamespace security_patterns {\r\n\r\n// RAII-based security context management\r\nclass SecurityContext {\r\n public:\r\n  SecurityContext(const SecurityPolicy& policy) \r\n      : policy_(policy), is_active_(true) {\r\n    // Acquire security context\r\n    if (!AcquireSecurityContext(policy_)) {\r\n      is_active_ = false;\r\n      LOG(FATAL) << \"Failed to acquire security context\";\r\n    }\r\n  }\r\n  \r\n  ~SecurityContext() {\r\n    if (is_active_) {\r\n      ReleaseSecurityContext();\r\n    }\r\n  }\r\n  \r\n  // Non-copyable, movable\r\n  SecurityContext(const SecurityContext&) = delete;\r\n  SecurityContext& operator=(const SecurityContext&) = delete;\r\n  SecurityContext(SecurityContext&&) = default;\r\n  SecurityContext& operator=(SecurityContext&&) = default;\r\n\r\n  // Secure operation execution\r\n  template<typename Operation>\r\n  base::expected<typename Operation::Result, SecurityError> \r\n  ExecuteSecurely(Operation&& operation) {\r\n    if (!is_active_) {\r\n      return base::unexpected(SecurityError::kInactiveContext);\r\n    }\r\n    \r\n    // Validate operation against security policy\r\n    if (auto validation = ValidateOperation(operation); !validation.has_value()) {\r\n      return base::unexpected(validation.error());\r\n    }\r\n    \r\n    // Execute with security monitoring\r\n    return ExecuteWithMonitoring(std::forward<Operation>(operation));\r\n  }\r\n\r\n private:\r\n  SecurityPolicy policy_;\r\n  bool is_active_;\r\n};\r\n\r\n// Capability-based operation wrapper\r\ntemplate<typename T>\r\nclass SecureWrapper {\r\n public:\r\n  explicit SecureWrapper(T&& value, const Capability& capability)\r\n      : value_(std::forward<T>(value)), capability_(capability) {}\r\n  \r\n  // Access requires capability validation\r\n  const T& Get() const {\r\n    ValidateCapability(capability_);\r\n    return value_;\r\n  }\r\n  \r\n  T& GetMutable() {\r\n    ValidateCapability(capability_);\r\n    ValidateWriteAccess(capability_);\r\n    return value_;\r\n  }\r\n\r\n private:\r\n  T value_;\r\n  Capability capability_;\r\n};\r\n\r\n}  // namespace security_patterns\r\n```\r\n\r\n### Code Review Security Checklist\r\n\r\n**Memory Safety**:\r\n- ✅ Use smart pointers and RAII patterns\r\n- ✅ Validate all input boundaries and buffer sizes\r\n- ✅ Employ AddressSanitizer and MemorySanitizer in testing\r\n- ✅ Avoid raw pointer arithmetic and unsafe casts\r\n\r\n**IPC Security**:\r\n- ✅ Use Mojo interfaces instead of legacy IPC mechanisms\r\n- ✅ Validate all IPC message parameters thoroughly\r\n- ✅ Implement capability-based access control\r\n- ✅ Apply rate limiting to prevent IPC flooding\r\n\r\n**Process Isolation**:\r\n- ✅ Respect site isolation boundaries\r\n- ✅ Minimize cross-process data sharing\r\n- ✅ Use appropriate sandbox policies for process types\r\n- ✅ Validate origin permissions for cross-process operations\r\n\r\n---\r\n\r\n## 12. References and Further Reading\r\n\r\n### Core Implementation Files\r\n- `sandbox/` - Cross-platform sandbox implementation\r\n- `content/browser/renderer_host/render_process_host_impl.cc` - Process isolation\r\n- `services/service_manager/` - Service isolation and security\r\n- `chrome/browser/chrome_content_browser_client.cc` - Security policy configuration\r\n\r\n### Architecture Documentation\r\n- [Process Model](../process-model.md) - Multi-process architecture and isolation\r\n- [IPC Internals](../ipc-internals.md) - Mojo IPC security mechanisms\r\n- [Site Isolation](../site-isolation.md) - Per-origin process boundaries\r\n\r\n### Security Documentation\r\n- [Security Model](../../security/security-model.md) - Overall security architecture\r\n- [Privacy Sandbox](../../privacy/privacy-sandbox.md) - Privacy feature isolation\r\n- [Exploit Mitigations](../../security/exploit-mitigations.md) - Advanced protection mechanisms\r\n\r\n### External Resources\r\n- **Chromium Security Architecture**: Official security documentation\r\n- **Platform Security Guides**: OS-specific security implementation details\r\n- **CVE Database**: Historical vulnerability analysis and mitigations\r\n- **Security Research Papers**: Academic research on browser security\r\n\r\n---\r\n\r\nThe sandbox architecture in Chromium v134+ represents the state-of-the-art in browser security, providing comprehensive protection through multiple defense layers, process isolation, and modern exploit mitigations. Understanding this architecture is essential for developing secure browser features and maintaining the highest levels of user protection in the modern web environment.\r\n"
  },
  {
    "path": "architecture/security/overview",
    "title": "Security Architecture",
    "content": "# Security Architecture\r\n\r\nWelcome to the Security Architecture section! This area provides detailed technical documentation about the security architecture and implementation within the Wanderlust custom Chromium browser.\r\n\r\n## What You'll Find Here\r\n\r\nThis section focuses on the architectural aspects of browser security:\r\n\r\n- **[Sandbox Architecture](sandbox-architecture.md)**: Detailed technical implementation of browser sandboxing and process isolation\r\n- **Security Boundaries**: How security boundaries are maintained across browser components\r\n- **Process Isolation**: Technical details of multi-process security architecture\r\n- **Privilege Separation**: Implementation of least-privilege principles\r\n\r\n## Security Architecture Overview\r\n\r\nThe security architecture of our custom Chromium browser is built on several key principles:\r\n\r\n### Multi-Process Security Model\r\n- **Process Isolation**: Each major component runs in its own process with limited privileges\r\n- **Sandbox Boundaries**: Strict sandboxing prevents processes from accessing unauthorized resources\r\n- **Inter-Process Communication**: Secure communication channels between isolated processes\r\n- **Privilege Escalation Prevention**: Architecture prevents unauthorized privilege increases\r\n\r\n### Sandboxing Implementation\r\n- **Renderer Sandboxing**: Web content runs in heavily sandboxed renderer processes\r\n- **System Resource Isolation**: Limited access to file system, network, and system APIs\r\n- **GPU Process Sandboxing**: Graphics operations isolated in separate sandboxed process\r\n- **Plugin Sandboxing**: Third-party plugins run with minimal system access\r\n\r\n## Technical Architecture Components\r\n\r\n### Process Security Model\r\nThe browser implements a multi-layered process security model:\r\n\r\n1. **Browser Process**: Privileged process managing other processes and system access\r\n2. **Renderer Processes**: Sandboxed processes for web content execution\r\n3. **GPU Process**: Isolated graphics and hardware acceleration\r\n4. **Network Process**: Separate process for network operations\r\n5. **Utility Processes**: Specialized processes for specific tasks\r\n\r\n### Security Boundaries\r\n- **Same-Origin Policy**: Enforced at the process level for strong isolation\r\n- **Site Isolation**: Each site runs in its own dedicated process\r\n- **Cross-Origin Restrictions**: Strict controls on cross-origin resource access\r\n- **API Access Controls**: Limited API access based on process type and privileges\r\n\r\n### Threat Mitigation\r\n- **Code Injection Prevention**: Architecture prevents malicious code injection\r\n- **Data Exfiltration Protection**: Sandboxing limits unauthorized data access\r\n- **System Compromise Mitigation**: Isolated processes limit impact of security breaches\r\n- **Privilege Escalation Blocks**: Multiple barriers prevent privilege escalation attacks\r\n\r\n## Implementation Details\r\n\r\n### Sandbox Technology\r\n- **Operating System Integration**: Leveraging OS-specific sandboxing mechanisms\r\n- **Capability-Based Security**: Fine-grained capability control for process operations\r\n- **Resource Limitations**: CPU, memory, and I/O restrictions for sandboxed processes\r\n- **System Call Filtering**: Restricted system calls for enhanced security\r\n\r\n### Communication Security\r\n- **IPC Security**: Secure inter-process communication mechanisms\r\n- **Message Validation**: Strict validation of all inter-process messages\r\n- **Authentication**: Process identity verification and authentication\r\n- **Encryption**: Encrypted communication channels where appropriate\r\n\r\n## Security Architecture Patterns\r\n\r\n### Defense in Depth\r\n- **Multiple Security Layers**: No single point of failure in security architecture\r\n- **Redundant Protections**: Multiple mechanisms protecting against the same threats\r\n- **Fail-Safe Defaults**: Secure default behaviors when security checks fail\r\n\r\n### Least Privilege\r\n- **Minimal Permissions**: Each process has only the minimum required permissions\r\n- **Dynamic Privilege Adjustment**: Privileges adjusted based on current needs\r\n- **Capability Dropping**: Unused capabilities are removed during process execution\r\n\r\n## Integration with Browser Architecture\r\n\r\nSecurity architecture integrates deeply with:\r\n- [Process Model](../process-model.md): How security boundaries align with process boundaries\r\n- [IPC Internals](../ipc-internals.md): Secure communication between processes\r\n- [Browser Components](../browser-components.md): Security considerations for each component\r\n- [General Security Model](../../security/overview.md): High-level security principles and policies\r\n\r\n## Development Considerations\r\n\r\nWhen working with security-sensitive code:\r\n\r\n1. **Security Review Required**: All changes affecting security boundaries need review\r\n2. **Threat Modeling**: Consider potential attacks and mitigation strategies\r\n3. **Testing Requirements**: Comprehensive security testing including penetration testing\r\n4. **Documentation Updates**: Keep security documentation current with implementation changes\r\n\r\n## Security Compliance\r\n\r\nOur security architecture adheres to:\r\n- **Industry Standards**: Following established security architecture best practices\r\n- **Regulatory Requirements**: Compliance with relevant security regulations\r\n- **Security Frameworks**: Implementation based on proven security frameworks\r\n- **Continuous Assessment**: Regular security architecture reviews and updates\r\n\r\n## Performance Considerations\r\n\r\nSecurity architecture balances security with performance:\r\n- **Efficient IPC**: Optimized secure communication between processes\r\n- **Resource Management**: Efficient use of system resources within security constraints\r\n- **Caching Strategies**: Secure caching that doesn't compromise security boundaries\r\n- **Startup Optimization**: Fast startup while maintaining security guarantees\r\n\r\n---\r\n\r\n*Start with the [Sandbox Architecture](sandbox-architecture.md) documentation to understand the foundational security isolation mechanisms that protect users and the system.*\r\n"
  },
  {
    "path": "architecture/design-patterns/state-pattern",
    "title": "State Pattern in Chromium v134+",
    "content": "# State Pattern in Chromium v134+\r\n\r\nThe State pattern enables objects to alter their behavior when internal state changes, appearing as if the object changed its class. Modern Chromium v134+ leverages sophisticated state machines for navigation, downloads, security contexts, service lifecycles, and complex UI interactions with type safety and performance optimization.\r\n\r\n---\r\n\r\n## 1. Modern State Pattern Applications (v134+)\r\n\r\n### Core Browser States\r\n- **Navigation State Management**: Multi-phase navigation with security boundaries\r\n- **Download Pipeline States**: Progressive download phases with resume capability  \r\n- **Service Lifecycle States**: Mojo service initialization, active, and cleanup phases\r\n- **Security Context States**: Site isolation, permission states, and capability management\r\n- **Renderer Process States**: Loading, active, backgrounded, and memory optimization\r\n- **Network Request States**: DNS resolution, connection establishment, data transfer phases\r\n\r\n### Advanced State Machines\r\n- **Privacy Sandbox States**: Consent flow, feature enablement, and configuration phases\r\n- **WebRTC Connection States**: ICE gathering, connection establishment, and media flow\r\n- **Cache Management States**: Storage allocation, eviction policies, and cleanup cycles\r\n- **Extension Lifecycle States**: Installation, activation, suspension, and removal phases\r\n\r\n---\r\n\r\n## 2. Modern C++ State Implementation Patterns\r\n\r\n### Type-Safe State Machines with std::variant\r\n\r\n```cpp\r\n// Modern state machine using C++20 features\r\nnamespace content {\r\n\r\n// State definitions with strong typing\r\nstruct NavigationPending {\r\n  GURL url;\r\n  base::TimeTicks start_time;\r\n  NavigationRequest::Priority priority = NavigationRequest::Priority::kNormal;\r\n};\r\n\r\nstruct NavigationInProgress {\r\n  std::unique_ptr<NavigationRequest> request;\r\n  base::TimeTicks navigation_start;\r\n  int64_t request_id;\r\n  bool is_same_process = false;\r\n};\r\n\r\nstruct NavigationComplete {\r\n  NavigationResult result;\r\n  base::TimeTicks completion_time;\r\n  std::optional<NavigationMetrics> metrics;\r\n};\r\n\r\nstruct NavigationFailed {\r\n  net::Error error_code;\r\n  std::string error_description;\r\n  base::TimeTicks failure_time;\r\n  bool is_recoverable = false;\r\n};\r\n\r\n// Type-safe state variant\r\nusing NavigationState = std::variant<\r\n    NavigationPending,\r\n    NavigationInProgress, \r\n    NavigationComplete,\r\n    NavigationFailed>;\r\n\r\nclass NavigationStateMachine {\r\n public:\r\n  // Modern state transition with error handling\r\n  base::expected<void, NavigationError> TransitionTo(NavigationState new_state) {\r\n    if (!IsValidTransition(current_state_, new_state)) {\r\n      return base::unexpected(NavigationError::kInvalidStateTransition);\r\n    }\r\n    \r\n    // Execute state exit actions\r\n    ExecuteExitActions(current_state_);\r\n    \r\n    // Update state atomically\r\n    current_state_ = std::move(new_state);\r\n    \r\n    // Execute state entry actions  \r\n    ExecuteEntryActions(current_state_);\r\n    \r\n    // Notify observers with new state\r\n    NotifyStateChanged();\r\n    \r\n    return base::ok();\r\n  }\r\n\r\n  // Pattern matching for state-specific behavior\r\n  template<typename Visitor>\r\n  auto Visit(Visitor&& visitor) const {\r\n    return std::visit(std::forward<Visitor>(visitor), current_state_);\r\n  }\r\n\r\n  // Type-safe state queries\r\n  bool IsPending() const { \r\n    return std::holds_alternative<NavigationPending>(current_state_); \r\n  }\r\n  \r\n  bool IsInProgress() const { \r\n    return std::holds_alternative<NavigationInProgress>(current_state_); \r\n  }\r\n\r\n private:\r\n  NavigationState current_state_{NavigationPending{}};\r\n  base::ObserverList<NavigationStateObserver> observers_;\r\n  \r\n  bool IsValidTransition(const NavigationState& from, const NavigationState& to) const {\r\n    // Implementation of state transition validation\r\n    return state_transition_table_.IsValidTransition(\r\n        GetStateType(from), GetStateType(to));\r\n  }\r\n};\r\n\r\n}  // namespace content\r\n```\r\n\r\n### Hierarchical State Machines for Complex Components\r\n\r\n```cpp\r\n// Hierarchical state management for download system\r\nnamespace download {\r\n\r\nclass DownloadStateMachine : public base::RefCountedThreadSafe<DownloadStateMachine> {\r\n public:\r\n  // Nested state hierarchy\r\n  enum class MainState {\r\n    kInitializing,\r\n    kActive,      // Has sub-states\r\n    kPaused,\r\n    kCompleted,\r\n    kFailed\r\n  };\r\n  \r\n  enum class ActiveSubState {\r\n    kConnecting,\r\n    kDownloading,\r\n    kVerifying,\r\n    kMovingToFinalLocation\r\n  };\r\n  \r\n  struct StateContext {\r\n    MainState main_state = MainState::kInitializing;\r\n    std::optional<ActiveSubState> sub_state;\r\n    base::FilePath target_path;\r\n    int64_t total_bytes = 0;\r\n    int64_t received_bytes = 0;\r\n    base::TimeTicks last_update;\r\n    DownloadDangerType danger_type = DownloadDangerType::kNotDangerous;\r\n  };\r\n\r\n  // Modern async state transitions\r\n  void TransitionToState(MainState new_main_state, \r\n                        std::optional<ActiveSubState> new_sub_state = std::nullopt) {\r\n    DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\r\n    \r\n    // Validate transition on UI thread\r\n    if (!IsValidStateTransition(context_.main_state, new_main_state)) {\r\n      LOG(ERROR) << \"Invalid state transition attempted: \" \r\n                 << static_cast<int>(context_.main_state) \r\n                 << \" -> \" << static_cast<int>(new_main_state);\r\n      return;\r\n    }\r\n    \r\n    // Execute async state transition\r\n    base::ThreadPool::PostTaskAndReplyWithResult(\r\n        FROM_HERE,\r\n        {base::MayBlock(), base::TaskPriority::USER_VISIBLE},\r\n        base::BindOnce(&DownloadStateMachine::ExecuteStateTransition,\r\n                      base::Unretained(this), new_main_state, new_sub_state),\r\n        base::BindOnce(&DownloadStateMachine::OnStateTransitionComplete,\r\n                      weak_factory_.GetWeakPtr()));\r\n  }\r\n\r\n private:\r\n  StateContext context_;\r\n  base::WeakPtrFactory<DownloadStateMachine> weak_factory_{this};\r\n  \r\n  // Executed on background thread\r\n  bool ExecuteStateTransition(MainState new_main_state, \r\n                             std::optional<ActiveSubState> new_sub_state) {\r\n    // Perform heavy state transition work\r\n    return true;  // Success\r\n  }\r\n  \r\n  // Back on UI thread\r\n  void OnStateTransitionComplete(bool success) {\r\n    if (success) {\r\n      NotifyObserversOfStateChange();\r\n    }\r\n  }\r\n};\r\n\r\n}  // namespace download\r\n```\r\n\r\n---\r\n\r\n## 3. Mojo Service State Management\r\n\r\n### Service Lifecycle State Patterns\r\n\r\n```cpp\r\n// Modern Mojo service with comprehensive state management\r\nnamespace network {\r\n\r\nclass NetworkServiceImpl : public mojom::NetworkService {\r\n public:\r\n  enum class ServiceState {\r\n    kInitializing,\r\n    kConfiguring,\r\n    kActive,\r\n    kShuttingDown,\r\n    kTerminated\r\n  };\r\n\r\n  class StateManager {\r\n   public:\r\n    // Thread-safe state transitions with validation\r\n    bool TransitionTo(ServiceState new_state) {\r\n      base::AutoLock lock(state_lock_);\r\n      \r\n      if (!IsValidTransition(current_state_, new_state)) {\r\n        DLOG(WARNING) << \"Invalid service state transition: \"\r\n                      << StateToString(current_state_) \r\n                      << \" -> \" << StateToString(new_state);\r\n        return false;\r\n      }\r\n      \r\n      ServiceState old_state = current_state_;\r\n      current_state_ = new_state;\r\n      \r\n      // Execute state change callbacks without holding lock\r\n      {\r\n        base::AutoUnlock unlock(state_lock_);\r\n        ExecuteStateChangeCallbacks(old_state, new_state);\r\n      }\r\n      \r\n      return true;\r\n    }\r\n    \r\n    ServiceState GetCurrentState() const {\r\n      base::AutoLock lock(state_lock_);\r\n      return current_state_;\r\n    }\r\n    \r\n    // Wait for specific state with timeout\r\n    base::expected<void, base::TimeDelta> WaitForState(\r\n        ServiceState target_state, \r\n        base::TimeDelta timeout = base::Seconds(30)) {\r\n      \r\n      base::WaitableEvent state_reached;\r\n      base::OneShotTimer timeout_timer;\r\n      \r\n      auto callback = base::BindRepeating([&](ServiceState old_state, ServiceState new_state) {\r\n        if (new_state == target_state) {\r\n          state_reached.Signal();\r\n        }\r\n      });\r\n      \r\n      AddStateChangeCallback(callback);\r\n      \r\n      // Set up timeout\r\n      timeout_timer.Start(FROM_HERE, timeout, base::BindOnce([&]() {\r\n        state_reached.Signal();  // Signal timeout\r\n      }));\r\n      \r\n      state_reached.Wait();\r\n      \r\n      RemoveStateChangeCallback(callback);\r\n      \r\n      base::AutoLock lock(state_lock_);\r\n      if (current_state_ == target_state) {\r\n        return base::ok();\r\n      } else {\r\n        return base::unexpected(timeout);\r\n      }\r\n    }\r\n\r\n   private:\r\n    mutable base::Lock state_lock_;\r\n    ServiceState current_state_ = ServiceState::kInitializing;\r\n    std::vector<base::RepeatingCallback<void(ServiceState, ServiceState)>> callbacks_;\r\n    \r\n    bool IsValidTransition(ServiceState from, ServiceState to) const {\r\n      // Define valid state transition matrix\r\n      static const std::set<std::pair<ServiceState, ServiceState>> valid_transitions = {\r\n        {ServiceState::kInitializing, ServiceState::kConfiguring},\r\n        {ServiceState::kConfiguring, ServiceState::kActive},\r\n        {ServiceState::kActive, ServiceState::kShuttingDown},\r\n        {ServiceState::kShuttingDown, ServiceState::kTerminated},\r\n        // Allow emergency shutdown from any state\r\n        {ServiceState::kInitializing, ServiceState::kTerminated},\r\n        {ServiceState::kConfiguring, ServiceState::kTerminated},\r\n      };\r\n      \r\n      return valid_transitions.count({from, to}) > 0;\r\n    }\r\n  };\r\n\r\n private:\r\n  std::unique_ptr<StateManager> state_manager_;\r\n};\r\n\r\n}  // namespace network\r\n```\r\n\r\n### Async State Coordination with Mojo\r\n\r\n```cpp\r\n// Coordinated state management across processes\r\nnamespace content {\r\n\r\nclass RenderProcessHostStateCoordinator {\r\n public:\r\n  enum class ProcessState {\r\n    kLaunching,\r\n    kInitializing,\r\n    kReady,\r\n    kBackgrounded,\r\n    kSuspended,\r\n    kTerminating\r\n  };\r\n\r\n  // Coordinate state changes across process boundaries\r\n  void CoordinateStateTransition(ProcessState target_state) {\r\n    auto coordinator_request = CreateCoordinationRequest(target_state);\r\n    \r\n    // Coordinate with browser process\r\n    coordinator_request->CoordinateWithBrowser(base::BindOnce(\r\n        &RenderProcessHostStateCoordinator::OnBrowserCoordinationComplete,\r\n        weak_factory_.GetWeakPtr(), target_state));\r\n  }\r\n\r\n private:\r\n  void OnBrowserCoordinationComplete(ProcessState target_state, bool browser_ready) {\r\n    if (!browser_ready) {\r\n      LOG(ERROR) << \"Browser process coordination failed for state: \"\r\n                 << static_cast<int>(target_state);\r\n      return;\r\n    }\r\n    \r\n    // Coordinate with renderer process via Mojo\r\n    if (renderer_coordinator_.is_bound()) {\r\n      renderer_coordinator_->PrepareForStateTransition(\r\n          ConvertToMojoState(target_state),\r\n          base::BindOnce(&RenderProcessHostStateCoordinator::OnRendererReady,\r\n                        weak_factory_.GetWeakPtr(), target_state));\r\n    }\r\n  }\r\n  \r\n  void OnRendererReady(ProcessState target_state, bool renderer_ready) {\r\n    if (renderer_ready) {\r\n      ExecuteStateTransition(target_state);\r\n    } else {\r\n      HandleStateTransitionFailure(target_state);\r\n    }\r\n  }\r\n  \r\n  mojo::Remote<mojom::RendererStateCoordinator> renderer_coordinator_;\r\n  base::WeakPtrFactory<RenderProcessHostStateCoordinator> weak_factory_{this};\r\n};\r\n\r\n}  // namespace content\r\n```\r\n\r\n---\r\n\r\n## 4. Privacy Sandbox State Management\r\n\r\n### Consent and Configuration State Patterns\r\n\r\n```cpp\r\n// Privacy Sandbox state management with compliance tracking\r\nnamespace privacy_sandbox {\r\n\r\nclass PrivacySandboxStateManager {\r\n public:\r\n  enum class ConsentState {\r\n    kNotRequired,\r\n    kRequired,\r\n    kPending,\r\n    kGranted,\r\n    kDenied,\r\n    kWithdrawn\r\n  };\r\n  \r\n  enum class FeatureState {\r\n    kDisabled,\r\n    kEnabledWithConsent,\r\n    kEnabledWithoutConsent,\r\n    kTemporarilyDisabled,\r\n    kPermanentlyDisabled\r\n  };\r\n\r\n  struct PrivacySandboxContext {\r\n    ConsentState consent_state = ConsentState::kNotRequired;\r\n    std::map<PrivacySandboxFeature, FeatureState> feature_states;\r\n    base::Time consent_timestamp;\r\n    std::string consent_jurisdiction;\r\n    bool is_measurement_enabled = false;\r\n    bool is_topics_enabled = false;\r\n    bool is_fledge_enabled = false;\r\n  };\r\n\r\n  // Complex state validation with regulatory compliance\r\n  base::expected<void, PrivacySandboxError> UpdateConsentState(\r\n      ConsentState new_consent_state,\r\n      const ConsentMetadata& metadata) {\r\n    \r\n    if (!IsValidConsentTransition(context_.consent_state, new_consent_state)) {\r\n      return base::unexpected(PrivacySandboxError::kInvalidConsentTransition);\r\n    }\r\n    \r\n    // Validate regulatory compliance\r\n    if (auto compliance_check = ValidateRegulatoryCompliance(new_consent_state, metadata);\r\n        !compliance_check.has_value()) {\r\n      return compliance_check;\r\n    }\r\n    \r\n    // Update consent state atomically\r\n    context_.consent_state = new_consent_state;\r\n    context_.consent_timestamp = base::Time::Now();\r\n    context_.consent_jurisdiction = metadata.jurisdiction;\r\n    \r\n    // Propagate state changes to dependent features\r\n    UpdateDependentFeatureStates();\r\n    \r\n    // Log compliance event\r\n    RecordComplianceEvent(new_consent_state, metadata);\r\n    \r\n    return base::ok();\r\n  }\r\n\r\n private:\r\n  PrivacySandboxContext context_;\r\n  \r\n  void UpdateDependentFeatureStates() {\r\n    // Update Topics API state\r\n    if (context_.consent_state == ConsentState::kGranted) {\r\n      context_.feature_states[PrivacySandboxFeature::kTopics] = \r\n          FeatureState::kEnabledWithConsent;\r\n    } else if (context_.consent_state == ConsentState::kDenied) {\r\n      context_.feature_states[PrivacySandboxFeature::kTopics] = \r\n          FeatureState::kPermanentlyDisabled;\r\n    }\r\n    \r\n    // Update FLEDGE state based on consent and feature flags\r\n    UpdateFledgeState();\r\n    UpdateMeasurementState();\r\n  }\r\n};\r\n\r\n}  // namespace privacy_sandbox\r\n```\r\n\r\n---\r\n\r\n## 5. Performance-Optimized State Machines\r\n\r\n### Cache-Friendly State Management\r\n\r\n```cpp\r\n// High-performance state management for renderer processes\r\nnamespace blink {\r\n\r\nclass RenderFrameStateManager {\r\n public:\r\n  // Bit-packed state for cache efficiency\r\n  struct CompactFrameState {\r\n    uint32_t lifecycle_state : 4;      // FrameLifecycleState (16 values max)\r\n    uint32_t visibility_state : 2;     // VisibilityState (4 values max)\r\n    uint32_t loading_state : 3;        // LoadingState (8 values max)\r\n    uint32_t is_main_frame : 1;        // Boolean\r\n    uint32_t is_cross_origin : 1;      // Boolean\r\n    uint32_t has_committed_navigation : 1;  // Boolean\r\n    uint32_t is_frozen : 1;             // Boolean\r\n    uint32_t reserved : 19;             // Reserved for future use\r\n    \r\n    // Fast state queries using bit operations\r\n    bool IsActiveAndVisible() const {\r\n      return (lifecycle_state == static_cast<uint32_t>(FrameLifecycleState::kActive)) &&\r\n             (visibility_state == static_cast<uint32_t>(mojom::VisibilityState::kVisible));\r\n    }\r\n    \r\n    bool CanStartNavigation() const {\r\n      return (lifecycle_state <= static_cast<uint32_t>(FrameLifecycleState::kActive)) &&\r\n             !is_frozen;\r\n    }\r\n  };\r\n\r\n  // Lockless state updates using atomic operations\r\n  void UpdateState(const StateUpdate& update) {\r\n    CompactFrameState current_state;\r\n    CompactFrameState new_state;\r\n    \r\n    do {\r\n      current_state.value = state_.load(std::memory_order_acquire);\r\n      new_state = current_state;\r\n      \r\n      // Apply state update\r\n      ApplyUpdate(new_state, update);\r\n      \r\n    } while (!state_.compare_exchange_weak(\r\n        current_state.value, new_state.value, \r\n        std::memory_order_release, std::memory_order_relaxed));\r\n    \r\n    // Notify state change observers if necessary\r\n    if (HasStateChangeObservers() && StateChangeRequiresNotification(current_state, new_state)) {\r\n      NotifyStateChangeAsync(current_state, new_state);\r\n    }\r\n  }\r\n\r\n private:\r\n  // Atomic state storage for lockless access\r\n  std::atomic<uint32_t> state_{0};\r\n  \r\n  // Observer notification queue to avoid blocking state updates\r\n  base::circular_deque<StateChangeNotification> pending_notifications_;\r\n  base::SequenceBound<StateChangeNotifier> notifier_;\r\n};\r\n\r\n}  // namespace blink\r\n```\r\n\r\n### Memory-Efficient State History\r\n\r\n```cpp\r\n// Efficient state history tracking for debugging and rollback\r\nnamespace base {\r\n\r\ntemplate<typename StateType, size_t MaxHistorySize = 32>\r\nclass CompactStateHistory {\r\n public:\r\n  struct StateEntry {\r\n    StateType state;\r\n    base::TimeTicks timestamp;\r\n    uint32_t transition_id;\r\n    \r\n    // Optional debug information (only in debug builds)\r\n#if DCHECK_IS_ON()\r\n    std::string debug_info;\r\n    base::Location location;\r\n#endif\r\n  };\r\n\r\n  void RecordStateTransition(const StateType& new_state, \r\n                           const base::Location& location = FROM_HERE) {\r\n    uint32_t transition_id = next_transition_id_++;\r\n    \r\n    StateEntry entry{\r\n      .state = new_state,\r\n      .timestamp = base::TimeTicks::Now(),\r\n      .transition_id = transition_id\r\n    };\r\n    \r\n#if DCHECK_IS_ON()\r\n    entry.location = location;\r\n#endif\r\n    \r\n    // Circular buffer for memory efficiency\r\n    history_[history_index_] = std::move(entry);\r\n    history_index_ = (history_index_ + 1) % MaxHistorySize;\r\n    \r\n    if (size_ < MaxHistorySize) {\r\n      ++size_;\r\n    }\r\n  }\r\n  \r\n  // Efficient state history queries\r\n  std::optional<StateType> GetStateAt(base::TimeTicks timestamp) const {\r\n    for (size_t i = 0; i < size_; ++i) {\r\n      const auto& entry = history_[i];\r\n      if (entry.timestamp <= timestamp) {\r\n        return entry.state;\r\n      }\r\n    }\r\n    return std::nullopt;\r\n  }\r\n\r\n private:\r\n  std::array<StateEntry, MaxHistorySize> history_;\r\n  size_t history_index_ = 0;\r\n  size_t size_ = 0;\r\n  std::atomic<uint32_t> next_transition_id_{1};\r\n};\r\n\r\n}  // namespace base\r\n```\r\n\r\n---\r\n\r\n## 6. Testing State Machines in Chromium v134+\r\n\r\n### Comprehensive State Machine Testing\r\n\r\n```cpp\r\n// Modern testing patterns for state machines\r\nnamespace content {\r\n\r\nclass NavigationStateMachineTest : public testing::Test {\r\n public:\r\n  void SetUp() override {\r\n    state_machine_ = std::make_unique<NavigationStateMachine>();\r\n    \r\n    // Set up test observers\r\n    state_observer_ = std::make_unique<TestStateObserver>();\r\n    state_machine_->AddObserver(state_observer_.get());\r\n  }\r\n\r\n  // Test state transition validation\r\n  TEST_F(NavigationStateMachineTest, ValidatesStateTransitions) {\r\n    // Test valid transition\r\n    EXPECT_TRUE(state_machine_->TransitionTo(NavigationInProgress{}).has_value());\r\n    \r\n    // Test invalid transition (should fail)\r\n    auto result = state_machine_->TransitionTo(NavigationPending{});\r\n    EXPECT_FALSE(result.has_value());\r\n    EXPECT_EQ(result.error(), NavigationError::kInvalidStateTransition);\r\n  }\r\n\r\n  // Test state machine behavior under concurrent access\r\n  TEST_F(NavigationStateMachineTest, HandlesConcurrentStateChanges) {\r\n    constexpr int kNumThreads = 10;\r\n    constexpr int kTransitionsPerThread = 100;\r\n    \r\n    std::vector<std::thread> threads;\r\n    std::atomic<int> successful_transitions{0};\r\n    \r\n    for (int i = 0; i < kNumThreads; ++i) {\r\n      threads.emplace_back([&]() {\r\n        for (int j = 0; j < kTransitionsPerThread; ++j) {\r\n          if (state_machine_->TransitionTo(GenerateRandomValidState()).has_value()) {\r\n            successful_transitions.fetch_add(1);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    \r\n    for (auto& thread : threads) {\r\n      thread.join();\r\n    }\r\n    \r\n    // Verify state machine remained consistent\r\n    EXPECT_GT(successful_transitions.load(), 0);\r\n    EXPECT_TRUE(state_machine_->IsInValidState());\r\n  }\r\n\r\n private:\r\n  std::unique_ptr<NavigationStateMachine> state_machine_;\r\n  std::unique_ptr<TestStateObserver> state_observer_;\r\n};\r\n\r\n// Property-based testing for state machines\r\nclass StatePropertyTest : public testing::TestWithParam<StateTransitionTestCase> {\r\n public:\r\n  // Generate comprehensive test cases\r\n  static std::vector<StateTransitionTestCase> GenerateTestCases() {\r\n    std::vector<StateTransitionTestCase> test_cases;\r\n    \r\n    // Generate all valid state transitions\r\n    for (auto from_state : AllPossibleStates()) {\r\n      for (auto to_state : AllPossibleStates()) {\r\n        test_cases.push_back({\r\n          .from_state = from_state,\r\n          .to_state = to_state,\r\n          .should_succeed = IsValidTransition(from_state, to_state),\r\n          .expected_side_effects = ComputeExpectedSideEffects(from_state, to_state)\r\n        });\r\n      }\r\n    }\r\n    \r\n    return test_cases;\r\n  }\r\n};\r\n\r\nINSTANTIATE_TEST_SUITE_P(\r\n    AllStateTransitions,\r\n    StatePropertyTest,\r\n    testing::ValuesIn(StatePropertyTest::GenerateTestCases())\r\n);\r\n\r\n}  // namespace content\r\n```\r\n\r\n### Mock State Coordination Testing\r\n\r\n```cpp\r\n// Testing complex state coordination scenarios\r\nnamespace content {\r\n\r\nclass MockRenderProcessStateCoordinator : public RenderProcessStateCoordinator {\r\n public:\r\n  MOCK_METHOD(void, CoordinateStateTransition, (ProcessState target_state), (override));\r\n  MOCK_METHOD(bool, WaitForStateTransition, (ProcessState state, base::TimeDelta timeout), (override));\r\n  \r\n  // Simulate state coordination failures\r\n  void SimulateCoordinationFailure(ProcessState failing_state) {\r\n    ON_CALL(*this, CoordinateStateTransition(failing_state))\r\n        .WillByDefault(testing::Invoke([this](ProcessState state) {\r\n          // Simulate failure after delay\r\n          base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\r\n              FROM_HERE,\r\n              base::BindOnce(&MockRenderProcessStateCoordinator::NotifyCoordinationFailure,\r\n                            base::Unretained(this), state),\r\n              base::Milliseconds(100));\r\n        }));\r\n  }\r\n  \r\n private:\r\n  void NotifyCoordinationFailure(ProcessState state) {\r\n    // Notify observers of coordination failure\r\n  }\r\n};\r\n\r\n// Integration test for state coordination\r\nTEST_F(RenderProcessStateTest, HandlesCoordinationFailures) {\r\n  auto mock_coordinator = std::make_unique<MockRenderProcessStateCoordinator>();\r\n  \r\n  // Configure mock to fail background state transition\r\n  mock_coordinator->SimulateCoordinationFailure(ProcessState::kBackgrounded);\r\n  \r\n  // Attempt state transition\r\n  bool transition_result = process_host_->TransitionToBackgroundState();\r\n  \r\n  // Verify graceful failure handling\r\n  EXPECT_FALSE(transition_result);\r\n  EXPECT_EQ(process_host_->GetCurrentState(), ProcessState::kReady);\r\n  \r\n  // Verify error was logged\r\n  EXPECT_TRUE(HasLoggedError(\"State coordination failed\"));\r\n}\r\n\r\n}  // namespace content\r\n```\r\n\r\n---\r\n\r\n## 7. Real-World Examples from Chromium v134+\r\n\r\n### Download State Management\r\n\r\n**File**: `content/browser/download/download_item_impl.h`\r\n\r\nModern download state management with resumption support:\r\n\r\n```cpp\r\n// Simplified view of actual Chromium v134+ download states\r\nenum class DownloadInternalState {\r\n  kInitial,\r\n  kTarget,\r\n  kInterrupted,\r\n  kInProgress, \r\n  kComplete,\r\n  kCancelled\r\n};\r\n\r\n// Enhanced with security and privacy features\r\nclass DownloadItemImpl {\r\n private:\r\n  DownloadInternalState internal_state_ = DownloadInternalState::kInitial;\r\n  DownloadDangerType danger_type_ = DownloadDangerType::kNotDangerous;\r\n  bool is_mixed_content_ = false;\r\n  bool is_from_privacy_sandbox_ = false;\r\n};\r\n```\r\n\r\n### Service Worker State Management  \r\n\r\n**File**: `content/browser/service_worker/service_worker_version.h`\r\n\r\n```cpp\r\n// Service Worker lifecycle with enhanced security\r\nenum class ServiceWorkerVersion::Status {\r\n  kNew,\r\n  kDownloading,\r\n  kInstalling,\r\n  kInstalled,\r\n  kActivating,\r\n  kActivated,\r\n  kRedundant\r\n};\r\n\r\n// Modern state tracking with privacy considerations\r\nclass ServiceWorkerVersion {\r\n private:\r\n  Status status_ = Status::kNew;\r\n  bool is_privacy_sandbox_enabled_ = false;\r\n  std::optional<PrivacySandboxPolicy> privacy_policy_;\r\n};\r\n```\r\n\r\n### Navigation State with Site Isolation\r\n\r\n**File**: `content/browser/renderer_host/navigation_request.h`\r\n\r\n```cpp\r\n// Enhanced navigation states for site isolation\r\nenum class NavigationRequest::NavigationState {\r\n  kWillStartRequest,\r\n  kWillRedirectRequest, \r\n  kWillFailRequest,\r\n  kWillProcessResponse,\r\n  kReadyToCommit,\r\n  kWillCommitNavigation\r\n};\r\n\r\n// Modern security-aware navigation tracking\r\nclass NavigationRequest {\r\n private:\r\n  NavigationState state_ = NavigationState::kWillStartRequest;\r\n  bool is_cross_site_cross_rph_ = false;\r\n  SiteInstance* target_site_instance_ = nullptr;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 8. Advanced State Pattern Best Practices (v134+)\r\n\r\n### Modern C++ Best Practices\r\n\r\n1. **Use std::variant for Type Safety**\r\n   - Prefer `std::variant` over enum + union patterns\r\n   - Leverage `std::visit` for exhaustive state handling\r\n   - Use concepts to constrain state types\r\n\r\n2. **Implement RAII for State Resources**\r\n   - Acquire resources on state entry, release on exit\r\n   - Use smart pointers for automatic cleanup\r\n   - Implement exception-safe state transitions\r\n\r\n3. **Leverage base::expected for Error Handling**\r\n   - Return `base::expected<void, ErrorType>` from state transitions\r\n   - Provide detailed error information for debugging\r\n   - Support both synchronous and asynchronous error propagation\r\n\r\n### Performance Optimization\r\n\r\n1. **Memory Layout Optimization**\r\n   - Pack state data for cache efficiency\r\n   - Use atomic operations for lockless state updates\r\n   - Minimize memory allocations during transitions\r\n\r\n2. **Concurrent State Management**\r\n   - Use thread-safe state machines for shared state\r\n   - Implement lockless algorithms where possible\r\n   - Provide async state coordination mechanisms\r\n\r\n### Security Considerations\r\n\r\n1. **State Validation**\r\n   - Validate all state transitions against security policies\r\n   - Implement capability-based state access control\r\n   - Log security-relevant state changes for auditing\r\n\r\n2. **Privacy-Aware State Management**\r\n   - Consider privacy implications of state persistence\r\n   - Implement appropriate state cleanup on privacy events\r\n   - Support privacy sandbox state isolation\r\n\r\n---\r\n\r\n## 9. Modern Debugging and Monitoring\r\n\r\n### State Machine Introspection\r\n\r\n```cpp\r\n// Advanced debugging support for state machines\r\nclass StateDebugInfo {\r\n public:\r\n  struct StateSnapshot {\r\n    std::string current_state_name;\r\n    base::TimeTicks last_transition_time;\r\n    std::vector<std::string> recent_transitions;\r\n    std::map<std::string, base::Value> debug_properties;\r\n  };\r\n  \r\n  // Export state for chrome://internals pages\r\n  base::Value::Dict ExportToValue() const {\r\n    base::Value::Dict result;\r\n    result.Set(\"current_state\", GetCurrentStateName());\r\n    result.Set(\"transition_count\", static_cast<int>(transition_count_));\r\n    result.Set(\"uptime\", GetUptimeString());\r\n    result.Set(\"recent_transitions\", GetRecentTransitionsAsValue());\r\n    return result;\r\n  }\r\n};\r\n```\r\n\r\n### Performance Metrics Integration\r\n\r\n```cpp\r\n// Integration with Chromium's metrics system\r\nclass StateMetricsRecorder {\r\n public:\r\n  void RecordStateTransition(const std::string& state_machine_name,\r\n                           const std::string& from_state,\r\n                           const std::string& to_state,\r\n                           base::TimeDelta transition_duration) {\r\n    // Record UMA histogram\r\n    base::UmaHistogramTimes(\r\n        base::StrCat({\"StateTransition.\", state_machine_name, \".Duration\"}),\r\n        transition_duration);\r\n        \r\n    // Record state distribution\r\n    base::UmaHistogramEnumeration(\r\n        base::StrCat({\"StateTransition.\", state_machine_name, \".ToState\"}),\r\n        HashStateString(to_state));\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 10. Integration with Modern Chromium Architecture\r\n\r\n### Mojo Service Integration\r\n\r\nState machines in v134+ integrate seamlessly with Mojo services for cross-process state synchronization:\r\n\r\n```cpp\r\n// State coordination across process boundaries\r\ninterface StateCoordinator {\r\n  // Prepare for state transition\r\n  PrepareStateTransition(StateTransitionRequest request) \r\n      => (StateTransitionResponse response);\r\n  \r\n  // Commit state transition after coordination\r\n  CommitStateTransition(StateCommitRequest request);\r\n  \r\n  // Observer interface for state changes\r\n  AddStateObserver(pending_remote<StateObserver> observer);\r\n};\r\n```\r\n\r\n### Privacy Sandbox Integration\r\n\r\nState machines respect Privacy Sandbox boundaries and provide appropriate isolation:\r\n\r\n```cpp\r\n// Privacy-aware state management\r\nclass PrivacyAwareStateMachine {\r\n public:\r\n  // State transitions respect privacy context\r\n  bool CanTransitionTo(State new_state) const {\r\n    return IsValidTransition(current_state_, new_state) &&\r\n           privacy_policy_.AllowsStateTransition(current_state_, new_state);\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 11. References and Further Reading\r\n\r\n### Core Implementation Files\r\n- `base/state_machine/` - Base state machine utilities\r\n- `content/browser/navigation/navigation_request.h` - Navigation state management\r\n- `content/browser/download/download_item_impl.h` - Download state implementation  \r\n- `services/network/network_service.h` - Network service lifecycle states\r\n- `chrome/browser/privacy_sandbox/` - Privacy Sandbox state management\r\n\r\n### Architecture Documentation\r\n- [Process Model](../process-model.md) - Multi-process state coordination\r\n- [IPC Internals](../ipc-internals.md) - State synchronization via Mojo\r\n- [Security Model](../../security/security-model.md) - Security-aware state management\r\n\r\n### Modern C++ Patterns\r\n- [RAII Patterns](../design-patterns/raii-pattern.md) - Resource management in state machines\r\n- [Observer Pattern](../design-patterns/observer-pattern.md) - State change notification\r\n- [Factory Pattern](../design-patterns/factory-pattern.md) - State object creation\r\n\r\n### Testing and Debugging\r\n- [Testing Strategies](../../debugging/testing-strategies.md) - State machine testing approaches\r\n- [Chrome Internals](../../debugging/chrome-internals-urls.md) - State inspection tools\r\n\r\n---\r\n\r\nThe State pattern in modern Chromium v134+ demonstrates sophisticated software engineering with type safety, performance optimization, security awareness, and seamless integration with the browser's multi-process architecture. Understanding these patterns is essential for contributing to or extending Chromium's state management systems.\r\n"
  },
  {
    "path": "architecture/design-patterns/pre-post-contract",
    "title": "Contract Programming and Pre/Post Patterns in Modern Chromium (v134+)",
    "content": "# Contract Programming and Pre/Post Patterns in Modern Chromium (v134+)\r\n\r\nContract programming is a fundamental architectural principle in modern Chromium v134+, emphasizing **preconditions**, **postconditions**, and **invariants** to ensure reliable, secure, and maintainable software components. This approach has evolved significantly with modern C++20/23 features, Mojo services, and advanced error handling patterns like `base::expected`, providing formal contracts that improve code reliability, security, and performance.\r\n\r\n---\r\n\r\n## Modern Contract Programming in Chromium (v134+)\r\n\r\nContract programming in modern Chromium has evolved to leverage cutting-edge C++20/23 features and sophisticated error handling patterns. It defines formal, precise, and verifiable interfaces for software components through:\r\n\r\n- **Preconditions**: Conditions that must hold true before a function executes, validated using modern assertions and `base::expected`\r\n- **Postconditions**: Conditions guaranteed after successful function execution, enforced through RAII and result validation\r\n- **Invariants**: Properties that remain true throughout an object's lifetime, maintained via class design and security boundaries\r\n- **Error Contracts**: Explicit error handling using `base::expected<T, Error>` instead of exceptions\r\n- **Capability Contracts**: Security-oriented contracts that define what operations are permitted in different contexts\r\n\r\n### Modern Implementation Approaches (v134+)\r\n\r\n```cpp\r\n// Example: Modern contract programming with base::expected\r\nclass NetworkService {\r\n public:\r\n  // Precondition: url must be valid, context must be authenticated\r\n  // Postcondition: Returns success result or specific error\r\n  base::expected<std::unique_ptr<URLLoader>, NetworkError> \r\n  CreateURLLoader(const GURL& url, const SecurityContext& context) {\r\n    // Precondition validation\r\n    if (!url.is_valid()) {\r\n      return base::unexpected(NetworkError::kInvalidURL);\r\n    }\r\n    if (!context.IsAuthenticated()) {\r\n      return base::unexpected(NetworkError::kUnauthenticated);\r\n    }\r\n    \r\n    // Main operation with guaranteed postcondition\r\n    auto loader = CreateLoaderInternal(url, context);\r\n    DCHECK(loader);  // Postcondition: never returns null on success\r\n    return loader;\r\n  }\r\n};\r\n```\r\n\r\nAt its core, modern contract programming in Chromium relies on **compile-time validation**, **runtime assertions**, and **type-safe error handling**—ensuring that contract violations are caught early and handled gracefully.\r\n\r\n---\r\n\r\n## Contract Patterns in Modern Chromium (v134+)\r\n\r\nModern Chromium v134+ extensively implements contract programming through sophisticated architectural patterns that ensure security, performance, and reliability. This evolution goes far beyond simple assertions to include **service contracts**, **security validation**, and **cross-process guarantees**.\r\n\r\n### Service Lifecycle Contracts\r\n\r\nModern Chromium's service-oriented architecture relies heavily on contract programming for service initialization and coordination:\r\n\r\n```cpp\r\n// Modern service contract example\r\nclass DownloadService : public mojom::DownloadService {\r\n public:\r\n  // Contract: Service must be initialized before any operations\r\n  base::expected<void, ServiceError> Initialize(Profile* profile) {\r\n    // Preconditions\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    if (!profile || is_initialized_) {\r\n      return base::unexpected(ServiceError::kInvalidState);\r\n    }\r\n    \r\n    // Initialization with guaranteed postconditions\r\n    storage_partition_ = profile->GetStoragePartition();\r\n    network_context_ = storage_partition_->GetNetworkContext();\r\n    is_initialized_ = true;\r\n    \r\n    // Postcondition: Service is ready for operations\r\n    DCHECK(IsInitialized());\r\n    return base::ok();\r\n  }\r\n  \r\n  // Contract: StartDownload requires initialized service and valid parameters\r\n  void StartDownload(const GURL& url, \r\n                    mojo::PendingReceiver<mojom::DownloadController> receiver,\r\n                    StartDownloadCallback callback) override {\r\n    // Precondition validation\r\n    if (!IsInitialized()) {\r\n      std::move(callback).Run(DownloadResult::kServiceNotReady);\r\n      return;\r\n    }\r\n    \r\n    if (!url.is_valid() || !url.SchemeIsHTTPOrHTTPS()) {\r\n      std::move(callback).Run(DownloadResult::kInvalidURL);\r\n      return;\r\n    }\r\n    \r\n    // Execute with postcondition guarantee\r\n    StartDownloadInternal(url, std::move(receiver), std::move(callback));\r\n  }\r\n  \r\n private:\r\n  bool IsInitialized() const { return is_initialized_ && storage_partition_; }\r\n  \r\n  bool is_initialized_ = false;\r\n  StoragePartition* storage_partition_ = nullptr;\r\n  network::NetworkContext* network_context_ = nullptr;\r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n};\r\n```\r\n\r\n### Security Contract Validation\r\n\r\nModern Chromium implements rigorous security contracts that validate permissions and capabilities:\r\n\r\n```cpp\r\n// Security contract pattern for site isolation\r\nclass RenderFrameHostImpl {\r\n public:\r\n  // Contract: CreateChild requires valid security context and site isolation\r\n  base::expected<std::unique_ptr<RenderFrameHost>, SecurityError>\r\n  CreateChildFrame(const std::string& name, \r\n                   const blink::FramePolicy& frame_policy) {\r\n    // Security preconditions\r\n    if (!GetSiteInstance()->IsValid()) {\r\n      return base::unexpected(SecurityError::kInvalidSiteInstance);\r\n    }\r\n    \r\n    if (!CanCreateChildFrame(frame_policy)) {\r\n      return base::unexpected(SecurityError::kPermissionDenied);\r\n    }\r\n    \r\n    // Create with security guarantees\r\n    auto child_frame = CreateChildFrameInternal(name, frame_policy);\r\n    \r\n    // Postcondition: Child frame inherits security properties\r\n    DCHECK_EQ(child_frame->GetSiteInstance()->GetSiteURL(),\r\n              GetSiteInstance()->GetSiteURL());\r\n    \r\n    return child_frame;\r\n  }\r\n};\r\n```\r\n\r\nThis ensures that each component operates within well-defined security boundaries and adheres to site isolation requirements.\r\n\r\n---\r\n\r\n## Benefits of Modern Contract Programming (v134+)\r\n\r\nModern contract programming in Chromium v134+ provides significant advantages over traditional error handling and validation approaches:\r\n\r\n### 1. **Enhanced Security and Safety**\r\n- **Compile-time Validation**: Contracts catch errors during compilation using C++20 concepts\r\n- **Runtime Security**: Automatic validation of security contexts and permissions\r\n- **Memory Safety**: RAII-based contracts prevent resource leaks and use-after-free bugs\r\n- **Site Isolation**: Contracts enforce process boundaries and origin restrictions\r\n\r\n### 2. **Superior Error Handling**\r\n- **Explicit Error Contracts**: `base::expected<T, Error>` makes error paths visible and testable\r\n- **Graceful Degradation**: Well-defined failure modes instead of crashes or undefined behavior\r\n- **Error Propagation**: Structured error handling across service boundaries\r\n- **Debugging Support**: Clear contract violations with detailed error information\r\n\r\n### 3. **Performance and Reliability**\r\n- **Early Validation**: Preconditions prevent expensive operations on invalid inputs\r\n- **Predictable Behavior**: Postconditions guarantee consistent outcomes\r\n- **Optimized Code Paths**: Compiler optimizations based on contract assumptions\r\n- **Reduced Testing Overhead**: Contracts serve as executable specifications\r\n\r\n### 4. **Developer Experience**\r\n- **Self-Documenting Code**: Contracts make API expectations explicit\r\n- **IDE Integration**: Better code completion and error detection\r\n- **Refactoring Safety**: Contract violations are caught during code changes\r\n- **Onboarding Efficiency**: New developers understand system guarantees quickly\r\n\r\n### 5. **Cross-Process Reliability**\r\n- **Service Contracts**: Mojo interfaces with built-in validation and capability checking\r\n- **IPC Safety**: Type-safe communication with automatic serialization validation\r\n- **Process Isolation**: Contracts enforce security boundaries between processes\r\n- **Capability-Based Security**: Fine-grained permission contracts for system resources\r\n\r\n---\r\n\r\n## Modern C++ Contract Patterns (v134+)\r\n\r\nChromium v134+ leverages cutting-edge C++20/23 features to implement sophisticated contract patterns that provide compile-time safety, runtime validation, and elegant error handling.\r\n\r\n### 1. **Concept-Based Contracts**\r\n\r\nModern C++ concepts enable compile-time contract validation:\r\n\r\n```cpp\r\n// Concept defining contract requirements\r\ntemplate<typename T>\r\nconcept ValidNetworkRequest = requires(T request) {\r\n  { request.GetURL() } -> std::convertible_to<GURL>;\r\n  { request.IsValid() } -> std::convertible_to<bool>;\r\n  { request.GetSecurityLevel() } -> std::convertible_to<SecurityLevel>;\r\n};\r\n\r\n// Function with concept-based contract\r\ntemplate<ValidNetworkRequest RequestType>\r\nbase::expected<std::unique_ptr<URLLoader>, NetworkError>\r\nCreateSecureLoader(const RequestType& request) {\r\n  // Concept guarantees these methods exist and return correct types\r\n  static_assert(ValidNetworkRequest<RequestType>);\r\n  \r\n  if (!request.IsValid()) {\r\n    return base::unexpected(NetworkError::kInvalidRequest);\r\n  }\r\n  \r\n  return CreateLoaderForRequest(request);\r\n}\r\n```\r\n\r\n### 2. **RAII-Based Resource Contracts**\r\n\r\nModern RAII patterns ensure resource cleanup and state consistency:\r\n\r\n```cpp\r\n// RAII contract for GPU context management\r\nclass ScopedGPUContext {\r\n public:\r\n  // Contract: Constructor establishes valid GPU context\r\n  explicit ScopedGPUContext(viz::Display* display) \r\n      : display_(display), context_lost_(false) {\r\n    DCHECK(display_);\r\n    \r\n    // Precondition: Display must be valid\r\n    if (!display_->IsValid()) {\r\n      context_lost_ = true;\r\n      return;\r\n    }\r\n    \r\n    // Establish GPU context with guaranteed cleanup\r\n    context_ = display_->CreateContext();\r\n    DCHECK(context_ || context_lost_);\r\n  }\r\n  \r\n  // Contract: Destructor guarantees resource cleanup\r\n  ~ScopedGPUContext() {\r\n    if (context_ && !context_lost_) {\r\n      context_->Destroy();\r\n    }\r\n    // Postcondition: All resources cleaned up\r\n  }\r\n  \r\n  // Contract: IsValid indicates usable context\r\n  bool IsValid() const { \r\n    return context_ && !context_lost_; \r\n  }\r\n  \r\n  // Contract: GetContext only valid when IsValid() == true\r\n  viz::GLContext* GetContext() const {\r\n    DCHECK(IsValid());  // Precondition enforcement\r\n    return context_.get();\r\n  }\r\n  \r\n private:\r\n  viz::Display* display_;\r\n  std::unique_ptr<viz::GLContext> context_;\r\n  bool context_lost_;\r\n};\r\n```\r\n\r\n### 3. **Async Contract Patterns**\r\n\r\nModern async programming with contract guarantees:\r\n\r\n```cpp\r\n// Async contract pattern with base::expected\r\nclass AsyncDownloadManager {\r\n public:\r\n  // Contract: Async operation with guaranteed completion callback\r\n  void StartDownloadAsync(\r\n      const GURL& url,\r\n      base::OnceCallback<void(base::expected<DownloadId, DownloadError>)> callback) {\r\n    \r\n    // Precondition validation\r\n    if (!url.is_valid()) {\r\n      std::move(callback).Run(base::unexpected(DownloadError::kInvalidURL));\r\n      return;\r\n    }\r\n    \r\n    // Contract: Callback will be called exactly once\r\n    auto wrapped_callback = base::BindOnce(\r\n        [](base::OnceCallback<void(base::expected<DownloadId, DownloadError>)> cb,\r\n           base::expected<DownloadId, DownloadError> result) {\r\n          // Postcondition: Result is always valid (success or well-defined error)\r\n          DCHECK(result.has_value() || IsValidDownloadError(result.error()));\r\n          std::move(cb).Run(std::move(result));\r\n        }, \r\n        std::move(callback));\r\n    \r\n    // Start async operation\r\n    StartDownloadInternal(url, std::move(wrapped_callback));\r\n  }\r\n  \r\n private:\r\n  static bool IsValidDownloadError(DownloadError error) {\r\n    return error != DownloadError::kUnknown;\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## Mojo Service Contracts (v134+)\r\n\r\nChromium's Mojo IPC system implements sophisticated contract patterns for cross-process communication, ensuring type safety, capability validation, and security enforcement.\r\n\r\n### 1. **Interface Contracts**\r\n\r\nMojo interfaces define explicit contracts for cross-process communication:\r\n\r\n```cpp\r\n// Mojo interface with built-in contract validation\r\ninterface DownloadService {\r\n  // Contract: StartDownload validates parameters and returns status\r\n  StartDownload(url.mojom.Url download_url, \r\n               pending_receiver<DownloadController> controller)\r\n      => (DownloadResult result);\r\n  \r\n  // Contract: Observer must be valid and will receive notifications\r\n  AddObserver(pending_remote<DownloadObserver> observer);\r\n  \r\n  // Contract: Returns current downloads matching filter criteria\r\n  GetDownloads(DownloadFilter filter) \r\n      => (array<DownloadInfo> downloads);\r\n};\r\n\r\n// Implementation with contract enforcement\r\nclass DownloadServiceImpl : public mojom::DownloadService {\r\n public:\r\n  void StartDownload(\r\n      const GURL& url,\r\n      mojo::PendingReceiver<mojom::DownloadController> controller,\r\n      StartDownloadCallback callback) override {\r\n    \r\n    // Mojo contract: Validate receiver before proceeding\r\n    if (!controller.is_valid()) {\r\n      std::move(callback).Run(DownloadResult::kInvalidReceiver);\r\n      return;\r\n    }\r\n    \r\n    // Security contract: Validate URL permissions\r\n    if (!security_policy_->CanDownload(url, GetCurrentOrigin())) {\r\n      std::move(callback).Run(DownloadResult::kPermissionDenied);\r\n      return;\r\n    }\r\n    \r\n    // Business logic with guaranteed callback\r\n    auto download_id = CreateDownload(url);\r\n    BindController(std::move(controller), download_id);\r\n    std::move(callback).Run(DownloadResult::kSuccess);\r\n  }\r\n};\r\n```\r\n\r\n### 2. **Capability-Based Security Contracts**\r\n\r\nModern Mojo services implement capability-based security through contract validation:\r\n\r\n```cpp\r\n// Security contract for file system access\r\nclass FileSystemAccessService : public mojom::FileSystemAccessService {\r\n public:\r\n  void RequestFileAccess(\r\n      const base::FilePath& path,\r\n      FileAccessMode mode,\r\n      mojo::PendingRemote<mojom::FileAccessObserver> observer,\r\n      RequestFileAccessCallback callback) override {\r\n    \r\n    // Security contract: Validate capability tokens\r\n    auto capability_result = ValidateFileCapability(path, mode);\r\n    if (!capability_result.has_value()) {\r\n      std::move(callback).Run(\r\n          FileAccessResult::FromError(capability_result.error()));\r\n      return;\r\n    }\r\n    \r\n    // Privacy contract: Check user permissions\r\n    auto permission_result = CheckUserPermission(path, mode);\r\n    if (!permission_result.has_value()) {\r\n      std::move(callback).Run(\r\n          FileAccessResult::FromError(permission_result.error()));\r\n      return;\r\n    }\r\n    \r\n    // Contract fulfilled: Grant access with monitoring\r\n    auto access_token = GrantFileAccess(path, mode, std::move(observer));\r\n    std::move(callback).Run(FileAccessResult::FromToken(access_token));\r\n  }\r\n  \r\n private:\r\n  base::expected<void, SecurityError> ValidateFileCapability(\r\n      const base::FilePath& path, FileAccessMode mode) {\r\n    // Implement capability validation logic\r\n    if (!IsPathAllowed(path)) {\r\n      return base::unexpected(SecurityError::kPathNotAllowed);\r\n    }\r\n    if (!IsModeAllowed(mode)) {\r\n      return base::unexpected(SecurityError::kModeNotAllowed);\r\n    }\r\n    return base::ok();\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## Modern Contract Implementation in Practice (v134+)\r\n\r\nModern Chromium v134+ implements contract patterns throughout its architecture, from browser initialization to service lifecycle management and security enforcement.\r\n\r\n### 1. **Enhanced Browser Initialization Contracts**\r\n\r\nThe modern browser startup sequence implements sophisticated contract patterns:\r\n\r\n```cpp\r\n// Modern BrowserMainParts with contract validation\r\nclass ChromeBrowserMainParts : public content::BrowserMainParts {\r\n public:\r\n  // Contract: PreCreateMainMessageLoop establishes prerequisites\r\n  base::expected<void, StartupError> PreCreateMainMessageLoop() override {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    // Precondition: System must meet minimum requirements\r\n    auto system_check = ValidateSystemRequirements();\r\n    if (!system_check.has_value()) {\r\n      return base::unexpected(system_check.error());\r\n    }\r\n    \r\n    // Initialize with guaranteed postconditions\r\n    auto init_result = InitializePlatformSupport();\r\n    if (!init_result.has_value()) {\r\n      return base::unexpected(init_result.error());\r\n    }\r\n    \r\n    // Postcondition: Platform support is ready\r\n    DCHECK(IsPlatformSupportInitialized());\r\n    return base::ok();\r\n  }\r\n  \r\n  // Contract: PostCreateMainMessageLoop configures services\r\n  void PostCreateMainMessageLoop() override {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    DCHECK(IsPlatformSupportInitialized());  // Precondition from previous stage\r\n    \r\n    // Service initialization with dependency contracts\r\n    InitializeServiceManagerWithContracts();\r\n    \r\n    // Postcondition: All essential services are available\r\n    DCHECK(AreEssentialServicesReady());\r\n  }\r\n  \r\n private:\r\n  void InitializeServiceManagerWithContracts() {\r\n    // Each service has initialization contracts\r\n    auto audio_result = InitializeAudioService();\r\n    DCHECK(audio_result.has_value()) << \"Audio service failed: \" \r\n                                     << static_cast<int>(audio_result.error());\r\n    \r\n    auto network_result = InitializeNetworkService();\r\n    DCHECK(network_result.has_value()) << \"Network service failed: \"\r\n                                       << static_cast<int>(network_result.error());\r\n  }\r\n  \r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n};\r\n```\r\n\r\n### 2. **Service Dependency Contracts**\r\n\r\nModern services implement explicit dependency contracts:\r\n\r\n```cpp\r\n// Service with dependency contract validation\r\nclass MediaService : public mojom::MediaService {\r\n public:\r\n  // Contract: Initialize with required dependencies\r\n  static base::expected<std::unique_ptr<MediaService>, ServiceError>\r\n  Create(ServiceDependencies deps) {\r\n    // Validate all required dependencies\r\n    if (!deps.audio_manager || !deps.gpu_service || !deps.storage_partition) {\r\n      return base::unexpected(ServiceError::kMissingDependencies);\r\n    }\r\n    \r\n    auto service = base::WrapUnique(new MediaService(std::move(deps)));\r\n    \r\n    // Postcondition: Service is ready for media operations\r\n    DCHECK(service->IsReadyForMediaOperations());\r\n    return service;\r\n  }\r\n  \r\n  // Contract: CreateMediaSession requires valid context\r\n  void CreateMediaSession(\r\n      mojo::PendingReceiver<mojom::MediaSession> receiver,\r\n      const MediaSessionConfig& config,\r\n      CreateMediaSessionCallback callback) override {\r\n    \r\n    // Precondition validation\r\n    if (!receiver.is_valid() || !IsValidConfig(config)) {\r\n      std::move(callback).Run(MediaSessionResult::kInvalidParameters);\r\n      return;\r\n    }\r\n    \r\n    // Security contract: Validate permissions\r\n    if (!HasMediaPermission(config.origin)) {\r\n      std::move(callback).Run(MediaSessionResult::kPermissionDenied);\r\n      return;\r\n    }\r\n    \r\n    // Create session with postcondition guarantee\r\n    auto session = CreateSessionInternal(config);\r\n    BindSession(std::move(receiver), std::move(session));\r\n    std::move(callback).Run(MediaSessionResult::kSuccess);\r\n  }\r\n  \r\n private:\r\n  explicit MediaService(ServiceDependencies deps) : deps_(std::move(deps)) {}\r\n  \r\n  bool IsReadyForMediaOperations() const {\r\n    return deps_.audio_manager && deps_.gpu_service && deps_.storage_partition;\r\n  }\r\n  \r\n  ServiceDependencies deps_;\r\n};\r\n```\r\n\r\n### 3. **Performance Contract Monitoring**\r\n\r\nModern Chromium implements performance contracts with real-time monitoring:\r\n\r\n```cpp\r\n// Performance contract with Core Web Vitals validation\r\nclass RenderFrameMetricsCollector {\r\n public:\r\n  // Contract: ReportMetrics validates performance thresholds\r\n  void ReportCoreWebVitals(const CoreWebVitalsData& data) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    // Performance contract validation\r\n    auto validation_result = ValidatePerformanceContract(data);\r\n    if (!validation_result.has_value()) {\r\n      ReportPerformanceViolation(validation_result.error());\r\n      return;\r\n    }\r\n    \r\n    // Update metrics with contract compliance\r\n    UpdateMetricsWithValidation(data);\r\n    \r\n    // Postcondition: Metrics are consistent and within bounds\r\n    DCHECK(AreMetricsConsistent());\r\n  }\r\n  \r\n private:\r\n  base::expected<void, PerformanceError> ValidatePerformanceContract(\r\n      const CoreWebVitalsData& data) {\r\n    // Contract: LCP should be reasonable (< 10 seconds)\r\n    if (data.largest_contentful_paint > base::Seconds(10)) {\r\n      return base::unexpected(PerformanceError::kUnreasonableLCP);\r\n    }\r\n    \r\n    // Contract: FID should be valid (>= 0)\r\n    if (data.first_input_delay < base::TimeDelta()) {\r\n      return base::unexpected(PerformanceError::kInvalidFID);\r\n    }\r\n    \r\n    // Contract: CLS should be in valid range [0.0, 5.0]\r\n    if (data.cumulative_layout_shift < 0.0 || \r\n        data.cumulative_layout_shift > 5.0) {\r\n      return base::unexpected(PerformanceError::kInvalidCLS);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n  \r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n};\r\n```\r\n\r\n---\r\n\r\n## Security Contract Patterns (v134+)\r\n\r\nModern Chromium implements sophisticated security contract patterns that enforce isolation, validate permissions, and prevent security vulnerabilities through compile-time and runtime guarantees.\r\n\r\n### 1. **Site Isolation Security Contracts**\r\n\r\nSite isolation relies on strict contracts to maintain security boundaries:\r\n\r\n```cpp\r\n// Site isolation contract enforcement\r\nclass SiteInstanceImpl : public SiteInstance {\r\n public:\r\n  // Contract: CreateRelatedSiteInstance maintains security invariants\r\n  static base::expected<scoped_refptr<SiteInstance>, SecurityError>\r\n  CreateRelatedSiteInstance(BrowserContext* context, \r\n                           const GURL& url,\r\n                           const SiteInstance* initiator) {\r\n    // Security preconditions\r\n    if (!context || !initiator) {\r\n      return base::unexpected(SecurityError::kInvalidContext);\r\n    }\r\n    \r\n    if (!url.is_valid() || url.is_empty()) {\r\n      return base::unexpected(SecurityError::kInvalidURL);\r\n    }\r\n    \r\n    // Site isolation contract: Validate cross-origin constraints\r\n    auto site_url = GetSiteForURL(url);\r\n    if (ShouldIsolateSite(context, site_url)) {\r\n      auto validation_result = ValidateSiteIsolationContract(\r\n          initiator->GetSiteURL(), site_url);\r\n      if (!validation_result.has_value()) {\r\n        return base::unexpected(validation_result.error());\r\n      }\r\n    }\r\n    \r\n    // Create with security guarantees\r\n    auto site_instance = base::WrapRefCounted(\r\n        new SiteInstanceImpl(context, site_url));\r\n    \r\n    // Postcondition: Site instance maintains isolation boundaries\r\n    DCHECK(site_instance->IsIsolatedFromOtherSites());\r\n    return site_instance;\r\n  }\r\n  \r\n private:\r\n  static base::expected<void, SecurityError> ValidateSiteIsolationContract(\r\n      const GURL& initiator_site, const GURL& target_site) {\r\n    // Contract: Cross-origin navigations require proper validation\r\n    if (url::Origin::Create(initiator_site) != url::Origin::Create(target_site)) {\r\n      if (!CanNavigateCrossOrigin(initiator_site, target_site)) {\r\n        return base::unexpected(SecurityError::kCrossOriginViolation);\r\n      }\r\n    }\r\n    return base::ok();\r\n  }\r\n};\r\n```\r\n\r\n### 2. **Permission System Contracts**\r\n\r\nModern permission contracts ensure secure capability delegation:\r\n\r\n```cpp\r\n// Permission contract with capability validation\r\nclass PermissionManagerImpl {\r\n public:\r\n  // Contract: RequestPermission validates security context and user intent\r\n  void RequestPermission(\r\n      blink::mojom::PermissionName permission,\r\n      RenderFrameHost* render_frame_host,\r\n      const GURL& requesting_origin,\r\n      bool user_gesture,\r\n      base::OnceCallback<void(blink::mojom::PermissionStatus)> callback) {\r\n    \r\n    // Security contract preconditions\r\n    auto validation_result = ValidatePermissionRequest(\r\n        permission, render_frame_host, requesting_origin, user_gesture);\r\n    if (!validation_result.has_value()) {\r\n      std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\r\n      return;\r\n    }\r\n    \r\n    // Privacy contract: Check Privacy Sandbox compliance\r\n    if (IsPrivacySandboxPermission(permission)) {\r\n      auto privacy_result = ValidatePrivacySandboxContract(\r\n          requesting_origin, permission);\r\n      if (!privacy_result.has_value()) {\r\n        std::move(callback).Run(blink::mojom::PermissionStatus::DENIED);\r\n        return;\r\n      }\r\n    }\r\n    \r\n    // Execute permission flow with guaranteed callback\r\n    ProcessPermissionRequestWithContract(\r\n        permission, render_frame_host, requesting_origin, std::move(callback));\r\n  }\r\n  \r\n private:\r\n  base::expected<void, SecurityError> ValidatePermissionRequest(\r\n      blink::mojom::PermissionName permission,\r\n      RenderFrameHost* render_frame_host,\r\n      const GURL& requesting_origin,\r\n      bool user_gesture) {\r\n    \r\n    // Contract: Frame must be valid and live\r\n    if (!render_frame_host || !render_frame_host->IsRenderFrameLive()) {\r\n      return base::unexpected(SecurityError::kInvalidFrame);\r\n    }\r\n    \r\n    // Contract: Powerful features require user gesture\r\n    if (IsPowerfulFeature(permission) && !user_gesture) {\r\n      return base::unexpected(SecurityError::kNoUserGesture);\r\n    }\r\n    \r\n    // Contract: Origin must match frame's committed origin\r\n    auto frame_origin = render_frame_host->GetLastCommittedOrigin();\r\n    if (frame_origin != url::Origin::Create(requesting_origin)) {\r\n      return base::unexpected(SecurityError::kOriginMismatch);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n  \r\n  base::expected<void, PrivacyError> ValidatePrivacySandboxContract(\r\n      const GURL& origin, blink::mojom::PermissionName permission) {\r\n    // Privacy contract: Validate Topics API usage\r\n    if (permission == blink::mojom::PermissionName::TOPICS_API) {\r\n      if (!IsTopicsAPIAllowed(origin)) {\r\n        return base::unexpected(PrivacyError::kTopicsNotAllowed);\r\n      }\r\n    }\r\n    \r\n    // Privacy contract: Validate FLEDGE usage\r\n    if (permission == blink::mojom::PermissionName::FLEDGE_API) {\r\n      if (!IsFledgeAPIAllowed(origin)) {\r\n        return base::unexpected(PrivacyError::kFledgeNotAllowed);\r\n      }\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n};\r\n```\r\n\r\n### 3. **Mojo Security Contracts**\r\n\r\nCross-process security contracts ensure safe IPC communication:\r\n\r\n```cpp\r\n// Mojo security contract for sensitive operations\r\nclass CryptographyService : public mojom::CryptographyService {\r\n public:\r\n  // Contract: EncryptData validates security context and data integrity\r\n  void EncryptData(\r\n      const std::vector<uint8_t>& plaintext,\r\n      const std::string& key_id,\r\n      mojo::PendingRemote<mojom::CryptographyObserver> observer,\r\n      EncryptDataCallback callback) override {\r\n    \r\n    // Security contract: Validate caller privileges\r\n    auto security_result = ValidateCallerSecurityContract();\r\n    if (!security_result.has_value()) {\r\n      std::move(callback).Run(CryptographyResult::FromError(security_result.error()));\r\n      return;\r\n    }\r\n    \r\n    // Data contract: Validate input parameters\r\n    if (plaintext.empty() || key_id.empty()) {\r\n      std::move(callback).Run(CryptographyResult::FromError(\r\n          CryptographyError::kInvalidParameters));\r\n      return;\r\n    }\r\n    \r\n    // Key management contract: Validate key access\r\n    auto key_result = ValidateKeyAccessContract(key_id);\r\n    if (!key_result.has_value()) {\r\n      std::move(callback).Run(CryptographyResult::FromError(key_result.error()));\r\n      return;\r\n    }\r\n    \r\n    // Execute with security monitoring\r\n    PerformEncryptionWithMonitoring(\r\n        plaintext, key_id, std::move(observer), std::move(callback));\r\n  }\r\n  \r\n private:\r\n  base::expected<void, SecurityError> ValidateCallerSecurityContract() {\r\n    // Contract: Caller must have cryptography capability\r\n    auto* current_context = mojo::GetMessageContext();\r\n    if (!current_context || !current_context->HasCapability(\"cryptography\")) {\r\n      return base::unexpected(SecurityError::kInsufficientCapabilities);\r\n    }\r\n    \r\n    // Contract: Process must be properly sandboxed\r\n    if (!IsCallerProperlySandboxed()) {\r\n      return base::unexpected(SecurityError::kSandboxViolation);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n  \r\n  base::expected<void, CryptographyError> ValidateKeyAccessContract(\r\n      const std::string& key_id) {\r\n    // Contract: Key must exist and be accessible\r\n    if (!key_store_->KeyExists(key_id)) {\r\n      return base::unexpected(CryptographyError::kKeyNotFound);\r\n    }\r\n    \r\n    // Contract: Caller must have permission for this key\r\n    if (!key_store_->CanAccessKey(key_id, GetCallerIdentity())) {\r\n      return base::unexpected(CryptographyError::kKeyAccessDenied);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## Performance Contract Patterns (v134+)\r\n\r\nModern Chromium implements performance contracts that ensure optimal user experience through measurable guarantees and real-time monitoring.\r\n\r\n### 1. **Core Web Vitals Performance Contracts**\r\n\r\nPerformance contracts ensure adherence to Core Web Vitals standards:\r\n\r\n```cpp\r\n// Core Web Vitals contract enforcement\r\nclass PagePerformanceManager {\r\n public:\r\n  // Contract: TrackPageLoad ensures performance metrics collection\r\n  void TrackPageLoad(content::WebContents* web_contents,\r\n                    const GURL& url,\r\n                    base::OnceCallback<void(PerformanceReport)> callback) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    // Performance contract preconditions\r\n    if (!web_contents || !url.is_valid()) {\r\n      std::move(callback).Run(PerformanceReport::CreateError(\r\n          PerformanceError::kInvalidParameters));\r\n      return;\r\n    }\r\n    \r\n    // Contract: Start performance monitoring with guaranteed reporting\r\n    auto tracker = CreatePerformanceTracker(web_contents, url);\r\n    tracker->SetPerformanceContract(CreateCoreWebVitalsContract());\r\n    \r\n    // Contract: Callback will be called with complete metrics\r\n    auto wrapped_callback = base::BindOnce(\r\n        &PagePerformanceManager::ValidateAndReportPerformance,\r\n        weak_factory_.GetWeakPtr(), std::move(callback));\r\n    \r\n    tracker->StartTracking(std::move(wrapped_callback));\r\n  }\r\n  \r\n private:\r\n  PerformanceContract CreateCoreWebVitalsContract() {\r\n    PerformanceContract contract;\r\n    \r\n    // LCP contract: Largest Contentful Paint < 2.5s for good rating\r\n    contract.AddMetricContract(\r\n        MetricType::kLargestContentfulPaint,\r\n        MetricThreshold{\r\n          .good_threshold = base::Milliseconds(2500),\r\n          .needs_improvement_threshold = base::Milliseconds(4000),\r\n          .violation_action = ViolationAction::kReportAndOptimize\r\n        });\r\n    \r\n    // FID contract: First Input Delay < 100ms for good rating\r\n    contract.AddMetricContract(\r\n        MetricType::kFirstInputDelay,\r\n        MetricThreshold{\r\n          .good_threshold = base::Milliseconds(100),\r\n          .needs_improvement_threshold = base::Milliseconds(300),\r\n          .violation_action = ViolationAction::kReportAndOptimize\r\n        });\r\n    \r\n    // CLS contract: Cumulative Layout Shift < 0.1 for good rating\r\n    contract.AddMetricContract(\r\n        MetricType::kCumulativeLayoutShift,\r\n        MetricThreshold{\r\n          .good_threshold = 0.1,\r\n          .needs_improvement_threshold = 0.25,\r\n          .violation_action = ViolationAction::kReportAndOptimize\r\n        });\r\n    \r\n    return contract;\r\n  }\r\n  \r\n  void ValidateAndReportPerformance(\r\n      base::OnceCallback<void(PerformanceReport)> callback,\r\n      const PerformanceMetrics& metrics) {\r\n    \r\n    // Contract validation: All required metrics must be present\r\n    auto validation_result = ValidateMetricsCompleteness(metrics);\r\n    if (!validation_result.has_value()) {\r\n      std::move(callback).Run(PerformanceReport::CreateError(\r\n          validation_result.error()));\r\n      return;\r\n    }\r\n    \r\n    // Performance contract evaluation\r\n    auto report = EvaluatePerformanceContracts(metrics);\r\n    \r\n    // Contract: Report violations for optimization\r\n    if (report.HasViolations()) {\r\n      TriggerPerformanceOptimization(report.GetViolations());\r\n    }\r\n    \r\n    std::move(callback).Run(std::move(report));\r\n  }\r\n  \r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n  base::WeakPtrFactory<PagePerformanceManager> weak_factory_{this};\r\n};\r\n```\r\n\r\n### 2. **Memory Usage Contracts**\r\n\r\nMemory management contracts prevent resource exhaustion:\r\n\r\n```cpp\r\n// Memory usage contract with automatic enforcement\r\nclass MemoryManager {\r\n public:\r\n  // Contract: AllocateMemory enforces memory limits and tracking\r\n  base::expected<std::unique_ptr<MemoryBlock>, MemoryError>\r\n  AllocateMemory(size_t size, MemoryPriority priority) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    // Memory contract preconditions\r\n    if (size == 0 || size > kMaxAllocationSize) {\r\n      return base::unexpected(MemoryError::kInvalidSize);\r\n    }\r\n    \r\n    // Contract: Check memory availability before allocation\r\n    auto availability_check = CheckMemoryAvailability(size, priority);\r\n    if (!availability_check.has_value()) {\r\n      return base::unexpected(availability_check.error());\r\n    }\r\n    \r\n    // Contract: Track allocation for lifecycle management\r\n    auto memory_block = AllocateWithTracking(size, priority);\r\n    if (!memory_block) {\r\n      return base::unexpected(MemoryError::kAllocationFailed);\r\n    }\r\n    \r\n    // Postcondition: Memory is tracked and within limits\r\n    DCHECK(IsMemoryWithinLimits());\r\n    return memory_block;\r\n  }\r\n  \r\n  // Contract: Memory pressure triggers managed cleanup\r\n  void HandleMemoryPressure(MemoryPressureLevel level) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    switch (level) {\r\n      case MemoryPressureLevel::kModerate:\r\n        // Contract: Free low-priority allocations\r\n        FreeLowPriorityMemory();\r\n        break;\r\n        \r\n      case MemoryPressureLevel::kCritical:\r\n        // Contract: Aggressive cleanup to prevent OOM\r\n        FreeNonEssentialMemory();\r\n        TriggerGarbageCollection();\r\n        break;\r\n    }\r\n    \r\n    // Postcondition: Memory usage reduced appropriately\r\n    DCHECK(IsMemoryUsageAppropriate(level));\r\n  }\r\n  \r\n private:\r\n  base::expected<void, MemoryError> CheckMemoryAvailability(\r\n      size_t size, MemoryPriority priority) {\r\n    \r\n    // Contract: High-priority allocations have reserved capacity\r\n    size_t available_memory = GetAvailableMemory();\r\n    if (priority == MemoryPriority::kHigh) {\r\n      if (size > available_memory + GetReservedMemory()) {\r\n        return base::unexpected(MemoryError::kInsufficientMemory);\r\n      }\r\n    } else {\r\n      if (size > available_memory) {\r\n        return base::unexpected(MemoryError::kInsufficientMemory);\r\n      }\r\n    }\r\n    \r\n    // Contract: Total memory usage stays within system limits\r\n    if (GetTotalMemoryUsage() + size > GetMemoryLimit()) {\r\n      return base::unexpected(MemoryError::kMemoryLimitExceeded);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n  \r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n};\r\n```\r\n\r\n### 3. **Thread Safety Contracts**\r\n\r\nThread safety contracts ensure correct concurrent behavior:\r\n\r\n```cpp\r\n// Thread safety contract with sequence validation\r\nclass ThreadSafeCache {\r\n public:\r\n  // Contract: Get operation is thread-safe and returns valid data\r\n  base::expected<CacheEntry, CacheError> Get(const std::string& key) {\r\n    base::AutoLock lock(cache_lock_);\r\n    \r\n    // Thread safety contract: Validate key before access\r\n    if (key.empty()) {\r\n      return base::unexpected(CacheError::kInvalidKey);\r\n    }\r\n    \r\n    // Contract: Return valid entry or explicit miss\r\n    auto it = cache_entries_.find(key);\r\n    if (it == cache_entries_.end()) {\r\n      return base::unexpected(CacheError::kEntryNotFound);\r\n    }\r\n    \r\n    // Contract: Validate entry freshness\r\n    if (IsEntryExpired(it->second)) {\r\n      cache_entries_.erase(it);\r\n      return base::unexpected(CacheError::kEntryExpired);\r\n    }\r\n    \r\n    // Postcondition: Return valid, fresh cache entry\r\n    return it->second;\r\n  }\r\n  \r\n  // Contract: Set operation maintains cache invariants\r\n  void Set(const std::string& key, CacheEntry entry) {\r\n    base::AutoLock lock(cache_lock_);\r\n    \r\n    // Contract: Enforce cache size limits\r\n    if (cache_entries_.size() >= kMaxCacheSize) {\r\n      EvictLeastRecentlyUsed();\r\n    }\r\n    \r\n    // Contract: Entry is valid and properly timestamped\r\n    entry.access_time = base::TimeTicks::Now();\r\n    cache_entries_[key] = std::move(entry);\r\n    \r\n    // Postcondition: Cache remains within size limits\r\n    DCHECK_LE(cache_entries_.size(), kMaxCacheSize);\r\n  }\r\n  \r\n private:\r\n  mutable base::Lock cache_lock_;\r\n  std::unordered_map<std::string, CacheEntry> cache_entries_ GUARDED_BY(cache_lock_);\r\n  static constexpr size_t kMaxCacheSize = 1000;\r\n};\r\n```\r\n\r\n---\r\n\r\n## Testing Contract Patterns (v134+)\r\n\r\nModern Chromium employs sophisticated testing strategies that validate contract adherence, ensuring that preconditions, postconditions, and error handling work correctly across all scenarios.\r\n\r\n### 1. **Google Mock Contract Validation**\r\n\r\nContract testing with Google Mock ensures proper validation and error handling:\r\n\r\n```cpp\r\n// Mock class for testing contract validation\r\nclass MockNetworkService : public NetworkService {\r\n public:\r\n  MOCK_METHOD(base::expected<std::unique_ptr<URLLoader>, NetworkError>,\r\n              CreateURLLoader,\r\n              (const GURL& url, const SecurityContext& context),\r\n              (override));\r\n  \r\n  MOCK_METHOD(void, \r\n              ValidateSecurityContext,\r\n              (const SecurityContext& context),\r\n              (const));\r\n};\r\n\r\n// Test fixture for contract validation\r\nclass NetworkServiceContractTest : public testing::Test {\r\n protected:\r\n  void SetUp() override {\r\n    mock_network_service_ = std::make_unique<MockNetworkService>();\r\n    security_context_ = CreateValidSecurityContext();\r\n  }\r\n  \r\n  std::unique_ptr<MockNetworkService> mock_network_service_;\r\n  SecurityContext security_context_;\r\n};\r\n\r\n// Test contract precondition violations\r\nTEST_F(NetworkServiceContractTest, CreateURLLoaderRejectsInvalidURL) {\r\n  const GURL invalid_url(\"\");  // Empty URL violates precondition\r\n  \r\n  // Expect contract violation to be handled gracefully\r\n  EXPECT_CALL(*mock_network_service_, CreateURLLoader(invalid_url, security_context_))\r\n      .WillOnce(testing::Return(base::unexpected(NetworkError::kInvalidURL)));\r\n  \r\n  auto result = mock_network_service_->CreateURLLoader(invalid_url, security_context_);\r\n  \r\n  // Verify contract enforcement\r\n  ASSERT_FALSE(result.has_value());\r\n  EXPECT_EQ(result.error(), NetworkError::kInvalidURL);\r\n}\r\n\r\n// Test contract postcondition guarantees\r\nTEST_F(NetworkServiceContractTest, CreateURLLoaderGuaranteesValidResult) {\r\n  const GURL valid_url(\"https://example.com\");\r\n  auto expected_loader = std::make_unique<MockURLLoader>();\r\n  auto* expected_loader_ptr = expected_loader.get();\r\n  \r\n  // Mock successful creation with postcondition guarantee\r\n  EXPECT_CALL(*mock_network_service_, CreateURLLoader(valid_url, security_context_))\r\n      .WillOnce(testing::Return(testing::ByMove(std::move(expected_loader))));\r\n  \r\n  auto result = mock_network_service_->CreateURLLoader(valid_url, security_context_);\r\n  \r\n  // Verify postcondition: successful result contains valid loader\r\n  ASSERT_TRUE(result.has_value());\r\n  EXPECT_EQ(result.value().get(), expected_loader_ptr);\r\n  EXPECT_NE(result.value().get(), nullptr);  // Postcondition: never null on success\r\n}\r\n\r\n// Test error contract propagation\r\nTEST_F(NetworkServiceContractTest, ErrorContractsPropagateCorrectly) {\r\n  const GURL valid_url(\"https://example.com\");\r\n  SecurityContext invalid_context;  // Unauthenticated context\r\n  \r\n  // Test each possible error condition\r\n  std::vector<std::pair<SecurityContext, NetworkError>> error_cases = {\r\n    {invalid_context, NetworkError::kUnauthenticated},\r\n    {CreateExpiredSecurityContext(), NetworkError::kExpiredCredentials},\r\n    {CreateRevokedSecurityContext(), NetworkError::kAccessRevoked}\r\n  };\r\n  \r\n  for (const auto& [context, expected_error] : error_cases) {\r\n    EXPECT_CALL(*mock_network_service_, CreateURLLoader(valid_url, context))\r\n        .WillOnce(testing::Return(base::unexpected(expected_error)));\r\n    \r\n    auto result = mock_network_service_->CreateURLLoader(valid_url, context);\r\n    \r\n    ASSERT_FALSE(result.has_value()) << \"Expected error for context type\";\r\n    EXPECT_EQ(result.error(), expected_error) << \"Error contract mismatch\";\r\n  }\r\n}\r\n```\r\n\r\n### 2. **Contract Violation Testing**\r\n\r\nSystematic testing of contract violations ensures robust error handling:\r\n\r\n```cpp\r\n// Test fixture for contract violation scenarios\r\nclass ContractViolationTest : public testing::Test {\r\n protected:\r\n  void SetUp() override {\r\n    download_service_ = std::make_unique<DownloadServiceImpl>(\r\n        CreateTestProfile());\r\n  }\r\n  \r\n  // Helper method to create invalid test scenarios\r\n  template<typename ContractViolation>\r\n  void TestContractViolation(ContractViolation violation,\r\n                            const std::string& expected_error_message) {\r\n    // Enable contract violation reporting for testing\r\n    base::test::ScopedFeatureList feature_list;\r\n    feature_list.InitAndEnableFeature(features::kStrictContractValidation);\r\n    \r\n    // Set up violation detection\r\n    bool violation_detected = false;\r\n    std::string violation_message;\r\n    \r\n    SetContractViolationHandler([&](const std::string& message) {\r\n      violation_detected = true;\r\n      violation_message = message;\r\n    });\r\n    \r\n    // Execute the violation scenario\r\n    violation();\r\n    \r\n    // Verify contract violation was detected\r\n    EXPECT_TRUE(violation_detected) << \"Contract violation not detected\";\r\n    EXPECT_THAT(violation_message, testing::HasSubstr(expected_error_message));\r\n  }\r\n  \r\n  std::unique_ptr<DownloadServiceImpl> download_service_;\r\n};\r\n\r\nTEST_F(ContractViolationTest, DetectsInvalidStateTransition) {\r\n  TestContractViolation(\r\n    [this]() {\r\n      // Violate contract: Call StartDownload on uninitialized service\r\n      download_service_->StartDownload(\r\n          GURL(\"https://example.com/file.pdf\"), \r\n          mojo::NullReceiver(), \r\n          base::DoNothing());\r\n    },\r\n    \"Service not initialized\"\r\n  );\r\n}\r\n\r\nTEST_F(ContractViolationTest, DetectsResourceLeaks) {\r\n  TestContractViolation(\r\n    [this]() {\r\n      // Violate contract: Create resource without proper cleanup\r\n      auto resource = download_service_->CreateTempResource();\r\n      // Intentionally don't clean up to trigger contract violation\r\n    },\r\n    \"Resource leak detected\"\r\n  );\r\n}\r\n```\r\n\r\n### 3. **Integration Contract Testing**\r\n\r\nEnd-to-end testing of contract interactions across components:\r\n\r\n```cpp\r\n// Integration test for cross-service contract validation\r\nclass ServiceContractIntegrationTest : public testing::Test {\r\n protected:\r\n  void SetUp() override {\r\n    // Set up service chain with contract validation enabled\r\n    network_service_ = CreateNetworkServiceWithContracts();\r\n    download_service_ = CreateDownloadServiceWithContracts(network_service_.get());\r\n    storage_service_ = CreateStorageServiceWithContracts();\r\n    \r\n    // Enable contract monitoring across services\r\n    EnableCrossServiceContractMonitoring();\r\n  }\r\n  \r\n  void TearDown() override {\r\n    // Verify all contracts were maintained during test\r\n    VerifyNoContractViolations();\r\n  }\r\n  \r\n  std::unique_ptr<NetworkService> network_service_;\r\n  std::unique_ptr<DownloadService> download_service_;\r\n  std::unique_ptr<StorageService> storage_service_;\r\n};\r\n\r\nTEST_F(ServiceContractIntegrationTest, DownloadFlowMaintainsAllContracts) {\r\n  const GURL download_url(\"https://example.com/large-file.zip\");\r\n  \r\n  // Contract: Download request should succeed with valid parameters\r\n  base::RunLoop download_started_loop;\r\n  download_service_->StartDownload(\r\n      download_url,\r\n      CreateMockDownloadReceiver(),\r\n      base::BindLambdaForTesting([&](DownloadResult result) {\r\n        EXPECT_EQ(result, DownloadResult::kSuccess);\r\n        download_started_loop.Quit();\r\n      }));\r\n  \r\n  download_started_loop.Run();\r\n  \r\n  // Contract: Network service should receive valid requests\r\n  EXPECT_TRUE(network_service_->ReceivedValidRequest(download_url));\r\n  \r\n  // Contract: Storage service should be prepared for data\r\n  EXPECT_TRUE(storage_service_->HasAvailableSpace());\r\n  \r\n  // Simulate download progress with contract validation\r\n  SimulateDownloadProgressWithContracts();\r\n  \r\n  // Contract: All services should maintain their invariants\r\n  EXPECT_TRUE(network_service_->MaintainsInvariants());\r\n  EXPECT_TRUE(download_service_->MaintainsInvariants());\r\n  EXPECT_TRUE(storage_service_->MaintainsInvariants());\r\n}\r\n```\r\n\r\n---\r\n\r\n## Real-World v134+ Examples\r\n\r\nModern Chromium's contract programming patterns are implemented throughout the codebase, providing concrete examples of sophisticated contract enforcement.\r\n\r\n### 1. **RenderFrameHost Contract Implementation**\r\n\r\nReal-world security contract in frame management:\r\n\r\n```cpp\r\n// Simplified from content/browser/renderer_host/render_frame_host_impl.cc\r\nclass RenderFrameHostImpl : public RenderFrameHost {\r\n public:\r\n  // Contract: CreateChildFrame maintains site isolation invariants\r\n  RenderFrameHost* CreateChildFrame(\r\n      int new_routing_id,\r\n      mojo::PendingAssociatedRemote<mojom::Frame> frame_remote,\r\n      blink::mojom::PolicyContainerBindParamsPtr policy_container_bind_params,\r\n      blink::mojom::TreeScopeType scope,\r\n      const std::string& frame_name,\r\n      const std::string& frame_unique_name,\r\n      bool is_created_by_script,\r\n      const blink::LocalFrameToken& frame_token,\r\n      const base::UnguessableToken& devtools_frame_token,\r\n      const blink::FramePolicy& frame_policy) {\r\n    \r\n    // Security contract: Validate frame creation parameters\r\n    if (!ValidateFrameCreationContract(new_routing_id, frame_token, frame_policy)) {\r\n      RecordContractViolation(\"CreateChildFrame: Invalid parameters\");\r\n      return nullptr;\r\n    }\r\n    \r\n    // Site isolation contract: Ensure proper origin separation\r\n    auto site_instance_result = GetSiteInstanceForChildFrame(frame_policy);\r\n    if (!site_instance_result.has_value()) {\r\n      RecordContractViolation(\"CreateChildFrame: Site isolation violation\");\r\n      return nullptr;\r\n    }\r\n    \r\n    // Create child with contract guarantees\r\n    auto child_frame = CreateChildFrameInternal(\r\n        new_routing_id, std::move(frame_remote), scope, frame_name,\r\n        frame_unique_name, is_created_by_script, frame_token,\r\n        devtools_frame_token, frame_policy, site_instance_result.value());\r\n    \r\n    // Postcondition: Child frame inherits security properties\r\n    DCHECK(child_frame->GetSiteInstance()->IsRelatedSiteInstance(GetSiteInstance()));\r\n    \r\n    return child_frame;\r\n  }\r\n  \r\n private:\r\n  bool ValidateFrameCreationContract(int routing_id,\r\n                                   const blink::LocalFrameToken& frame_token,\r\n                                   const blink::FramePolicy& frame_policy) {\r\n    // Contract: Routing ID must be valid and unique\r\n    if (routing_id == MSG_ROUTING_NONE || \r\n        RenderFrameHostImpl::FromID(GetProcess()->GetID(), routing_id)) {\r\n      return false;\r\n    }\r\n    \r\n    // Contract: Frame token must be valid and unique\r\n    if (frame_token.is_empty() || \r\n        RenderFrameHostImpl::FromFrameToken(GetProcess()->GetID(), frame_token)) {\r\n      return false;\r\n    }\r\n    \r\n    // Contract: Frame policy must be valid for current context\r\n    return ValidateFramePolicy(frame_policy);\r\n  }\r\n};\r\n```\r\n\r\n### 2. **URLLoaderFactory Security Contracts**\r\n\r\nReal-world network security contract implementation:\r\n\r\n```cpp\r\n// Simplified from services/network/url_loader_factory.cc\r\nclass URLLoaderFactoryImpl : public mojom::URLLoaderFactory {\r\n public:\r\n  void CreateLoaderAndStart(\r\n      mojo::PendingReceiver<mojom::URLLoader> receiver,\r\n      int32_t request_id,\r\n      uint32_t options,\r\n      const ResourceRequest& url_request,\r\n      mojo::PendingRemote<mojom::URLLoaderClient> client,\r\n      const net::MutableNetworkTrafficAnnotationTag& traffic_annotation) override {\r\n    \r\n    // Security contract: Validate request against factory parameters\r\n    auto validation_result = ValidateRequestContract(url_request, options);\r\n    if (!validation_result.has_value()) {\r\n      RecordSecurityViolation(\"URLLoaderFactory\", validation_result.error());\r\n      client->OnComplete(network::URLLoaderCompletionStatus(\r\n          validation_result.error()));\r\n      return;\r\n    }\r\n    \r\n    // CORS contract: Validate cross-origin requests\r\n    if (IsCrossOriginRequest(url_request)) {\r\n      auto cors_result = ValidateCORSContract(url_request);\r\n      if (!cors_result.has_value()) {\r\n        client->OnComplete(network::URLLoaderCompletionStatus(\r\n            net::ERR_BLOCKED_BY_CLIENT));\r\n        return;\r\n      }\r\n    }\r\n    \r\n    // Create loader with security guarantees\r\n    auto loader = std::make_unique<URLLoaderImpl>(\r\n        url_request, std::move(client), traffic_annotation, factory_params_);\r\n    \r\n    auto* raw_loader = loader.get();\r\n    mojo::MakeSelfOwnedReceiver(std::move(loader), std::move(receiver));\r\n    \r\n    // Postcondition: Loader is properly configured and secured\r\n    DCHECK(raw_loader->IsProperlyConfigured());\r\n  }\r\n  \r\n private:\r\n  base::expected<void, net::Error> ValidateRequestContract(\r\n      const ResourceRequest& request, uint32_t options) {\r\n    \r\n    // Contract: URL must be valid and allowed\r\n    if (!request.url.is_valid()) {\r\n      return base::unexpected(net::ERR_INVALID_URL);\r\n    }\r\n    \r\n    // Contract: Respect factory's origin restrictions\r\n    if (factory_params_->request_initiator_origin_lock.has_value()) {\r\n      auto expected_origin = factory_params_->request_initiator_origin_lock.value();\r\n      if (request.request_initiator != expected_origin) {\r\n        return base::unexpected(net::ERR_BLOCKED_BY_CLIENT);\r\n      }\r\n    }\r\n    \r\n    // Contract: Validate resource type permissions\r\n    if (!CanRequestResourceType(request.resource_type)) {\r\n      return base::unexpected(net::ERR_BLOCKED_BY_CLIENT);\r\n    }\r\n    \r\n    return base::ok();\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## Modern Contract Programming Best Practices (v134+)\r\n\r\nBased on Chromium's extensive use of contract programming, here are the essential best practices for implementing robust contracts:\r\n\r\n### 1. **Contract Design Principles**\r\n\r\n- **Explicit Error Contracts**: Use `base::expected<T, Error>` to make error conditions explicit and testable\r\n- **Fail-Fast Validation**: Validate preconditions early and fail fast with clear error messages\r\n- **Invariant Maintenance**: Design classes that maintain their invariants automatically through RAII\r\n- **Security by Default**: Implement security contracts that deny by default and require explicit permission\r\n- **Performance Awareness**: Design contracts that can be optimized away in release builds when appropriate\r\n\r\n### 2. **Implementation Guidelines**\r\n\r\n- **Use Modern C++ Features**: Leverage concepts, `base::expected`, and RAII for robust contract implementation\r\n- **Sequence Checking**: Use `SEQUENCE_CHECKER` to enforce single-threaded access contracts\r\n- **Memory Safety**: Implement contracts that prevent use-after-free and memory leaks\r\n- **Cross-Process Contracts**: Use Mojo interfaces to enforce contracts across process boundaries\r\n- **Testing Coverage**: Write comprehensive tests that validate contract adherence and violation handling\r\n\r\n### 3. **Error Handling Best Practices**\r\n\r\n- **Structured Error Types**: Define specific error types that provide actionable information\r\n- **Error Propagation**: Use `base::expected` to propagate errors up the call stack cleanly\r\n- **Graceful Degradation**: Design contracts that allow graceful degradation when possible\r\n- **Security Response**: Implement contracts that respond appropriately to security violations\r\n- **Performance Monitoring**: Monitor contract violations for performance optimization opportunities\r\n\r\n---\r\n\r\n## Why Contract Programming is Essential in Modern Chromium (v134+)\r\n\r\nModern contract programming in Chromium v134+ goes far beyond traditional assertions, providing a comprehensive framework for building reliable, secure, and performant software:\r\n\r\n### **Foundation for Security**\r\n- **Zero-Trust Architecture**: Contracts enforce security boundaries at every interface\r\n- **Site Isolation Guarantees**: Formal contracts prevent cross-origin security violations\r\n- **Permission Validation**: Explicit contracts govern capability delegation and resource access\r\n- **Privacy Protection**: Contracts ensure Privacy Sandbox APIs operate within defined boundaries\r\n\r\n### **Performance and Reliability**\r\n- **Early Error Detection**: Contract violations are caught at development time, not in production\r\n- **Optimized Code Paths**: Compiler optimizations based on contract assumptions improve performance\r\n- **Predictable Behavior**: Postconditions guarantee consistent system state across all scenarios\r\n- **Resource Management**: RAII-based contracts prevent memory leaks and resource exhaustion\r\n\r\n### **Developer Productivity**\r\n- **Self-Documenting APIs**: Contracts make interface expectations explicit and verifiable\r\n- **Refactoring Safety**: Contract violations are detected automatically during code changes\r\n- **Testing Efficiency**: Contracts serve as executable specifications, reducing testing overhead\r\n- **Cross-Team Collaboration**: Clear contracts enable safe integration across team boundaries\r\n\r\n### **Modern C++ Advantages**\r\n- **Type Safety**: `base::expected<T, Error>` provides compile-time error handling validation\r\n- **Async Safety**: Contracts ensure proper callback execution and resource cleanup in async operations\r\n- **Thread Safety**: Sequence checkers and lock annotations prevent concurrency bugs\r\n- **Service Integration**: Mojo contracts enable safe cross-process communication with capability validation\r\n\r\n---\r\n\r\n## Conclusion: Contract Programming as Chromium's Architectural Foundation\r\n\r\nContract programming has evolved from a simple pre/post pattern into a sophisticated architectural foundation that underpins modern Chromium v134+. Through the integration of cutting-edge C++20/23 features, advanced error handling with `base::expected`, and comprehensive security validation, contract programming enables Chromium to maintain its position as the world's most secure and performant browser engine.\r\n\r\n### **Key Achievements**\r\n\r\n**Security Excellence**: Contract programming provides the foundation for Chromium's advanced security model, including site isolation, Privacy Sandbox compliance, and capability-based resource access. Every security boundary is enforced through explicit contracts that are validated at compile-time and runtime.\r\n\r\n**Performance Leadership**: By establishing clear performance contracts with Core Web Vitals integration, memory usage limits, and thread safety guarantees, Chromium maintains its performance leadership while handling billions of web requests daily.\r\n\r\n**Developer Experience**: Modern contract patterns with `base::expected`, concepts, and RAII enable developers to write safer, more maintainable code while providing clear interfaces that are self-documenting and automatically testable.\r\n\r\n### **The Future of Contract Programming in Chromium**\r\n\r\nAs Chromium continues to evolve, contract programming will become even more central to its architecture:\r\n\r\n- **Enhanced Compile-Time Validation**: Future C++ standards will enable even more sophisticated compile-time contract validation\r\n- **Cross-Process Security**: Expanding Mojo contract patterns will provide stronger guarantees for service isolation\r\n- **Performance Optimization**: Advanced contract-based optimizations will further improve Core Web Vitals and user experience\r\n- **Privacy Innovation**: Contract programming will enable new privacy-preserving technologies while maintaining security guarantees\r\n\r\n### **Best Practices for Implementation**\r\n\r\n1. **Design Contracts First**: Define preconditions, postconditions, and error contracts before implementation\r\n2. **Use Modern C++ Features**: Leverage `base::expected`, concepts, and RAII for robust contract enforcement\r\n3. **Test Contract Violations**: Comprehensive testing of contract violations ensures robust error handling\r\n4. **Monitor in Production**: Real-time contract monitoring enables proactive performance and security optimization\r\n5. **Document Contract Guarantees**: Clear documentation of contract expectations enables safe code evolution\r\n\r\n**Contract programming in modern Chromium demonstrates how formal software engineering principles can be applied at massive scale to create software that is simultaneously secure, performant, and maintainable. By defining clear expectations, validating assumptions, and handling errors gracefully, contract programming enables Chromium to continue pushing the boundaries of what's possible in browser technology while maintaining the reliability and security that billions of users depend on daily.**\r\n\r\n---\r\n\r\n**Related Documentation:**\r\n- [Modern C++ Patterns in Chromium](../cpp-patterns.md)\r\n- [Mojo IPC Architecture](../../ipc-internals.md)\r\n- [Security Model and Site Isolation](../../../security/security-model.md)\r\n- [Performance Optimization Patterns](../../performance-patterns.md)"
  },
  {
    "path": "architecture/design-patterns/overview",
    "title": "Design Patterns in Chromium Architecture",
    "content": "# Design Patterns in Chromium Architecture\r\n\r\nWelcome to the Design Patterns section! This area documents the key design patterns and architectural patterns used throughout the Wanderlust custom Chromium browser implementation.\r\n\r\n## What You'll Find Here\r\n\r\nThis section covers the fundamental design patterns that shape our Chromium architecture:\r\n\r\n- **[Delegate Pattern](delegate-pattern.md)**: Delegation and callback mechanisms for flexible component interactions\r\n- **[Factory Pattern](factory-pattern.md)**: Object creation patterns for managing complex component instantiation\r\n- **[Observer Pattern](observer-pattern.md)**: Event notification and subscription systems\r\n- **[Pre/Post Contract Pattern](pre-post-contract.md)**: Contracts for method preconditions and postconditions\r\n- **[State Pattern](state-pattern.md)**: State management and state machine implementations\r\n\r\n## Why Design Patterns Matter\r\n\r\nIn a complex codebase like Chromium, design patterns provide:\r\n\r\n### Code Organization\r\n- **Consistent Structure**: Predictable code organization across modules\r\n- **Separation of Concerns**: Clear boundaries between different responsibilities\r\n- **Modularity**: Loosely coupled components that can evolve independently\r\n\r\n### Maintainability\r\n- **Common Vocabulary**: Shared understanding of architectural concepts\r\n- **Proven Solutions**: Time-tested approaches to common problems\r\n- **Refactoring Safety**: Patterns that support safe code evolution\r\n\r\n### Team Collaboration\r\n- **Design Communication**: Clear ways to express architectural intentions\r\n- **Code Reviews**: Common patterns make code easier to review and understand\r\n- **Knowledge Transfer**: Patterns help new team members understand the codebase\r\n\r\n## Pattern Categories\r\n\r\n### Behavioral Patterns\r\n- **Observer Pattern**: Managing event notifications and subscriptions\r\n- **State Pattern**: Handling complex state transitions and behaviors\r\n- **Delegate Pattern**: Flexible callback and delegation mechanisms\r\n\r\n### Creational Patterns\r\n- **Factory Pattern**: Controlled object creation and initialization\r\n- **Pre/Post Contracts**: Ensuring proper object construction and usage\r\n\r\n### Architectural Patterns\r\n- **Component Separation**: How different browser components interact\r\n- **Process Boundaries**: Patterns for inter-process communication\r\n- **Security Boundaries**: Patterns that maintain security isolation\r\n\r\n## Implementation Context\r\n\r\nThese patterns are implemented within the broader Chromium architecture:\r\n\r\n### Process Model Integration\r\n- Patterns work across process boundaries in multi-process architecture\r\n- Security considerations for pattern implementations\r\n- Performance implications of pattern choices\r\n\r\n### Module Integration\r\n- How patterns facilitate communication between browser modules\r\n- Pattern usage in networking, rendering, and JavaScript execution\r\n- Cross-module pattern consistency\r\n\r\n## Pattern Usage Guidelines\r\n\r\nWhen implementing or modifying code that uses these patterns:\r\n\r\n1. **Understand the Intent**: Know why the pattern was chosen for specific use cases\r\n2. **Follow Conventions**: Maintain consistency with existing pattern implementations\r\n3. **Consider Performance**: Understand the performance implications of pattern choices\r\n4. **Respect Boundaries**: Ensure patterns don't violate security or process boundaries\r\n\r\n## Learning Path\r\n\r\nFor developers new to these patterns:\r\n\r\n1. **Start with Observer**: Most commonly encountered in browser event systems\r\n2. **Study Delegate**: Critical for understanding callback mechanisms\r\n3. **Explore Factory**: Important for component creation and initialization\r\n4. **Advanced Patterns**: Pre/Post contracts and State patterns for complex scenarios\r\n\r\n## Integration with Architecture\r\n\r\nThese design patterns integrate with:\r\n- [Architecture Overview](../overview.md): How patterns fit into overall system design\r\n- [Process Model](../process-model.md): Patterns in multi-process architecture\r\n- [IPC Internals](../ipc-internals.md): Communication patterns between processes\r\n- [Security Architecture](../security/overview.md): Security-aware pattern implementations\r\n\r\n## Practical Applications\r\n\r\nEach pattern documentation includes:\r\n- **Real-world Examples**: Actual usage in the Chromium codebase\r\n- **Implementation Details**: Code examples and best practices\r\n- **Common Pitfalls**: What to avoid when using each pattern\r\n- **Performance Considerations**: Impact on browser performance\r\n\r\n---\r\n\r\n*Begin with the [Observer Pattern](observer-pattern.md) to understand the most fundamental pattern in browser event handling, or explore the [Delegate Pattern](delegate-pattern.md) for callback mechanisms.*\r\n"
  },
  {
    "path": "architecture/design-patterns/observer-pattern",
    "title": "Observer Pattern in Modern Chromium (v134+)",
    "content": "# Observer Pattern in Modern Chromium (v134+)\r\n\r\nThe Observer pattern is fundamental to Chromium's event-driven architecture, enabling loose coupling between components that need to react to state changes. In modern Chromium v134+, the observer pattern has evolved to support thread-safe notifications, weak pointer management, and integration with Mojo services for cross-process observation.\r\n\r\n---\r\n\r\n## 1. Modern Observer Pattern Evolution (v134+)\r\n\r\n### Core Principles\r\n- **Decoupled Communication**: Subjects notify observers without tight coupling\r\n- **Event-Driven Architecture**: Real-time notifications for state changes\r\n- **Memory Safety**: Automatic cleanup using weak pointers and RAII\r\n- **Thread Safety**: Safe cross-thread notification mechanisms\r\n- **Service Integration**: Seamless integration with Mojo IPC for cross-process events\r\n\r\n### Contemporary Applications\r\n- **Cross-Process Events**: Mojo-based observer patterns for multi-process coordination\r\n- **UI State Management**: Modern reactive UI updates with efficient batching\r\n- **Service Lifecycle**: Service state change notifications with capability management\r\n- **Performance Monitoring**: Real-time metrics collection and reporting\r\n- **Security Events**: Privacy and security state change notifications\r\n\r\n---\r\n\r\n## 2. Modern Observer Implementations (v134+)\r\n\r\n### 2.1. Thread-Safe Observer Pattern\r\n\r\nModern thread-safe observer implementation with weak pointer management:\r\n\r\n```cpp\r\n// Modern observer interface with weak pointer support\r\ntemplate<typename ObserverType>\r\nclass ThreadSafeObserverList {\r\n public:\r\n  ThreadSafeObserverList() = default;\r\n  ~ThreadSafeObserverList() = default;\r\n\r\n  // Non-copyable, movable\r\n  ThreadSafeObserverList(const ThreadSafeObserverList&) = delete;\r\n  ThreadSafeObserverList& operator=(const ThreadSafeObserverList&) = delete;\r\n  ThreadSafeObserverList(ThreadSafeObserverList&&) = default;\r\n  ThreadSafeObserverList& operator=(ThreadSafeObserverList&&) = default;\r\n\r\n  void AddObserver(ObserverType* observer) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    CHECK(observer);\r\n    observers_.push_back(observer->AsWeakPtr());\r\n  }\r\n\r\n  void RemoveObserver(ObserverType* observer) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    CHECK(observer);\r\n    \r\n    auto it = std::find_if(observers_.begin(), observers_.end(),\r\n                          [observer](const auto& weak_observer) {\r\n                            return weak_observer.get() == observer;\r\n                          });\r\n    if (it != observers_.end()) {\r\n      observers_.erase(it);\r\n    }\r\n  }\r\n\r\n  // Notify all observers with automatic cleanup of expired weak pointers\r\n  template<typename Method, typename... Args>\r\n  void NotifyObservers(Method method, Args&&... args) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    // Remove expired weak pointers while notifying\r\n    auto it = observers_.begin();\r\n    while (it != observers_.end()) {\r\n      if (auto observer = it->get()) {\r\n        (observer->*method)(std::forward<Args>(args)...);\r\n        ++it;\r\n      } else {\r\n        it = observers_.erase(it);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Async notification for cross-thread scenarios\r\n  template<typename Method, typename... Args>\r\n  void NotifyObserversAsync(const base::Location& location,\r\n                           base::SequencedTaskRunner* task_runner,\r\n                           Method method,\r\n                           Args&&... args) {\r\n    // Capture weak pointers for async execution\r\n    std::vector<base::WeakPtr<ObserverType>> observer_copies;\r\n    {\r\n      DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n      observer_copies = observers_;\r\n    }\r\n    \r\n    task_runner->PostTask(\r\n        location,\r\n        base::BindOnce(&ThreadSafeObserverList::NotifyObserversOnSequence<Method, Args...>,\r\n                      std::move(observer_copies), method, std::forward<Args>(args)...));\r\n  }\r\n\r\n  bool HasObservers() const {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    // Clean up expired pointers when checking\r\n    auto& mutable_observers = const_cast<std::vector<base::WeakPtr<ObserverType>>&>(observers_);\r\n    mutable_observers.erase(\r\n        std::remove_if(mutable_observers.begin(), mutable_observers.end(),\r\n                      [](const auto& weak_ptr) { return !weak_ptr; }),\r\n        mutable_observers.end());\r\n    return !observers_.empty();\r\n  }\r\n\r\n private:\r\n  template<typename Method, typename... Args>\r\n  static void NotifyObserversOnSequence(\r\n      std::vector<base::WeakPtr<ObserverType>> observers,\r\n      Method method,\r\n      Args... args) {\r\n    for (auto& weak_observer : observers) {\r\n      if (auto observer = weak_observer.get()) {\r\n        (observer->*method)(args...);\r\n      }\r\n    }\r\n  }\r\n\r\n  std::vector<base::WeakPtr<ObserverType>> observers_;\r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n};\r\n```\r\n\r\n### 2.2. Mojo Observer Pattern\r\n\r\nCross-process observer pattern using Mojo for service communication:\r\n\r\n```cpp\r\n// Mojo-based observer for cross-process notifications\r\nnamespace download {\r\n\r\n// Observer interface for download events\r\nclass DownloadObserver : public base::SupportsWeakPtr<DownloadObserver> {\r\n public:\r\n  virtual ~DownloadObserver() = default;\r\n  \r\n  virtual void OnDownloadCreated(const std::string& download_id,\r\n                                const DownloadMetadata& metadata) {}\r\n  virtual void OnDownloadUpdated(const std::string& download_id,\r\n                                const DownloadProgress& progress) {}\r\n  virtual void OnDownloadCompleted(const std::string& download_id,\r\n                                  const base::FilePath& file_path) {}\r\n  virtual void OnDownloadFailed(const std::string& download_id,\r\n                               DownloadError error) {}\r\n};\r\n\r\n// Modern download service with observer support\r\nclass DownloadServiceImpl : public mojom::DownloadService {\r\n public:\r\n  explicit DownloadServiceImpl(Profile* profile)\r\n      : profile_(profile) {}\r\n  \r\n  ~DownloadServiceImpl() override = default;\r\n\r\n  // Mojo service methods\r\n  void StartDownload(const GURL& url,\r\n                    const std::string& referrer,\r\n                    StartDownloadCallback callback) override {\r\n    auto download_id = base::Uuid::GenerateRandomV4().AsLowercaseString();\r\n    \r\n    // Create download item\r\n    auto download_item = std::make_unique<DownloadItem>(\r\n        download_id, url, profile_->GetPath());\r\n    \r\n    // Notify local observers\r\n    DownloadMetadata metadata;\r\n    metadata.url = url;\r\n    metadata.file_name = ExtractFileNameFromUrl(url);\r\n    metadata.total_bytes = -1;  // Unknown initially\r\n    \r\n    observers_.NotifyObservers(&DownloadObserver::OnDownloadCreated,\r\n                              download_id, metadata);\r\n    \r\n    // Notify remote observers via Mojo\r\n    for (auto& remote_observer : remote_observers_) {\r\n      if (remote_observer.is_connected()) {\r\n        remote_observer->OnDownloadCreated(download_id, metadata.Clone());\r\n      }\r\n    }\r\n    \r\n    // Start the download asynchronously\r\n    StartDownloadInternal(std::move(download_item), std::move(callback));\r\n  }\r\n\r\n  void AddObserver(mojo::PendingRemote<mojom::DownloadObserver> observer) override {\r\n    mojo::Remote<mojom::DownloadObserver> remote_observer(std::move(observer));\r\n    \r\n    // Set up disconnect handler for cleanup\r\n    remote_observer.set_disconnect_handler(\r\n        base::BindOnce(&DownloadServiceImpl::OnRemoteObserverDisconnected,\r\n                      weak_factory_.GetWeakPtr(),\r\n                      remote_observer.get()));\r\n    \r\n    remote_observers_.push_back(std::move(remote_observer));\r\n  }\r\n\r\n  // Local observer management\r\n  void AddLocalObserver(DownloadObserver* observer) {\r\n    observers_.AddObserver(observer);\r\n  }\r\n\r\n  void RemoveLocalObserver(DownloadObserver* observer) {\r\n    observers_.RemoveObserver(observer);\r\n  }\r\n\r\n private:\r\n  void StartDownloadInternal(std::unique_ptr<DownloadItem> item,\r\n                           StartDownloadCallback callback) {\r\n    const std::string download_id = item->GetId();\r\n    \r\n    // Set up progress tracking\r\n    item->SetProgressCallback(\r\n        base::BindRepeating(&DownloadServiceImpl::OnDownloadProgress,\r\n                           weak_factory_.GetWeakPtr(), download_id));\r\n    \r\n    item->SetCompletionCallback(\r\n        base::BindOnce(&DownloadServiceImpl::OnDownloadCompleted,\r\n                      weak_factory_.GetWeakPtr(), download_id));\r\n    \r\n    // Store and start download\r\n    active_downloads_[download_id] = std::move(item);\r\n    active_downloads_[download_id]->Start();\r\n    \r\n    std::move(callback).Run(DownloadResult::kSuccess);\r\n  }\r\n\r\n  void OnDownloadProgress(const std::string& download_id,\r\n                         int64_t bytes_downloaded,\r\n                         int64_t total_bytes) {\r\n    DownloadProgress progress;\r\n    progress.bytes_downloaded = bytes_downloaded;\r\n    progress.total_bytes = total_bytes;\r\n    progress.percentage = total_bytes > 0 ? \r\n        static_cast<float>(bytes_downloaded) / total_bytes * 100.0f : 0.0f;\r\n    \r\n    // Notify local observers\r\n    observers_.NotifyObservers(&DownloadObserver::OnDownloadUpdated,\r\n                              download_id, progress);\r\n    \r\n    // Notify remote observers\r\n    for (auto& remote_observer : remote_observers_) {\r\n      if (remote_observer.is_connected()) {\r\n        remote_observer->OnDownloadUpdated(download_id, progress.Clone());\r\n      }\r\n    }\r\n  }\r\n\r\n  void OnDownloadCompleted(const std::string& download_id,\r\n                          const base::FilePath& file_path) {\r\n    // Notify local observers\r\n    observers_.NotifyObservers(&DownloadObserver::OnDownloadCompleted,\r\n                              download_id, file_path);\r\n    \r\n    // Notify remote observers\r\n    for (auto& remote_observer : remote_observers_) {\r\n      if (remote_observer.is_connected()) {\r\n        remote_observer->OnDownloadCompleted(download_id, file_path);\r\n      }\r\n    }\r\n    \r\n    // Clean up completed download\r\n    active_downloads_.erase(download_id);\r\n  }\r\n\r\n  void OnRemoteObserverDisconnected(mojom::DownloadObserver* observer) {\r\n    auto it = std::find_if(remote_observers_.begin(), remote_observers_.end(),\r\n                          [observer](const auto& remote) {\r\n                            return remote.get() == observer;\r\n                          });\r\n    if (it != remote_observers_.end()) {\r\n      remote_observers_.erase(it);\r\n    }\r\n  }\r\n\r\n  Profile* profile_;\r\n  ThreadSafeObserverList<DownloadObserver> observers_;\r\n  std::vector<mojo::Remote<mojom::DownloadObserver>> remote_observers_;\r\n  std::unordered_map<std::string, std::unique_ptr<DownloadItem>> active_downloads_;\r\n  \r\n  base::WeakPtrFactory<DownloadServiceImpl> weak_factory_{this};\r\n};\r\n\r\n} // namespace download\r\n```\r\n\r\n### 2.3. Reactive Observer Pattern\r\n\r\nModern reactive observer pattern with efficient batching and filtering:\r\n\r\n```cpp\r\n// Reactive observer pattern with batching and filtering\r\ntemplate<typename EventType>\r\nclass ReactiveObserver : public base::SupportsWeakPtr<ReactiveObserver<EventType>> {\r\n public:\r\n  virtual ~ReactiveObserver() = default;\r\n  \r\n  // Override this method to handle events\r\n  virtual void OnEvent(const EventType& event) = 0;\r\n  \r\n  // Optional: Override for batch processing\r\n  virtual void OnEventBatch(const std::vector<EventType>& events) {\r\n    for (const auto& event : events) {\r\n      OnEvent(event);\r\n    }\r\n  }\r\n  \r\n  // Optional: Override to filter events\r\n  virtual bool ShouldReceiveEvent(const EventType& event) const {\r\n    return true;\r\n  }\r\n};\r\n\r\ntemplate<typename EventType>\r\nclass ReactiveSubject {\r\n public:\r\n  ReactiveSubject() : weak_factory_(this) {}\r\n  \r\n  void AddObserver(ReactiveObserver<EventType>* observer) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    observers_.AddObserver(observer);\r\n  }\r\n  \r\n  void RemoveObserver(ReactiveObserver<EventType>* observer) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    observers_.RemoveObserver(observer);\r\n  }\r\n  \r\n  // Emit single event with optional batching\r\n  void EmitEvent(EventType event) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    if (batch_events_) {\r\n      pending_events_.push_back(std::move(event));\r\n      ScheduleBatchFlush();\r\n    } else {\r\n      NotifyObserversOfEvent(event);\r\n    }\r\n  }\r\n  \r\n  // Emit multiple events efficiently\r\n  void EmitEvents(std::vector<EventType> events) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    if (batch_events_) {\r\n      pending_events_.insert(pending_events_.end(),\r\n                            std::make_move_iterator(events.begin()),\r\n                            std::make_move_iterator(events.end()));\r\n      ScheduleBatchFlush();\r\n    } else {\r\n      for (const auto& event : events) {\r\n        NotifyObserversOfEvent(event);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Configure batching behavior\r\n  void SetBatchingEnabled(bool enabled) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    batch_events_ = enabled;\r\n    \r\n    if (!enabled && !pending_events_.empty()) {\r\n      FlushPendingEvents();\r\n    }\r\n  }\r\n  \r\n  void SetBatchDelay(base::TimeDelta delay) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    batch_delay_ = delay;\r\n  }\r\n  \r\n private:\r\n  void NotifyObserversOfEvent(const EventType& event) {\r\n    std::vector<base::WeakPtr<ReactiveObserver<EventType>>> filtered_observers;\r\n    \r\n    // Apply filtering\r\n    auto it = observers_.begin();\r\n    while (it != observers_.end()) {\r\n      if (auto observer = it->get()) {\r\n        if (observer->ShouldReceiveEvent(event)) {\r\n          filtered_observers.push_back(*it);\r\n        }\r\n        ++it;\r\n      } else {\r\n        it = observers_.erase(it);\r\n      }\r\n    }\r\n    \r\n    // Notify filtered observers\r\n    for (auto& weak_observer : filtered_observers) {\r\n      if (auto observer = weak_observer.get()) {\r\n        observer->OnEvent(event);\r\n      }\r\n    }\r\n  }\r\n  \r\n  void ScheduleBatchFlush() {\r\n    if (batch_flush_pending_) {\r\n      return;\r\n    }\r\n    \r\n    batch_flush_pending_ = true;\r\n    base::SequencedTaskRunner::GetCurrentDefault()->PostDelayedTask(\r\n        FROM_HERE,\r\n        base::BindOnce(&ReactiveSubject::FlushPendingEvents,\r\n                      weak_factory_.GetWeakPtr()),\r\n        batch_delay_);\r\n  }\r\n  \r\n  void FlushPendingEvents() {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    batch_flush_pending_ = false;\r\n    \r\n    if (pending_events_.empty()) {\r\n      return;\r\n    }\r\n    \r\n    std::vector<EventType> events_to_flush;\r\n    events_to_flush.swap(pending_events_);\r\n    \r\n    // Group events by observer for efficient batch processing\r\n    std::unordered_map<ReactiveObserver<EventType>*, std::vector<EventType>> \r\n        observer_events;\r\n    \r\n    for (const auto& event : events_to_flush) {\r\n      auto it = observers_.begin();\r\n      while (it != observers_.end()) {\r\n        if (auto observer = it->get()) {\r\n          if (observer->ShouldReceiveEvent(event)) {\r\n            observer_events[observer].push_back(event);\r\n          }\r\n          ++it;\r\n        } else {\r\n          it = observers_.erase(it);\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Notify observers with batched events\r\n    for (auto& [observer, events] : observer_events) {\r\n      if (events.size() == 1) {\r\n        observer->OnEvent(events[0]);\r\n      } else if (!events.empty()) {\r\n        observer->OnEventBatch(events);\r\n      }\r\n    }\r\n  }\r\n  \r\n  std::vector<base::WeakPtr<ReactiveObserver<EventType>>> observers_;\r\n  std::vector<EventType> pending_events_;\r\n  bool batch_events_ = false;\r\n  bool batch_flush_pending_ = false;\r\n  base::TimeDelta batch_delay_ = base::Milliseconds(16);  // ~60 FPS\r\n  \r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n  base::WeakPtrFactory<ReactiveSubject<EventType>> weak_factory_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 3. Key Observer Implementations in v134+\r\n\r\n### 3.1. TabStripModelObserver\r\n\r\nModern tab management with enhanced lifecycle tracking:\r\n\r\n```cpp\r\n// Modern tab strip observer with comprehensive event handling\r\nclass TabStripModelObserver : public base::SupportsWeakPtr<TabStripModelObserver> {\r\n public:\r\n  virtual ~TabStripModelObserver() = default;\r\n\r\n  // Tab lifecycle events\r\n  virtual void OnTabStripModelChanged(\r\n      TabStripModel* tab_strip_model,\r\n      const TabStripModelChange& change,\r\n      const TabStripSelectionChange& selection) {}\r\n\r\n  // Enhanced tab events for v134+\r\n  virtual void OnTabWillBeAdded(TabStripModel* model, \r\n                               content::WebContents* contents,\r\n                               int index) {}\r\n  \r\n  virtual void OnTabAdded(TabStripModel* model,\r\n                         content::WebContents* contents,\r\n                         int index,\r\n                         bool foreground) {}\r\n  \r\n  virtual void OnTabWillBeRemoved(TabStripModel* model,\r\n                                 content::WebContents* contents,\r\n                                 int index,\r\n                                 TabStripModelChange::RemoveReason reason) {}\r\n  \r\n  virtual void OnTabRemoved(TabStripModel* model,\r\n                           content::WebContents* contents,\r\n                           int index,\r\n                           TabStripModelChange::RemoveReason reason) {}\r\n\r\n  // Modern navigation and security events\r\n  virtual void OnTabSecurityStateChanged(TabStripModel* model,\r\n                                        content::WebContents* contents,\r\n                                        int index,\r\n                                        SecurityLevel security_level) {}\r\n  \r\n  virtual void OnTabPrivacySandboxStateChanged(TabStripModel* model,\r\n                                              content::WebContents* contents,\r\n                                              int index,\r\n                                              bool privacy_sandbox_enabled) {}\r\n\r\n  // Performance and resource events\r\n  virtual void OnTabResourceUsageChanged(TabStripModel* model,\r\n                                        content::WebContents* contents,\r\n                                        int index,\r\n                                        const ResourceUsageInfo& usage) {}\r\n  \r\n  virtual void OnTabFrozenStateChanged(TabStripModel* model,\r\n                                      content::WebContents* contents,\r\n                                      int index,\r\n                                      bool is_frozen) {}\r\n};\r\n\r\n// Modern TabStripModel implementation\r\nclass TabStripModel {\r\n public:\r\n  void AddObserver(TabStripModelObserver* observer) {\r\n    observers_.AddObserver(observer);\r\n  }\r\n  \r\n  void RemoveObserver(TabStripModelObserver* observer) {\r\n    observers_.RemoveObserver(observer);\r\n  }\r\n  \r\n  // Modern tab addition with comprehensive notification\r\n  void AddWebContents(std::unique_ptr<content::WebContents> contents,\r\n                     int index,\r\n                     ui::PageTransition transition,\r\n                     int add_types) {\r\n    DCHECK(contents);\r\n    \r\n    // Notify observers before addition\r\n    observers_.NotifyObservers(&TabStripModelObserver::OnTabWillBeAdded,\r\n                              this, contents.get(), index);\r\n    \r\n    // Add tab to model\r\n    auto* raw_contents = contents.get();\r\n    web_contents_.insert(web_contents_.begin() + index, std::move(contents));\r\n    \r\n    // Set up content observers for enhanced events\r\n    SetupContentObservers(raw_contents, index);\r\n    \r\n    // Notify observers after addition\r\n    bool foreground = (add_types & ADD_ACTIVE) != 0;\r\n    observers_.NotifyObservers(&TabStripModelObserver::OnTabAdded,\r\n                              this, raw_contents, index, foreground);\r\n    \r\n    // Update selection if necessary\r\n    if (foreground) {\r\n      SetActiveIndex(index);\r\n    }\r\n  }\r\n  \r\n  // Enhanced removal with detailed reason tracking\r\n  std::unique_ptr<content::WebContents> DetachWebContentsAt(\r\n      int index,\r\n      TabStripModelChange::RemoveReason reason) {\r\n    DCHECK(IsValidIndex(index));\r\n    \r\n    auto* contents = web_contents_[index].get();\r\n    \r\n    // Notify observers before removal\r\n    observers_.NotifyObservers(&TabStripModelObserver::OnTabWillBeRemoved,\r\n                              this, contents, index, reason);\r\n    \r\n    // Clean up content observers\r\n    CleanupContentObservers(contents);\r\n    \r\n    // Remove from model\r\n    auto detached_contents = std::move(web_contents_[index]);\r\n    web_contents_.erase(web_contents_.begin() + index);\r\n    \r\n    // Notify observers after removal\r\n    observers_.NotifyObservers(&TabStripModelObserver::OnTabRemoved,\r\n                              this, detached_contents.get(), index, reason);\r\n    \r\n    // Update active index if necessary\r\n    if (active_index_ >= index && active_index_ > 0) {\r\n      SetActiveIndex(active_index_ - 1);\r\n    }\r\n    \r\n    return detached_contents;\r\n  }\r\n  \r\n private:\r\n  void SetupContentObservers(content::WebContents* contents, int index) {\r\n    // Set up security state observer\r\n    auto security_observer = std::make_unique<SecurityStateObserver>(\r\n        base::BindRepeating(&TabStripModel::OnSecurityStateChanged,\r\n                           weak_factory_.GetWeakPtr(), contents, index));\r\n    content_observers_[contents] = std::move(security_observer);\r\n  }\r\n  \r\n  void OnSecurityStateChanged(content::WebContents* contents,\r\n                             int index,\r\n                             SecurityLevel level) {\r\n    observers_.NotifyObservers(&TabStripModelObserver::OnTabSecurityStateChanged,\r\n                              this, contents, index, level);\r\n  }\r\n  \r\n  ThreadSafeObserverList<TabStripModelObserver> observers_;\r\n  std::vector<std::unique_ptr<content::WebContents>> web_contents_;\r\n  std::unordered_map<content::WebContents*, \r\n                     std::unique_ptr<SecurityStateObserver>> content_observers_;\r\n  int active_index_ = -1;\r\n  \r\n  base::WeakPtrFactory<TabStripModel> weak_factory_{this};\r\n};\r\n```\r\n\r\n### 3.2. PermissionObserver\r\n\r\nModern permission system observer with Privacy Sandbox integration:\r\n\r\n```cpp\r\n// Observer for permission and privacy state changes\r\nclass PermissionObserver : public base::SupportsWeakPtr<PermissionObserver> {\r\n public:\r\n  virtual ~PermissionObserver() = default;\r\n  \r\n  // Traditional permission events\r\n  virtual void OnPermissionChanged(const url::Origin& origin,\r\n                                  ContentSettingsType type,\r\n                                  ContentSetting setting) {}\r\n  \r\n  // Privacy Sandbox events (v134+)\r\n  virtual void OnTopicsPermissionChanged(const url::Origin& origin,\r\n                                        bool allowed) {}\r\n  \r\n  virtual void OnFledgePermissionChanged(const url::Origin& origin,\r\n                                        bool allowed) {}\r\n  \r\n  virtual void OnAttributionReportingPermissionChanged(const url::Origin& origin,\r\n                                                      bool allowed) {}\r\n  \r\n  // Trust Token events\r\n  virtual void OnTrustTokenPermissionChanged(const url::Origin& origin,\r\n                                           bool allowed) {}\r\n  \r\n  // Device permission events\r\n  virtual void OnDevicePermissionChanged(const url::Origin& origin,\r\n                                        blink::mojom::PermissionName permission,\r\n                                        blink::mojom::PermissionStatus status) {}\r\n};\r\n\r\n// Modern permission manager with comprehensive notification\r\nclass PermissionManagerImpl {\r\n public:\r\n  void AddObserver(PermissionObserver* observer) {\r\n    observers_.AddObserver(observer);\r\n  }\r\n  \r\n  void RemoveObserver(PermissionObserver* observer) {\r\n    observers_.RemoveObserver(observer);\r\n  }\r\n  \r\n  // Set permission with automatic notification\r\n  void SetPermission(const url::Origin& origin,\r\n                    ContentSettingsType type,\r\n                    ContentSetting setting) {\r\n    // Update internal state\r\n    permission_store_[{origin, type}] = setting;\r\n    \r\n    // Notify observers\r\n    observers_.NotifyObservers(&PermissionObserver::OnPermissionChanged,\r\n                              origin, type, setting);\r\n    \r\n    // Handle Privacy Sandbox specific permissions\r\n    if (type == ContentSettingsType::PRIVACY_SANDBOX_TOPICS_API) {\r\n      bool allowed = (setting == CONTENT_SETTING_ALLOW);\r\n      observers_.NotifyObservers(&PermissionObserver::OnTopicsPermissionChanged,\r\n                                origin, allowed);\r\n    }\r\n    \r\n    // Update related permissions and notify\r\n    UpdateRelatedPermissions(origin, type, setting);\r\n  }\r\n  \r\n  // Async permission request with observer notification\r\n  void RequestPermissionAsync(\r\n      const url::Origin& origin,\r\n      ContentSettingsType type,\r\n      base::OnceCallback<void(ContentSetting)> callback) {\r\n    \r\n    // Check if permission is already granted\r\n    auto current_setting = GetPermission(origin, type);\r\n    if (current_setting != CONTENT_SETTING_ASK) {\r\n      std::move(callback).Run(current_setting);\r\n      return;\r\n    }\r\n    \r\n    // Show permission prompt asynchronously\r\n    permission_prompt_->ShowPrompt(\r\n        origin, type,\r\n        base::BindOnce(&PermissionManagerImpl::OnPermissionPromptComplete,\r\n                      weak_factory_.GetWeakPtr(), origin, type, \r\n                      std::move(callback)));\r\n  }\r\n  \r\n private:\r\n  void OnPermissionPromptComplete(const url::Origin& origin,\r\n                                 ContentSettingsType type,\r\n                                 base::OnceCallback<void(ContentSetting)> callback,\r\n                                 ContentSetting result) {\r\n    // Update permission state\r\n    SetPermission(origin, type, result);\r\n    \r\n    // Complete the request\r\n    std::move(callback).Run(result);\r\n  }\r\n  \r\n  void UpdateRelatedPermissions(const url::Origin& origin,\r\n                               ContentSettingsType type,\r\n                               ContentSetting setting) {\r\n    // Handle cascading permission changes\r\n    if (type == ContentSettingsType::NOTIFICATIONS && \r\n        setting == CONTENT_SETTING_BLOCK) {\r\n      // Also block push messaging\r\n      SetPermission(origin, ContentSettingsType::PUSH_MESSAGING, \r\n                   CONTENT_SETTING_BLOCK);\r\n    }\r\n    \r\n    // Privacy Sandbox cascading\r\n    if (type == ContentSettingsType::COOKIES && \r\n        setting == CONTENT_SETTING_BLOCK) {\r\n      // Disable Privacy Sandbox APIs when cookies are blocked\r\n      SetPermission(origin, ContentSettingsType::PRIVACY_SANDBOX_TOPICS_API,\r\n                   CONTENT_SETTING_BLOCK);\r\n      SetPermission(origin, ContentSettingsType::PRIVACY_SANDBOX_FLEDGE_API,\r\n                   CONTENT_SETTING_BLOCK);\r\n    }\r\n  }\r\n  \r\n  ContentSetting GetPermission(const url::Origin& origin,\r\n                              ContentSettingsType type) {\r\n    auto key = std::make_pair(origin, type);\r\n    auto it = permission_store_.find(key);\r\n    return it != permission_store_.end() ? it->second : CONTENT_SETTING_ASK;\r\n  }\r\n  \r\n  ThreadSafeObserverList<PermissionObserver> observers_;\r\n  std::map<std::pair<url::Origin, ContentSettingsType>, ContentSetting> permission_store_;\r\n  std::unique_ptr<PermissionPrompt> permission_prompt_;\r\n  \r\n  base::WeakPtrFactory<PermissionManagerImpl> weak_factory_{this};\r\n};\r\n```\r\n\r\n### 3.3. Performance Observer\r\n\r\nModern performance monitoring with Core Web Vitals integration:\r\n\r\n```cpp\r\n// Performance event types for v134+\r\nstruct PerformanceEvent {\r\n  enum class Type {\r\n    kPageLoad,\r\n    kResourceLoad,\r\n    kCoreWebVitals,\r\n    kMemoryUsage,\r\n    kCPUUsage,\r\n    kNetworkLatency,\r\n    kRenderingMetrics\r\n  };\r\n  \r\n  Type type;\r\n  base::TimeTicks timestamp;\r\n  url::Origin origin;\r\n  std::unordered_map<std::string, double> metrics;\r\n  std::unordered_map<std::string, std::string> metadata;\r\n};\r\n\r\n// Performance observer with filtering and aggregation\r\nclass PerformanceObserver : public ReactiveObserver<PerformanceEvent> {\r\n public:\r\n  virtual ~PerformanceObserver() = default;\r\n  \r\n  // Implement filtering for specific performance events\r\n  bool ShouldReceiveEvent(const PerformanceEvent& event) const override {\r\n    // Filter by event type\r\n    if (!interested_types_.empty() && \r\n        interested_types_.find(event.type) == interested_types_.end()) {\r\n      return false;\r\n    }\r\n    \r\n    // Filter by origin\r\n    if (!interested_origins_.empty() &&\r\n        interested_origins_.find(event.origin) == interested_origins_.end()) {\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }\r\n  \r\n  // Override for batch processing of performance events\r\n  void OnEventBatch(const std::vector<PerformanceEvent>& events) override {\r\n    ProcessPerformanceBatch(events);\r\n  }\r\n  \r\n  // Configuration methods\r\n  void SetInterestedTypes(std::set<PerformanceEvent::Type> types) {\r\n    interested_types_ = std::move(types);\r\n  }\r\n  \r\n  void SetInterestedOrigins(std::set<url::Origin> origins) {\r\n    interested_origins_ = std::move(origins);\r\n  }\r\n  \r\n protected:\r\n  virtual void ProcessPerformanceBatch(const std::vector<PerformanceEvent>& events) {\r\n    for (const auto& event : events) {\r\n      OnEvent(event);\r\n    }\r\n  }\r\n  \r\n private:\r\n  std::set<PerformanceEvent::Type> interested_types_;\r\n  std::set<url::Origin> interested_origins_;\r\n};\r\n\r\n// Modern performance monitor with Core Web Vitals\r\nclass PerformanceMonitor {\r\n public:\r\n  PerformanceMonitor() {\r\n    // Enable batching for efficient performance data collection\r\n    subject_.SetBatchingEnabled(true);\r\n    subject_.SetBatchDelay(base::Milliseconds(100));  // 10 Hz reporting\r\n  }\r\n  \r\n  void AddObserver(PerformanceObserver* observer) {\r\n    subject_.AddObserver(observer);\r\n  }\r\n  \r\n  void RemoveObserver(PerformanceObserver* observer) {\r\n    subject_.RemoveObserver(observer);\r\n  }\r\n  \r\n  // Report Core Web Vitals\r\n  void ReportCoreWebVitals(const url::Origin& origin,\r\n                          double lcp,    // Largest Contentful Paint\r\n                          double fid,    // First Input Delay\r\n                          double cls) {  // Cumulative Layout Shift\r\n    PerformanceEvent event;\r\n    event.type = PerformanceEvent::Type::kCoreWebVitals;\r\n    event.timestamp = base::TimeTicks::Now();\r\n    event.origin = origin;\r\n    event.metrics[\"lcp\"] = lcp;\r\n    event.metrics[\"fid\"] = fid;\r\n    event.metrics[\"cls\"] = cls;\r\n    \r\n    // Calculate Web Vitals score\r\n    double score = CalculateWebVitalsScore(lcp, fid, cls);\r\n    event.metrics[\"score\"] = score;\r\n    \r\n    subject_.EmitEvent(std::move(event));\r\n  }\r\n  \r\n  // Report resource loading performance\r\n  void ReportResourceLoad(const url::Origin& origin,\r\n                         const GURL& resource_url,\r\n                         base::TimeDelta load_time,\r\n                         size_t resource_size) {\r\n    PerformanceEvent event;\r\n    event.type = PerformanceEvent::Type::kResourceLoad;\r\n    event.timestamp = base::TimeTicks::Now();\r\n    event.origin = origin;\r\n    event.metrics[\"load_time_ms\"] = load_time.InMillisecondsF();\r\n    event.metrics[\"size_bytes\"] = static_cast<double>(resource_size);\r\n    event.metrics[\"throughput_mbps\"] = \r\n        (resource_size * 8.0) / (load_time.InSecondsF() * 1024 * 1024);\r\n    event.metadata[\"resource_url\"] = resource_url.spec();\r\n    \r\n    subject_.EmitEvent(std::move(event));\r\n  }\r\n  \r\n  // Report memory usage with detailed breakdown\r\n  void ReportMemoryUsage(const url::Origin& origin,\r\n                        const MemoryUsageInfo& usage_info) {\r\n    PerformanceEvent event;\r\n    event.type = PerformanceEvent::Type::kMemoryUsage;\r\n    event.timestamp = base::TimeTicks::Now();\r\n    event.origin = origin;\r\n    event.metrics[\"heap_used_mb\"] = usage_info.heap_used / (1024.0 * 1024.0);\r\n    event.metrics[\"heap_total_mb\"] = usage_info.heap_total / (1024.0 * 1024.0);\r\n    event.metrics[\"external_mb\"] = usage_info.external / (1024.0 * 1024.0);\r\n    event.metrics[\"dom_nodes\"] = static_cast<double>(usage_info.dom_nodes);\r\n    \r\n    subject_.EmitEvent(std::move(event));\r\n  }\r\n  \r\n private:\r\n  double CalculateWebVitalsScore(double lcp, double fid, double cls) {\r\n    // Implement Google's Core Web Vitals scoring algorithm\r\n    double lcp_score = lcp <= 2500 ? 1.0 : (lcp <= 4000 ? 0.5 : 0.0);\r\n    double fid_score = fid <= 100 ? 1.0 : (fid <= 300 ? 0.5 : 0.0);\r\n    double cls_score = cls <= 0.1 ? 1.0 : (cls <= 0.25 ? 0.5 : 0.0);\r\n    \r\n    return (lcp_score + fid_score + cls_score) / 3.0;\r\n  }\r\n  \r\n  ReactiveSubject<PerformanceEvent> subject_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 4. Advanced Observer Patterns (v134+)\r\n\r\n### 4.1. Hierarchical Observer Pattern\r\n\r\nObserver pattern with parent-child relationships and event bubbling:\r\n\r\n```cpp\r\n// Hierarchical observer for tree-structured events\r\ntemplate<typename EventType>\r\nclass HierarchicalObserver : public base::SupportsWeakPtr<HierarchicalObserver<EventType>> {\r\n public:\r\n  virtual ~HierarchicalObserver() = default;\r\n  \r\n  // Handle events at this level\r\n  virtual bool OnEvent(const EventType& event, bool from_child = false) {\r\n    return false;  // Return true to stop event propagation\r\n  }\r\n  \r\n  // Handle events bubbling up from children\r\n  virtual bool OnChildEvent(const EventType& event, \r\n                           HierarchicalObserver* child) {\r\n    return OnEvent(event, true);\r\n  }\r\n  \r\n  // Set parent for event bubbling\r\n  void SetParent(HierarchicalObserver* parent) {\r\n    parent_ = parent ? parent->AsWeakPtr() : base::WeakPtr<HierarchicalObserver>();\r\n  }\r\n  \r\n  // Add child observer\r\n  void AddChild(HierarchicalObserver* child) {\r\n    if (child) {\r\n      children_.push_back(child->AsWeakPtr());\r\n      child->SetParent(this);\r\n    }\r\n  }\r\n  \r\n  // Remove child observer\r\n  void RemoveChild(HierarchicalObserver* child) {\r\n    auto it = std::find_if(children_.begin(), children_.end(),\r\n                          [child](const auto& weak_child) {\r\n                            return weak_child.get() == child;\r\n                          });\r\n    if (it != children_.end()) {\r\n      children_.erase(it);\r\n      if (child) {\r\n        child->SetParent(nullptr);\r\n      }\r\n    }\r\n  }\r\n  \r\n protected:\r\n  // Emit event with automatic bubbling\r\n  bool EmitEvent(const EventType& event) {\r\n    // Handle locally first\r\n    if (OnEvent(event)) {\r\n      return true;  // Event handled, stop propagation\r\n    }\r\n    \r\n    // Bubble up to parent\r\n    if (auto parent = parent_.get()) {\r\n      return parent->OnChildEvent(event, this);\r\n    }\r\n    \r\n    return false;\r\n  }\r\n  \r\n  // Broadcast event down to children\r\n  void BroadcastToChildren(const EventType& event) {\r\n    auto it = children_.begin();\r\n    while (it != children_.end()) {\r\n      if (auto child = it->get()) {\r\n        if (child->OnEvent(event)) {\r\n          break;  // Stop broadcast if child handles event\r\n        }\r\n        ++it;\r\n      } else {\r\n        it = children_.erase(it);\r\n      }\r\n    }\r\n  }\r\n  \r\n private:\r\n  base::WeakPtr<HierarchicalObserver> parent_;\r\n  std::vector<base::WeakPtr<HierarchicalObserver>> children_;\r\n};\r\n```\r\n\r\n### 4.2. Filtered Observer Pattern\r\n\r\nObserver pattern with sophisticated filtering and transformation:\r\n\r\n```cpp\r\n// Event filter interface\r\ntemplate<typename EventType>\r\nclass EventFilter {\r\n public:\r\n  virtual ~EventFilter() = default;\r\n  virtual bool ShouldProcess(const EventType& event) const = 0;\r\n  virtual EventType Transform(EventType event) const { return event; }\r\n};\r\n\r\n// Compound filter for complex filtering logic\r\ntemplate<typename EventType>\r\nclass CompoundEventFilter : public EventFilter<EventType> {\r\n public:\r\n  enum class Logic { kAnd, kOr };\r\n  \r\n  CompoundEventFilter(Logic logic) : logic_(logic) {}\r\n  \r\n  void AddFilter(std::unique_ptr<EventFilter<EventType>> filter) {\r\n    filters_.push_back(std::move(filter));\r\n  }\r\n  \r\n  bool ShouldProcess(const EventType& event) const override {\r\n    if (filters_.empty()) {\r\n      return true;\r\n    }\r\n    \r\n    if (logic_ == Logic::kAnd) {\r\n      return std::all_of(filters_.begin(), filters_.end(),\r\n                        [&event](const auto& filter) {\r\n                          return filter->ShouldProcess(event);\r\n                        });\r\n    } else {\r\n      return std::any_of(filters_.begin(), filters_.end(),\r\n                        [&event](const auto& filter) {\r\n                          return filter->ShouldProcess(event);\r\n                        });\r\n    }\r\n  }\r\n  \r\n  EventType Transform(EventType event) const override {\r\n    for (const auto& filter : filters_) {\r\n      event = filter->Transform(std::move(event));\r\n    }\r\n    return event;\r\n  }\r\n  \r\n private:\r\n  Logic logic_;\r\n  std::vector<std::unique_ptr<EventFilter<EventType>>> filters_;\r\n};\r\n\r\n// Filtered observer implementation\r\ntemplate<typename EventType>\r\nclass FilteredObserver : public base::SupportsWeakPtr<FilteredObserver<EventType>> {\r\n public:\r\n  virtual ~FilteredObserver() = default;\r\n  \r\n  // Pure virtual method for handling filtered events\r\n  virtual void OnFilteredEvent(const EventType& event) = 0;\r\n  \r\n  // Set event filter\r\n  void SetFilter(std::unique_ptr<EventFilter<EventType>> filter) {\r\n    filter_ = std::move(filter);\r\n  }\r\n  \r\n  // Internal event processing with filtering\r\n  bool ProcessEvent(const EventType& event) {\r\n    if (!filter_ || filter_->ShouldProcess(event)) {\r\n      EventType processed_event = filter_ ? filter_->Transform(event) : event;\r\n      OnFilteredEvent(processed_event);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  \r\n private:\r\n  std::unique_ptr<EventFilter<EventType>> filter_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 5. Testing Observer Patterns (v134+)\r\n\r\n### 5.1. Mock Observer Implementation\r\n\r\nComprehensive mock observer for testing:\r\n\r\n```cpp\r\n// Mock observer with expectation validation\r\ntemplate<typename EventType>\r\nclass MockObserver : public ReactiveObserver<EventType> {\r\n public:\r\n  MockObserver() = default;\r\n  ~MockObserver() override = default;\r\n  \r\n  // Mock method that can be configured\r\n  MOCK_METHOD(void, OnEvent, (const EventType& event), (override));\r\n  MOCK_METHOD(void, OnEventBatch, (const std::vector<EventType>& events), (override));\r\n  MOCK_METHOD(bool, ShouldReceiveEvent, (const EventType& event), (const override));\r\n  \r\n  // Helper methods for test setup\r\n  void ExpectEvent(const EventType& expected_event) {\r\n    EXPECT_CALL(*this, OnEvent(testing::Eq(expected_event)))\r\n        .Times(1);\r\n  }\r\n  \r\n  void ExpectEventCount(int count) {\r\n    EXPECT_CALL(*this, OnEvent(testing::_))\r\n        .Times(count);\r\n  }\r\n  \r\n  void ExpectEventSequence(const std::vector<EventType>& sequence) {\r\n    testing::InSequence seq;\r\n    for (const auto& event : sequence) {\r\n      EXPECT_CALL(*this, OnEvent(testing::Eq(event)))\r\n          .Times(1);\r\n    }\r\n  }\r\n  \r\n  void ExpectNoEvents() {\r\n    EXPECT_CALL(*this, OnEvent(testing::_))\r\n        .Times(0);\r\n  }\r\n  \r\n  // Set up filtering behavior for tests\r\n  void SetupFiltering(std::function<bool(const EventType&)> filter_func) {\r\n    ON_CALL(*this, ShouldReceiveEvent(testing::_))\r\n        .WillByDefault(testing::Invoke(filter_func));\r\n  }\r\n  \r\n  // Record events for verification\r\n  void EnableEventRecording() {\r\n    ON_CALL(*this, OnEvent(testing::_))\r\n        .WillByDefault(testing::Invoke([this](const EventType& event) {\r\n          recorded_events_.push_back(event);\r\n        }));\r\n  }\r\n  \r\n  const std::vector<EventType>& GetRecordedEvents() const {\r\n    return recorded_events_;\r\n  }\r\n  \r\n  void ClearRecordedEvents() {\r\n    recorded_events_.clear();\r\n  }\r\n  \r\n private:\r\n  std::vector<EventType> recorded_events_;\r\n};\r\n\r\n// Test helper for observer pattern testing\r\ntemplate<typename SubjectType, typename EventType>\r\nclass ObserverTestHelper {\r\n public:\r\n  ObserverTestHelper() : mock_observer_(std::make_unique<MockObserver<EventType>>()) {}\r\n  \r\n  void SetUp() {\r\n    subject_.AddObserver(mock_observer_.get());\r\n  }\r\n  \r\n  void TearDown() {\r\n    subject_.RemoveObserver(mock_observer_.get());\r\n  }\r\n  \r\n  MockObserver<EventType>* mock_observer() { return mock_observer_.get(); }\r\n  SubjectType* subject() { return &subject_; }\r\n  \r\n  // Verify observer was called within timeout\r\n  void VerifyObserverCalledWithin(base::TimeDelta timeout) {\r\n    base::RunLoop run_loop;\r\n    base::OneShotTimer timer;\r\n    \r\n    EXPECT_CALL(*mock_observer_, OnEvent(testing::_))\r\n        .WillOnce(testing::InvokeWithoutArgs([&run_loop]() {\r\n          run_loop.Quit();\r\n        }));\r\n    \r\n    timer.Start(FROM_HERE, timeout, \r\n                base::BindOnce([](base::RunLoop* loop) { loop->Quit(); }, \r\n                              &run_loop));\r\n    \r\n    run_loop.Run();\r\n  }\r\n  \r\n private:\r\n  SubjectType subject_;\r\n  std::unique_ptr<MockObserver<EventType>> mock_observer_;\r\n};\r\n```\r\n\r\n### 5.2. Test Examples\r\n\r\nComprehensive test examples for observer patterns:\r\n\r\n```cpp\r\n// Test fixture for download observer testing\r\nclass DownloadObserverTest : public testing::Test {\r\n protected:\r\n  void SetUp() override {\r\n    download_service_ = std::make_unique<DownloadServiceImpl>(\r\n        TestProfile::CreateProfile());\r\n    mock_observer_ = std::make_unique<MockDownloadObserver>();\r\n    download_service_->AddLocalObserver(mock_observer_.get());\r\n  }\r\n  \r\n  void TearDown() override {\r\n    download_service_->RemoveLocalObserver(mock_observer_.get());\r\n  }\r\n  \r\n  std::unique_ptr<DownloadServiceImpl> download_service_;\r\n  std::unique_ptr<MockDownloadObserver> mock_observer_;\r\n};\r\n\r\nTEST_F(DownloadObserverTest, NotifiesOnDownloadCreated) {\r\n  const GURL test_url(\"https://example.com/file.pdf\");\r\n  const std::string expected_id = \"test-download-id\";\r\n  \r\n  // Set up expectation\r\n  EXPECT_CALL(*mock_observer_, OnDownloadCreated(expected_id, testing::_))\r\n      .Times(1);\r\n  \r\n  // Trigger download creation\r\n  download_service_->StartDownload(test_url, \"\", base::DoNothing());\r\n  \r\n  // Verify expectation\r\n  testing::Mock::VerifyAndClearExpectations(mock_observer_.get());\r\n}\r\n\r\nTEST_F(DownloadObserverTest, BatchNotificationForMultipleDownloads) {\r\n  std::vector<GURL> urls = {\r\n    GURL(\"https://example.com/file1.pdf\"),\r\n    GURL(\"https://example.com/file2.pdf\"),\r\n    GURL(\"https://example.com/file3.pdf\")\r\n  };\r\n  \r\n  // Expect three creation events\r\n  EXPECT_CALL(*mock_observer_, OnDownloadCreated(testing::_, testing::_))\r\n      .Times(3);\r\n  \r\n  // Start multiple downloads\r\n  for (const auto& url : urls) {\r\n    download_service_->StartDownload(url, \"\", base::DoNothing());\r\n  }\r\n  \r\n  // Allow event processing\r\n  base::RunLoop().RunUntilIdle();\r\n  \r\n  testing::Mock::VerifyAndClearExpectations(mock_observer_.get());\r\n}\r\n\r\n// Test for filtered observer\r\nTEST_F(DownloadObserverTest, FilteredObserverReceivesOnlyRelevantEvents) {\r\n  auto filtered_observer = std::make_unique<MockFilteredDownloadObserver>();\r\n  \r\n  // Set up filter to only receive PDF downloads\r\n  filtered_observer->SetFilter(\r\n      std::make_unique<FileTypeFilter>(\"application/pdf\"));\r\n  \r\n  download_service_->AddLocalObserver(filtered_observer.get());\r\n  \r\n  // Expect only PDF download to be notified\r\n  EXPECT_CALL(*filtered_observer, OnFilteredEvent(testing::_))\r\n      .Times(1);\r\n  \r\n  // Start downloads of different types\r\n  download_service_->StartDownload(GURL(\"https://example.com/image.jpg\"), \"\", base::DoNothing());\r\n  download_service_->StartDownload(GURL(\"https://example.com/document.pdf\"), \"\", base::DoNothing());\r\n  download_service_->StartDownload(GURL(\"https://example.com/video.mp4\"), \"\", base::DoNothing());\r\n  \r\n  base::RunLoop().RunUntilIdle();\r\n  \r\n  download_service_->RemoveLocalObserver(filtered_observer.get());\r\n}\r\n\r\n// Test for async observer notification\r\nTEST_F(DownloadObserverTest, AsyncNotificationWorksCorrectly) {\r\n  base::test::TaskEnvironment task_environment{\r\n      base::test::TaskEnvironment::TimeSource::MOCK_TIME};\r\n  \r\n  auto async_observer = std::make_unique<MockAsyncDownloadObserver>();\r\n  download_service_->AddLocalObserver(async_observer.get());\r\n  \r\n  // Set up expectation for async notification\r\n  base::RunLoop run_loop;\r\n  EXPECT_CALL(*async_observer, OnDownloadCreated(testing::_, testing::_))\r\n      .WillOnce(testing::InvokeWithoutArgs([&run_loop]() {\r\n        run_loop.Quit();\r\n      }));\r\n  \r\n  // Start download\r\n  download_service_->StartDownload(GURL(\"https://example.com/file.pdf\"), \"\", base::DoNothing());\r\n  \r\n  // Fast-forward time and run pending tasks\r\n  task_environment.FastForwardBy(base::Milliseconds(100));\r\n  run_loop.Run();\r\n  \r\n  download_service_->RemoveLocalObserver(async_observer.get());\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Observer Pattern Best Practices (v134+)\r\n\r\n### 6.1. Memory Management\r\n\r\n```cpp\r\n// RAII observer registration helper\r\ntemplate<typename SubjectType, typename ObserverType>\r\nclass ScopedObserverRegistration {\r\n public:\r\n  ScopedObserverRegistration(SubjectType* subject, ObserverType* observer)\r\n      : subject_(subject), observer_(observer) {\r\n    DCHECK(subject_);\r\n    DCHECK(observer_);\r\n    subject_->AddObserver(observer_);\r\n  }\r\n  \r\n  ~ScopedObserverRegistration() {\r\n    if (subject_ && observer_) {\r\n      subject_->RemoveObserver(observer_);\r\n    }\r\n  }\r\n  \r\n  // Non-copyable, movable\r\n  ScopedObserverRegistration(const ScopedObserverRegistration&) = delete;\r\n  ScopedObserverRegistration& operator=(const ScopedObserverRegistration&) = delete;\r\n  \r\n  ScopedObserverRegistration(ScopedObserverRegistration&& other) noexcept\r\n      : subject_(std::exchange(other.subject_, nullptr)),\r\n        observer_(std::exchange(other.observer_, nullptr)) {}\r\n  \r\n  ScopedObserverRegistration& operator=(ScopedObserverRegistration&& other) noexcept {\r\n    if (this != &other) {\r\n      if (subject_ && observer_) {\r\n        subject_->RemoveObserver(observer_);\r\n      }\r\n      subject_ = std::exchange(other.subject_, nullptr);\r\n      observer_ = std::exchange(other.observer_, nullptr);\r\n    }\r\n    return *this;\r\n  }\r\n  \r\n  void Reset() {\r\n    if (subject_ && observer_) {\r\n      subject_->RemoveObserver(observer_);\r\n      subject_ = nullptr;\r\n      observer_ = nullptr;\r\n    }\r\n  }\r\n  \r\n private:\r\n  SubjectType* subject_;\r\n  ObserverType* observer_;\r\n};\r\n```\r\n\r\n### 6.2. Performance Optimization\r\n\r\n```cpp\r\n// High-performance observer list with minimal allocations\r\ntemplate<typename ObserverType>\r\nclass OptimizedObserverList {\r\n public:\r\n  OptimizedObserverList() {\r\n    observers_.reserve(kInitialCapacity);\r\n  }\r\n  \r\n  void AddObserver(ObserverType* observer) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    CHECK(observer);\r\n    \r\n    // Check if already exists to avoid duplicates\r\n    if (std::find(observers_.begin(), observers_.end(), observer) == observers_.end()) {\r\n      observers_.push_back(observer);\r\n    }\r\n  }\r\n  \r\n  void RemoveObserver(ObserverType* observer) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    CHECK(observer);\r\n    \r\n    auto it = std::find(observers_.begin(), observers_.end(), observer);\r\n    if (it != observers_.end()) {\r\n      // Use swap-and-pop for O(1) removal\r\n      std::swap(*it, observers_.back());\r\n      observers_.pop_back();\r\n    }\r\n  }\r\n  \r\n  // High-performance notification with minimal overhead\r\n  template<typename Method, typename... Args>\r\n  void NotifyObservers(Method method, Args&&... args) {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    \r\n    // Use simple iteration for maximum performance\r\n    for (auto* observer : observers_) {\r\n      if (observer) {\r\n        (observer->*method)(args...);\r\n      }\r\n    }\r\n  }\r\n  \r\n  size_t size() const {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    return observers_.size();\r\n  }\r\n  \r\n  bool empty() const {\r\n    DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);\r\n    return observers_.empty();\r\n  }\r\n  \r\n private:\r\n  static constexpr size_t kInitialCapacity = 4;\r\n  \r\n  std::vector<ObserverType*> observers_;\r\n  SEQUENCE_CHECKER(sequence_checker_);\r\n};\r\n```\r\n\r\n---\r\n\r\n## 7. Real-World Examples from Chromium v134+\r\n\r\n### 7.1. WebContents Observer\r\n\r\nModern web contents observer with enhanced security and privacy events:\r\n\r\n```cpp\r\n// Simplified WebContentsObserver for v134+\r\nclass WebContentsObserver : public base::SupportsWeakPtr<WebContentsObserver> {\r\n public:\r\n  explicit WebContentsObserver(content::WebContents* web_contents)\r\n      : web_contents_(web_contents) {\r\n    if (web_contents_) {\r\n      web_contents_->AddObserver(this);\r\n    }\r\n  }\r\n  \r\n  virtual ~WebContentsObserver() {\r\n    if (web_contents_) {\r\n      web_contents_->RemoveObserver(this);\r\n    }\r\n  }\r\n  \r\n  // Navigation events\r\n  virtual void DidStartNavigation(content::NavigationHandle* navigation) {}\r\n  virtual void DidFinishNavigation(content::NavigationHandle* navigation) {}\r\n  \r\n  // Security events (v134+)\r\n  virtual void DidChangeSecurityState(SecurityLevel security_level) {}\r\n  virtual void OnPermissionStatusChanged(blink::mojom::PermissionName permission,\r\n                                        blink::mojom::PermissionStatus status) {}\r\n  \r\n  // Privacy Sandbox events (v134+)\r\n  virtual void OnTopicsAPIUsed(const std::vector<int>& topic_ids) {}\r\n  virtual void OnFledgeAuctionCompleted(const GURL& seller_origin,\r\n                                       bool success) {}\r\n  \r\n  // Performance events (v134+)\r\n  virtual void OnCoreWebVitalsUpdated(double lcp, double fid, double cls) {}\r\n  virtual void OnMemoryUsageUpdated(const MemoryUsageInfo& usage) {}\r\n  \r\n protected:\r\n  content::WebContents* web_contents() const { return web_contents_; }\r\n  \r\n private:\r\n  content::WebContents* web_contents_;\r\n};\r\n```\r\n\r\n### 7.2. Preference Observer\r\n\r\nModern preference system observer with hierarchical settings:\r\n\r\n```cpp\r\n// Preference observer with fine-grained change detection\r\nclass PrefObserver : public base::SupportsWeakPtr<PrefObserver> {\r\n public:\r\n  virtual ~PrefObserver() = default;\r\n  \r\n  // Called when a preference value changes\r\n  virtual void OnPreferenceChanged(const std::string& pref_name,\r\n                                  const base::Value& old_value,\r\n                                  const base::Value& new_value) {}\r\n  \r\n  // Called for Privacy Sandbox preference changes\r\n  virtual void OnPrivacySandboxPrefChanged(const std::string& pref_name,\r\n                                          bool enabled) {}\r\n  \r\n  // Called for security-related preference changes\r\n  virtual void OnSecurityPrefChanged(const std::string& pref_name,\r\n                                    const base::Value& value) {}\r\n};\r\n\r\nclass ModernPrefService {\r\n public:\r\n  void AddObserver(PrefObserver* observer) {\r\n    observers_.AddObserver(observer);\r\n  }\r\n  \r\n  void RemoveObserver(PrefObserver* observer) {\r\n    observers_.RemoveObserver(observer);\r\n  }\r\n  \r\n  void SetUserPref(const std::string& pref_name, base::Value value) {\r\n    auto old_value = GetValue(pref_name);\r\n    \r\n    // Update preference\r\n    user_prefs_[pref_name] = value.Clone();\r\n    \r\n    // Notify observers\r\n    observers_.NotifyObservers(&PrefObserver::OnPreferenceChanged,\r\n                              pref_name, old_value, value);\r\n    \r\n    // Handle special preference categories\r\n    if (IsPrivacySandboxPref(pref_name)) {\r\n      bool enabled = value.is_bool() ? value.GetBool() : false;\r\n      observers_.NotifyObservers(&PrefObserver::OnPrivacySandboxPrefChanged,\r\n                                pref_name, enabled);\r\n    }\r\n    \r\n    if (IsSecurityPref(pref_name)) {\r\n      observers_.NotifyObservers(&PrefObserver::OnSecurityPrefChanged,\r\n                                pref_name, value);\r\n    }\r\n  }\r\n  \r\n private:\r\n  bool IsPrivacySandboxPref(const std::string& pref_name) const {\r\n    return base::StartsWith(pref_name, \"privacy_sandbox.\") ||\r\n           pref_name == \"profile.cookie_controls_mode\";\r\n  }\r\n  \r\n  bool IsSecurityPref(const std::string& pref_name) const {\r\n    return base::StartsWith(pref_name, \"security.\") ||\r\n           pref_name == \"safebrowsing.enabled\";\r\n  }\r\n  \r\n  base::Value GetValue(const std::string& pref_name) const {\r\n    auto it = user_prefs_.find(pref_name);\r\n    return it != user_prefs_.end() ? it->second.Clone() : base::Value();\r\n  }\r\n  \r\n  ThreadSafeObserverList<PrefObserver> observers_;\r\n  std::unordered_map<std::string, base::Value> user_prefs_;\r\n};\r\n```\r\n\r\n---\r\n\r\n## 8. Observer Pattern Summary (v134+)\r\n\r\n### Key Advantages\r\n- **Decoupled Architecture**: Subjects and observers remain loosely coupled\r\n- **Real-Time Updates**: Immediate notification of state changes\r\n- **Scalability**: Multiple observers can monitor a single subject\r\n- **Testability**: Easy mocking and verification of event handling\r\n- **Flexibility**: Dynamic subscription and unsubscription\r\n\r\n### Modern Enhancements (v134+)\r\n- **Memory Safety**: Automatic cleanup using weak pointers and RAII\r\n- **Thread Safety**: Safe cross-thread notification mechanisms\r\n- **Performance**: Optimized notification with batching and filtering\r\n- **Service Integration**: Seamless Mojo IPC for cross-process observation\r\n- **Error Handling**: Robust error propagation and recovery\r\n\r\n### Best Practices\r\n1. **Use weak pointers** to prevent memory leaks and dangling references\r\n2. **Implement proper cleanup** in destructors and scope guards\r\n3. **Consider batching** for high-frequency events to improve performance\r\n4. **Apply filtering** to reduce unnecessary notifications\r\n5. **Test thoroughly** with mock observers and comprehensive scenarios\r\n6. **Document event contracts** clearly for maintainable code\r\n7. **Handle edge cases** like observer removal during notification\r\n\r\nThe Observer pattern continues to be essential in modern Chromium architecture, providing the foundation for event-driven communication across the complex browser ecosystem while maintaining performance, security, and maintainability standards.\r\n"
  },
  {
    "path": "architecture/design-patterns/factory-pattern",
    "title": "Factory Pattern in Modern Chromium (v134+)",
    "content": "# Factory Pattern in Modern Chromium (v134+)\r\n\r\nThe Factory pattern is fundamental to Chromium's architecture, providing flexible object creation that abstracts implementation details and enables platform-specific, feature-gated, and service-oriented instantiation. In modern Chromium v134+, factory patterns have evolved to support Mojo services, modern C++ practices, and sophisticated dependency injection.\r\n\r\n---\r\n\r\n## 1. Modern Factory Pattern Evolution (v134+)\r\n\r\n### Core Principles\r\n- **Abstraction**: Hide complex instantiation logic behind clean interfaces\r\n- **Flexibility**: Support multiple implementations based on runtime conditions\r\n- **Testability**: Enable easy mocking and dependency injection for tests\r\n- **Service Integration**: Seamless integration with Mojo service architecture\r\n- **Memory Safety**: Modern C++ RAII and smart pointer practices\r\n\r\n### Contemporary Applications\r\n- **Service Factories**: Creating Mojo service implementations\r\n- **Platform Abstraction**: OS-specific component instantiation\r\n- **Feature Flags**: Conditional feature implementation based on experiments\r\n- **Renderer Components**: Process-safe object creation with IPC awareness\r\n- **Privacy Sandbox**: Secure component instantiation with capability restrictions\r\n\r\n---\r\n\r\n## 2. Factory Pattern Types in Chromium v134+\r\n\r\n### 2.1. Static Factory Methods\r\n\r\nModern static factories with enhanced type safety and error handling:\r\n\r\n```cpp\r\n// Modern factory with base::expected for error handling\r\nclass NetworkContextFactory {\r\n public:\r\n  static base::expected<std::unique_ptr<NetworkContext>, NetworkError>\r\n  CreateForProfile(Profile* profile, \r\n                   const NetworkContextParams& params) {\r\n    if (!profile || !profile->IsValidForNetworking()) {\r\n      return base::unexpected(NetworkError::kInvalidProfile);\r\n    }\r\n    \r\n    auto context = std::make_unique<NetworkContextImpl>(profile);\r\n    if (auto result = context->Initialize(params); !result.has_value()) {\r\n      return base::unexpected(result.error());\r\n    }\r\n    \r\n    return context;\r\n  }\r\n  \r\n  // Factory method with modern C++20 concepts\r\n  template<typename ContextType>\r\n    requires std::derived_from<ContextType, NetworkContext>\r\n  static std::unique_ptr<ContextType> CreateCustomContext(\r\n      const CustomNetworkParams& params) {\r\n    return std::make_unique<ContextType>(params);\r\n  }\r\n};\r\n```\r\n\r\n### 2.2. Mojo Service Factories\r\n\r\nModern service factories integrated with Mojo IPC and capability-based security:\r\n\r\n```cpp\r\n// Service factory with Mojo integration\r\nclass DownloadServiceFactory {\r\n public:\r\n  static void Create(\r\n      Profile* profile,\r\n      mojo::PendingReceiver<download::mojom::DownloadService> receiver) {\r\n    // Validate profile and permissions\r\n    if (!profile || !profile->HasDownloadPermission()) {\r\n      receiver.ResetWithReason(1, \"Insufficient permissions\");\r\n      return;\r\n    }\r\n    \r\n    // Create service with proper context\r\n    auto service = std::make_unique<DownloadServiceImpl>(\r\n        profile->GetPath(),\r\n        profile->GetPrefs(),\r\n        profile->GetDownloadManager());\r\n    \r\n    // Bind with automatic cleanup on disconnect\r\n    mojo::MakeSelfOwnedReceiver(std::move(service), std::move(receiver));\r\n  }\r\n  \r\n  // Factory for testing with dependency injection\r\n  static std::unique_ptr<download::mojom::DownloadService> CreateForTesting(\r\n      std::unique_ptr<DownloadManager> manager,\r\n      std::unique_ptr<PrefService> prefs) {\r\n    return std::make_unique<MockDownloadService>(\r\n        std::move(manager), std::move(prefs));\r\n  }\r\n};\r\n```\r\n\r\n### 2.3. Abstract Factory Pattern\r\n\r\nModern abstract factories for platform-specific and feature-specific implementations:\r\n\r\n```cpp\r\n// Abstract factory for UI components with modern C++\r\nclass UIComponentFactory {\r\n public:\r\n  virtual ~UIComponentFactory() = default;\r\n  \r\n  // Pure virtual factory methods\r\n  virtual std::unique_ptr<TabStripModel> CreateTabStripModel(\r\n      Browser* browser) = 0;\r\n  virtual std::unique_ptr<LocationBar> CreateLocationBar(\r\n      Browser* browser) = 0;\r\n  virtual std::unique_ptr<BookmarkBar> CreateBookmarkBar(\r\n      Browser* browser) = 0;\r\n  \r\n  // Static factory to get platform-specific implementation\r\n  static std::unique_ptr<UIComponentFactory> Create();\r\n};\r\n\r\n// Platform-specific implementation\r\nclass WindowsUIComponentFactory : public UIComponentFactory {\r\n public:\r\n  std::unique_ptr<TabStripModel> CreateTabStripModel(\r\n      Browser* browser) override {\r\n    return std::make_unique<WindowsTabStripModel>(browser);\r\n  }\r\n  \r\n  std::unique_ptr<LocationBar> CreateLocationBar(\r\n      Browser* browser) override {\r\n    return std::make_unique<WindowsLocationBar>(browser);\r\n  }\r\n  \r\n  std::unique_ptr<BookmarkBar> CreateBookmarkBar(\r\n      Browser* browser) override {\r\n    return std::make_unique<WindowsBookmarkBar>(browser);\r\n  }\r\n};\r\n```\r\n\r\n### 2.4. Builder-Style Factories\r\n\r\nModern fluent interfaces for complex object construction:\r\n\r\n```cpp\r\n// Builder-style factory for complex configuration\r\nclass RenderFrameHostFactory {\r\n public:\r\n  class Builder {\r\n   public:\r\n    Builder& SetSiteInstance(scoped_refptr<SiteInstance> site_instance) {\r\n      site_instance_ = std::move(site_instance);\r\n      return *this;\r\n    }\r\n    \r\n    Builder& SetRenderViewHost(RenderViewHost* render_view_host) {\r\n      render_view_host_ = render_view_host;\r\n      return *this;\r\n    }\r\n    \r\n    Builder& SetFrameTreeNode(FrameTreeNode* frame_tree_node) {\r\n      frame_tree_node_ = frame_tree_node;\r\n      return *this;\r\n    }\r\n    \r\n    Builder& EnableFeatures(const std::vector<std::string>& features) {\r\n      enabled_features_.insert(enabled_features_.end(), \r\n                              features.begin(), features.end());\r\n      return *this;\r\n    }\r\n    \r\n    // Build with validation and error handling\r\n    base::expected<std::unique_ptr<RenderFrameHost>, FrameError> Build() {\r\n      if (!site_instance_ || !render_view_host_ || !frame_tree_node_) {\r\n        return base::unexpected(FrameError::kMissingRequiredComponents);\r\n      }\r\n      \r\n      auto frame_host = std::make_unique<RenderFrameHostImpl>(\r\n          site_instance_, render_view_host_, frame_tree_node_);\r\n      \r\n      // Apply feature configuration\r\n      for (const auto& feature : enabled_features_) {\r\n        frame_host->EnableFeature(feature);\r\n      }\r\n      \r\n      return frame_host;\r\n    }\r\n    \r\n   private:\r\n    scoped_refptr<SiteInstance> site_instance_;\r\n    RenderViewHost* render_view_host_ = nullptr;\r\n    FrameTreeNode* frame_tree_node_ = nullptr;\r\n    std::vector<std::string> enabled_features_;\r\n  };\r\n  \r\n  static Builder CreateBuilder() { return Builder{}; }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 3. Key Factory Implementations in v134+\r\n\r\n### 3.1. BrowserContextKeyedServiceFactory\r\n\r\nModern service factory with enhanced lifecycle management:\r\n\r\n```cpp\r\nclass DownloadCoreServiceFactory : public BrowserContextKeyedServiceFactory {\r\n public:\r\n  static DownloadCoreService* GetForBrowserContext(BrowserContext* context) {\r\n    return static_cast<DownloadCoreService*>(\r\n        GetInstance()->GetServiceForBrowserContext(context, true));\r\n  }\r\n  \r\n  static DownloadCoreServiceFactory* GetInstance() {\r\n    static base::NoDestructor<DownloadCoreServiceFactory> instance;\r\n    return instance.get();\r\n  }\r\n  \r\n private:\r\n  friend base::NoDestructor<DownloadCoreServiceFactory>;\r\n  \r\n  DownloadCoreServiceFactory()\r\n      : BrowserContextKeyedServiceFactory(\r\n            \"DownloadCoreService\",\r\n            BrowserContextDependencyManager::GetInstance()) {\r\n    // Declare dependencies\r\n    DependsOn(SimpleDownloadManagerCoordinatorFactory::GetInstance());\r\n    DependsOn(HistoryServiceFactory::GetInstance());\r\n  }\r\n  \r\n  KeyedService* BuildServiceInstanceFor(\r\n      content::BrowserContext* context) const override {\r\n    if (!base::FeatureList::IsEnabled(features::kDownloadService)) {\r\n      return nullptr;\r\n    }\r\n    \r\n    auto* profile = Profile::FromBrowserContext(context);\r\n    return new DownloadCoreServiceImpl(\r\n        profile, \r\n        std::make_unique<DownloadDriverImpl>(),\r\n        std::make_unique<TaskSchedulerImpl>());\r\n  }\r\n  \r\n  bool ServiceIsCreatedWithBrowserContext() const override { return true; }\r\n  bool ServiceIsNULLWhileTesting() const override { return false; }\r\n};\r\n```\r\n\r\n### 3.2. URLLoaderFactory Pattern\r\n\r\nModern network factory with enhanced security and capability delegation:\r\n\r\n```cpp\r\nclass NetworkServiceURLLoaderFactory {\r\n public:\r\n  // Create factory with proper security context\r\n  static mojo::PendingRemote<network::mojom::URLLoaderFactory>\r\n  CreateForFrame(RenderFrameHost* frame_host,\r\n                 const url::Origin& request_initiator) {\r\n    if (!frame_host || !frame_host->IsRenderFrameLive()) {\r\n      return mojo::PendingRemote<network::mojom::URLLoaderFactory>();\r\n    }\r\n    \r\n    // Create with appropriate security restrictions\r\n    auto factory_params = network::mojom::URLLoaderFactoryParams::New();\r\n    factory_params->process_id = frame_host->GetProcess()->GetID();\r\n    factory_params->request_initiator_origin_lock = request_initiator;\r\n    factory_params->is_corb_enabled = true;\r\n    factory_params->is_trusted = false;\r\n    \r\n    // Apply Content Security Policy\r\n    if (auto* policy = frame_host->GetContentSecurityPolicy()) {\r\n      factory_params->client_security_state = \r\n          policy->CreateClientSecurityState();\r\n    }\r\n    \r\n    mojo::PendingRemote<network::mojom::URLLoaderFactory> factory_remote;\r\n    frame_host->GetStoragePartition()\r\n        ->GetNetworkContext()\r\n        ->CreateURLLoaderFactory(\r\n            factory_remote.InitWithNewPipeAndPassReceiver(),\r\n            std::move(factory_params));\r\n    \r\n    return factory_remote;\r\n  }\r\n  \r\n  // Factory for service workers with restricted capabilities\r\n  static mojo::PendingRemote<network::mojom::URLLoaderFactory>\r\n  CreateForServiceWorker(\r\n      ServiceWorkerVersion* version,\r\n      const blink::StorageKey& storage_key) {\r\n    \r\n    auto factory_params = network::mojom::URLLoaderFactoryParams::New();\r\n    factory_params->process_id = version->embedded_worker()->process_id();\r\n    factory_params->request_initiator_origin_lock = storage_key.origin();\r\n    factory_params->is_trusted = false;\r\n    factory_params->automatically_assign_isolation_info = true;\r\n    \r\n    // Restrict to same-origin and specific schemes\r\n    factory_params->unsafe_non_webby_requestor = false;\r\n    \r\n    mojo::PendingRemote<network::mojom::URLLoaderFactory> factory_remote;\r\n    version->GetStoragePartition()\r\n        ->GetNetworkContext()\r\n        ->CreateURLLoaderFactory(\r\n            factory_remote.InitWithNewPipeAndPassReceiver(),\r\n            std::move(factory_params));\r\n    \r\n    return factory_remote;\r\n  }\r\n};\r\n```\r\n\r\n### 3.3. GPU Service Factory\r\n\r\nModern graphics factory with advanced GPU capabilities:\r\n\r\n```cpp\r\nclass GpuServiceFactory {\r\n public:\r\n  static std::unique_ptr<viz::GpuServiceImpl> Create(\r\n      const gpu::GpuPreferences& gpu_preferences,\r\n      base::WeakPtr<viz::ImageTransportSurfaceDelegate> delegate) {\r\n    \r\n    // Initialize GPU feature info\r\n    auto gpu_feature_info = gpu::GetGpuFeatureInfo(\r\n        gpu::GpuDriverBugWorkarounds(), gpu_preferences);\r\n    \r\n    // Create with WebGPU support if available\r\n    auto gpu_service = std::make_unique<viz::GpuServiceImpl>(\r\n        gpu_feature_info,\r\n        gpu_preferences,\r\n        std::move(delegate),\r\n        /*enable_webgpu=*/base::FeatureList::IsEnabled(features::kWebGPU));\r\n    \r\n    // Configure advanced features\r\n    if (gpu_feature_info.IsWebGPUSupported()) {\r\n      gpu_service->EnableWebGPUService();\r\n    }\r\n    \r\n    if (base::FeatureList::IsEnabled(features::kVaapiVideoDecoding)) {\r\n      gpu_service->EnableHardwareVideoDecoding();\r\n    }\r\n    \r\n    return gpu_service;\r\n  }\r\n  \r\n  // Factory for testing with mock GPU capabilities\r\n  static std::unique_ptr<viz::GpuServiceImpl> CreateForTesting(\r\n      std::unique_ptr<gpu::GpuMemoryBufferFactory> memory_buffer_factory,\r\n      std::unique_ptr<gpu::ImageFactory> image_factory) {\r\n    \r\n    auto gpu_service = std::make_unique<MockGpuServiceImpl>();\r\n    gpu_service->SetMemoryBufferFactory(std::move(memory_buffer_factory));\r\n    gpu_service->SetImageFactory(std::move(image_factory));\r\n    \r\n    return gpu_service;\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 4. Modern C++ Factory Techniques (v134+)\r\n\r\n### 4.1. Template-Based Factories\r\n\r\nUsing concepts and template metaprogramming for type-safe factories:\r\n\r\n```cpp\r\n// Concept for factory-creatable types\r\ntemplate<typename T>\r\nconcept FactoryCreatable = requires(T t) {\r\n  typename T::InitParams;\r\n  { T::Create(std::declval<typename T::InitParams>()) } \r\n    -> std::convertible_to<std::unique_ptr<T>>;\r\n};\r\n\r\n// Generic factory with compile-time validation\r\ntemplate<FactoryCreatable T>\r\nclass GenericFactory {\r\n public:\r\n  template<typename... Args>\r\n  static base::expected<std::unique_ptr<T>, FactoryError> \r\n  Create(Args&&... args) {\r\n    try {\r\n      auto params = typename T::InitParams{std::forward<Args>(args)...};\r\n      if (auto result = ValidateParams(params); !result.has_value()) {\r\n        return base::unexpected(result.error());\r\n      }\r\n      \r\n      return T::Create(std::move(params));\r\n    } catch (const std::exception& e) {\r\n      return base::unexpected(FactoryError::kCreationFailed);\r\n    }\r\n  }\r\n  \r\n private:\r\n  static base::expected<void, FactoryError> ValidateParams(\r\n      const typename T::InitParams& params) {\r\n    // Generic validation logic\r\n    if constexpr (requires { params.Validate(); }) {\r\n      return params.Validate() ? base::expected<void, FactoryError>{}\r\n                               : base::unexpected(FactoryError::kInvalidParams);\r\n    }\r\n    return {};\r\n  }\r\n};\r\n```\r\n\r\n### 4.2. Registry-Based Factories\r\n\r\nModern factory registration with type safety:\r\n\r\n```cpp\r\n// Factory registry for extensible component creation\r\ntemplate<typename BaseType>\r\nclass FactoryRegistry {\r\n public:\r\n  using FactoryFunction = std::function<std::unique_ptr<BaseType>()>;\r\n  using ConditionalFactory = std::function<std::unique_ptr<BaseType>(\r\n      const FactoryContext&)>;\r\n  \r\n  // Register factory with type information\r\n  template<typename DerivedType>\r\n    requires std::derived_from<DerivedType, BaseType>\r\n  static void RegisterFactory(const std::string& name,\r\n                              ConditionalFactory factory) {\r\n    GetRegistry()[name] = FactoryEntry{\r\n      .factory = std::move(factory),\r\n      .type_info = typeid(DerivedType),\r\n      .creation_flags = DerivedType::GetCreationFlags()\r\n    };\r\n  }\r\n  \r\n  // Create with automatic selection based on context\r\n  static base::expected<std::unique_ptr<BaseType>, FactoryError>\r\n  Create(const std::string& name, const FactoryContext& context) {\r\n    auto& registry = GetRegistry();\r\n    auto it = registry.find(name);\r\n    \r\n    if (it == registry.end()) {\r\n      return base::unexpected(FactoryError::kUnknownType);\r\n    }\r\n    \r\n    const auto& entry = it->second;\r\n    if (!IsCompatibleWithContext(entry, context)) {\r\n      return base::unexpected(FactoryError::kIncompatibleContext);\r\n    }\r\n    \r\n    try {\r\n      auto instance = entry.factory(context);\r\n      if (!instance) {\r\n        return base::unexpected(FactoryError::kCreationFailed);\r\n      }\r\n      \r\n      return instance;\r\n    } catch (const std::exception& e) {\r\n      LOG(ERROR) << \"Factory creation failed: \" << e.what();\r\n      return base::unexpected(FactoryError::kCreationFailed);\r\n    }\r\n  }\r\n  \r\n private:\r\n  struct FactoryEntry {\r\n    ConditionalFactory factory;\r\n    std::type_info type_info;\r\n    uint32_t creation_flags;\r\n  };\r\n  \r\n  static std::unordered_map<std::string, FactoryEntry>& GetRegistry() {\r\n    static base::NoDestructor<std::unordered_map<std::string, FactoryEntry>> \r\n        registry;\r\n    return *registry;\r\n  }\r\n  \r\n  static bool IsCompatibleWithContext(const FactoryEntry& entry,\r\n                                      const FactoryContext& context) {\r\n    return (entry.creation_flags & context.GetRequiredFlags()) == \r\n           context.GetRequiredFlags();\r\n  }\r\n};\r\n```\r\n\r\n### 4.3. Async Factory Pattern\r\n\r\nModern async factories with coroutine support:\r\n\r\n```cpp\r\n// Async factory for heavy initialization\r\nclass AsyncResourceFactory {\r\n public:\r\n  // Coroutine-based async factory\r\n  static base::expected<std::unique_ptr<Resource>, ResourceError>\r\n  CreateAsync(const ResourceParams& params) {\r\n    // Validate parameters synchronously\r\n    if (auto validation = ValidateParams(params); !validation.has_value()) {\r\n      return base::unexpected(validation.error());\r\n    }\r\n    \r\n    // Create resource with async initialization\r\n    auto resource = std::make_unique<ResourceImpl>(params);\r\n    \r\n    // Schedule async initialization\r\n    auto init_result = co_await resource->InitializeAsync();\r\n    if (!init_result.has_value()) {\r\n      return base::unexpected(init_result.error());\r\n    }\r\n    \r\n    return resource;\r\n  }\r\n  \r\n  // Traditional callback-based async factory\r\n  static void CreateAsync(\r\n      const ResourceParams& params,\r\n      base::OnceCallback<void(base::expected<std::unique_ptr<Resource>, \r\n                                           ResourceError>)> callback) {\r\n    \r\n    base::ThreadPool::PostTaskAndReplyWithResult(\r\n        FROM_HERE,\r\n        {base::TaskPriority::USER_BLOCKING, base::MayBlock()},\r\n        base::BindOnce(&DoAsyncCreation, params),\r\n        std::move(callback));\r\n  }\r\n  \r\n private:\r\n  static base::expected<std::unique_ptr<Resource>, ResourceError>\r\n  DoAsyncCreation(const ResourceParams& params) {\r\n    // Heavy initialization work on background thread\r\n    auto resource = std::make_unique<ResourceImpl>(params);\r\n    \r\n    if (auto result = resource->LoadData(); !result.has_value()) {\r\n      return base::unexpected(result.error());\r\n    }\r\n    \r\n    if (auto result = resource->InitializeConnections(); !result.has_value()) {\r\n      return base::unexpected(result.error());\r\n    }\r\n    \r\n    return resource;\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 5. Testing Factory Patterns (v134+)\r\n\r\n### 5.1. Test Factory Implementation\r\n\r\nModern test factories with comprehensive mocking:\r\n\r\n```cpp\r\nclass TestDownloadServiceFactory {\r\n public:\r\n  // Create mock service for unit tests\r\n  static std::unique_ptr<MockDownloadService> CreateMockService() {\r\n    auto mock_service = std::make_unique<MockDownloadService>();\r\n    \r\n    // Set up default expectations\r\n    EXPECT_CALL(*mock_service, StartDownload(testing::_))\r\n        .WillRepeatedly(testing::Return(DownloadResult::kSuccess));\r\n    \r\n    EXPECT_CALL(*mock_service, GetDownloadState(testing::_))\r\n        .WillRepeatedly(testing::Return(DownloadState::kComplete));\r\n    \r\n    return mock_service;\r\n  }\r\n  \r\n  // Create fake service for integration tests\r\n  static std::unique_ptr<FakeDownloadService> CreateFakeService(\r\n      const FakeServiceConfig& config) {\r\n    auto fake_service = std::make_unique<FakeDownloadService>();\r\n    \r\n    // Configure behavior based on test needs\r\n    fake_service->SetSimulatedBandwidth(config.bandwidth);\r\n    fake_service->SetFailureRate(config.failure_rate);\r\n    fake_service->SetLatencyRange(config.min_latency, config.max_latency);\r\n    \r\n    return fake_service;\r\n  }\r\n  \r\n  // Factory for parameterized tests\r\n  template<typename ServiceType>\r\n    requires std::derived_from<ServiceType, DownloadService>\r\n  static std::unique_ptr<ServiceType> CreateParameterizedService(\r\n      const TestParameters& params) {\r\n    auto service = std::make_unique<ServiceType>();\r\n    \r\n    // Apply test-specific configuration\r\n    for (const auto& [key, value] : params.GetConfigMap()) {\r\n      service->SetConfiguration(key, value);\r\n    }\r\n    \r\n    return service;\r\n  }\r\n};\r\n```\r\n\r\n### 5.2. Google Mock Integration\r\n\r\nModern factory testing with enhanced mock validation:\r\n\r\n```cpp\r\n// Test fixture with factory-created mocks\r\nclass DownloadServiceTest : public testing::Test {\r\n protected:\r\n  void SetUp() override {\r\n    // Create mock dependencies\r\n    mock_download_manager_ = std::make_unique<MockDownloadManager>();\r\n    mock_file_system_ = std::make_unique<MockFileSystem>();\r\n    mock_network_service_ = std::make_unique<MockNetworkService>();\r\n    \r\n    // Configure factory to use mocks\r\n    DownloadServiceFactory::SetDownloadManagerForTesting(\r\n        mock_download_manager_.get());\r\n    DownloadServiceFactory::SetFileSystemForTesting(\r\n        mock_file_system_.get());\r\n    DownloadServiceFactory::SetNetworkServiceForTesting(\r\n        mock_network_service_.get());\r\n    \r\n    // Create service under test\r\n    service_ = DownloadServiceFactory::CreateForTesting(\r\n        TestProfile::CreateProfile());\r\n  }\r\n  \r\n  void TearDown() override {\r\n    // Clean up factory state\r\n    DownloadServiceFactory::ResetForTesting();\r\n  }\r\n  \r\n  // Test helper methods\r\n  void ExpectSuccessfulDownload() {\r\n    EXPECT_CALL(*mock_download_manager_, StartDownload(testing::_))\r\n        .WillOnce(testing::Return(DownloadId{123}));\r\n    \r\n    EXPECT_CALL(*mock_file_system_, CreateTempFile(testing::_))\r\n        .WillOnce(testing::Return(base::FilePath(\"/tmp/download_123\")));\r\n    \r\n    EXPECT_CALL(*mock_network_service_, CreateURLLoader(testing::_))\r\n        .WillOnce(testing::Return(std::make_unique<MockURLLoader>()));\r\n  }\r\n  \r\n private:\r\n  std::unique_ptr<MockDownloadManager> mock_download_manager_;\r\n  std::unique_ptr<MockFileSystem> mock_file_system_;\r\n  std::unique_ptr<MockNetworkService> mock_network_service_;\r\n  std::unique_ptr<DownloadService> service_;\r\n};\r\n\r\nTEST_F(DownloadServiceTest, FactoryCreatesValidService) {\r\n  ASSERT_TRUE(service_);\r\n  EXPECT_TRUE(service_->IsInitialized());\r\n  EXPECT_FALSE(service_->HasActiveDownloads());\r\n}\r\n```\r\n\r\n---\r\n\r\n## 6. Advanced Factory Patterns (v134+)\r\n\r\n### 6.1. Dependency Injection Factory\r\n\r\nModern dependency injection with automatic resolution:\r\n\r\n```cpp\r\n// Dependency injection container\r\nclass DIContainer {\r\n public:\r\n  template<typename Interface, typename Implementation>\r\n    requires std::derived_from<Implementation, Interface>\r\n  void RegisterSingleton() {\r\n    auto factory = []() -> std::unique_ptr<Interface> {\r\n      return std::make_unique<Implementation>();\r\n    };\r\n    \r\n    singletons_[typeid(Interface)] = SingletonEntry{\r\n      .factory = std::move(factory),\r\n      .instance = nullptr\r\n    };\r\n  }\r\n  \r\n  template<typename Interface, typename Implementation>\r\n    requires std::derived_from<Implementation, Interface>\r\n  void RegisterTransient() {\r\n    auto factory = []() -> std::unique_ptr<Interface> {\r\n      return std::make_unique<Implementation>();\r\n    };\r\n    \r\n    transients_[typeid(Interface)] = std::move(factory);\r\n  }\r\n  \r\n  template<typename T>\r\n  std::unique_ptr<T> Resolve() {\r\n    const std::type_info& type = typeid(T);\r\n    \r\n    // Check for singleton\r\n    if (auto it = singletons_.find(type); it != singletons_.end()) {\r\n      auto& entry = it->second;\r\n      if (!entry.instance) {\r\n        entry.instance = entry.factory();\r\n      }\r\n      // Return a copy for singletons (or use weak_ptr pattern)\r\n      return std::unique_ptr<T>(static_cast<T*>(entry.instance.get()));\r\n    }\r\n    \r\n    // Check for transient\r\n    if (auto it = transients_.find(type); it != transients_.end()) {\r\n      return std::unique_ptr<T>(static_cast<T*>(it->second().release()));\r\n    }\r\n    \r\n    return nullptr;\r\n  }\r\n  \r\n private:\r\n  struct SingletonEntry {\r\n    std::function<std::unique_ptr<void>()> factory;\r\n    std::unique_ptr<void> instance;\r\n  };\r\n  \r\n  std::unordered_map<std::type_index, SingletonEntry> singletons_;\r\n  std::unordered_map<std::type_index, \r\n                     std::function<std::unique_ptr<void>()>> transients_;\r\n};\r\n```\r\n\r\n### 6.2. Plugin Factory System\r\n\r\nModern plugin architecture with dynamic loading:\r\n\r\n```cpp\r\n// Plugin factory for extensible components\r\nclass PluginFactory {\r\n public:\r\n  struct PluginInfo {\r\n    std::string name;\r\n    std::string version;\r\n    std::vector<std::string> dependencies;\r\n    std::function<std::unique_ptr<Plugin>()> creator;\r\n  };\r\n  \r\n  static void RegisterPlugin(const PluginInfo& info) {\r\n    auto& registry = GetRegistry();\r\n    \r\n    // Validate dependencies\r\n    for (const auto& dep : info.dependencies) {\r\n      if (registry.find(dep) == registry.end()) {\r\n        LOG(WARNING) << \"Plugin \" << info.name \r\n                     << \" depends on unregistered plugin: \" << dep;\r\n      }\r\n    }\r\n    \r\n    registry[info.name] = info;\r\n  }\r\n  \r\n  static base::expected<std::unique_ptr<Plugin>, PluginError>\r\n  CreatePlugin(const std::string& name) {\r\n    auto& registry = GetRegistry();\r\n    auto it = registry.find(name);\r\n    \r\n    if (it == registry.end()) {\r\n      return base::unexpected(PluginError::kPluginNotFound);\r\n    }\r\n    \r\n    const auto& info = it->second;\r\n    \r\n    // Check and load dependencies\r\n    for (const auto& dep : info.dependencies) {\r\n      if (auto result = EnsurePluginLoaded(dep); !result.has_value()) {\r\n        return base::unexpected(result.error());\r\n      }\r\n    }\r\n    \r\n    try {\r\n      auto plugin = info.creator();\r\n      if (!plugin) {\r\n        return base::unexpected(PluginError::kCreationFailed);\r\n      }\r\n      \r\n      // Initialize plugin\r\n      if (auto result = plugin->Initialize(); !result.has_value()) {\r\n        return base::unexpected(PluginError::kInitializationFailed);\r\n      }\r\n      \r\n      return plugin;\r\n    } catch (const std::exception& e) {\r\n      LOG(ERROR) << \"Plugin creation failed: \" << e.what();\r\n      return base::unexpected(PluginError::kCreationFailed);\r\n    }\r\n  }\r\n  \r\n private:\r\n  static std::unordered_map<std::string, PluginInfo>& GetRegistry() {\r\n    static base::NoDestructor<std::unordered_map<std::string, PluginInfo>> \r\n        registry;\r\n    return *registry;\r\n  }\r\n  \r\n  static std::unordered_set<std::string>& GetLoadedPlugins() {\r\n    static base::NoDestructor<std::unordered_set<std::string>> loaded;\r\n    return *loaded;\r\n  }\r\n  \r\n  static base::expected<void, PluginError> EnsurePluginLoaded(\r\n      const std::string& name) {\r\n    auto& loaded = GetLoadedPlugins();\r\n    if (loaded.find(name) != loaded.end()) {\r\n      return {};  // Already loaded\r\n    }\r\n    \r\n    auto plugin_result = CreatePlugin(name);\r\n    if (!plugin_result.has_value()) {\r\n      return base::unexpected(plugin_result.error());\r\n    }\r\n    \r\n    loaded.insert(name);\r\n    return {};\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 7. Factory Pattern Best Practices (v134+)\r\n\r\n### 7.1. Error Handling and Validation\r\n\r\n```cpp\r\n// Modern error handling in factories\r\nclass SecureComponentFactory {\r\n public:\r\n  static base::expected<std::unique_ptr<SecureComponent>, SecurityError>\r\n  CreateSecureComponent(const SecurityContext& context) {\r\n    // Pre-creation validation\r\n    if (auto validation = ValidateSecurityContext(context); \r\n        !validation.has_value()) {\r\n      return base::unexpected(validation.error());\r\n    }\r\n    \r\n    // Capability check\r\n    if (!context.HasRequiredCapabilities()) {\r\n      return base::unexpected(SecurityError::kInsufficientCapabilities);\r\n    }\r\n    \r\n    // Create with security restrictions\r\n    auto component = std::make_unique<SecureComponentImpl>(context);\r\n    \r\n    // Post-creation verification\r\n    if (auto verification = VerifyComponent(*component); \r\n        !verification.has_value()) {\r\n      return base::unexpected(verification.error());\r\n    }\r\n    \r\n    // Set up security monitoring\r\n    component->EnableSecurityMonitoring();\r\n    \r\n    return component;\r\n  }\r\n  \r\n private:\r\n  static base::expected<void, SecurityError> ValidateSecurityContext(\r\n      const SecurityContext& context) {\r\n    if (!context.IsValid()) {\r\n      return base::unexpected(SecurityError::kInvalidContext);\r\n    }\r\n    \r\n    if (context.GetTrustLevel() < SecurityLevel::kMinimumRequired) {\r\n      return base::unexpected(SecurityError::kInsufficientTrustLevel);\r\n    }\r\n    \r\n    return {};\r\n  }\r\n  \r\n  static base::expected<void, SecurityError> VerifyComponent(\r\n      const SecureComponent& component) {\r\n    if (!component.IsProperlySandboxed()) {\r\n      return base::unexpected(SecurityError::kSandboxingFailed);\r\n    }\r\n    \r\n    if (!component.HasValidSignature()) {\r\n      return base::unexpected(SecurityError::kInvalidSignature);\r\n    }\r\n    \r\n    return {};\r\n  }\r\n};\r\n```\r\n\r\n### 7.2. Performance Optimization\r\n\r\n```cpp\r\n// High-performance factory with object pooling\r\ntemplate<typename T>\r\nclass PooledFactory {\r\n public:\r\n  // Get object from pool or create new one\r\n  static std::unique_ptr<T> Acquire() {\r\n    auto& pool = GetPool();\r\n    \r\n    if (!pool.empty()) {\r\n      auto obj = std::move(pool.back());\r\n      pool.pop_back();\r\n      \r\n      // Reset object state\r\n      obj->Reset();\r\n      return obj;\r\n    }\r\n    \r\n    // Create new object if pool is empty\r\n    return std::make_unique<T>();\r\n  }\r\n  \r\n  // Return object to pool for reuse\r\n  static void Release(std::unique_ptr<T> obj) {\r\n    if (!obj) return;\r\n    \r\n    auto& pool = GetPool();\r\n    \r\n    // Limit pool size to prevent memory bloat\r\n    constexpr size_t kMaxPoolSize = 64;\r\n    if (pool.size() < kMaxPoolSize) {\r\n      pool.push_back(std::move(obj));\r\n    }\r\n    // Object is automatically destroyed if pool is full\r\n  }\r\n  \r\n  // Pre-warm pool with objects\r\n  static void PrewarmPool(size_t count) {\r\n    auto& pool = GetPool();\r\n    pool.reserve(count);\r\n    \r\n    for (size_t i = 0; i < count; ++i) {\r\n      pool.push_back(std::make_unique<T>());\r\n    }\r\n  }\r\n  \r\n private:\r\n  static std::vector<std::unique_ptr<T>>& GetPool() {\r\n    static base::NoDestructor<std::vector<std::unique_ptr<T>>> pool;\r\n    return *pool;\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 8. Real-World Examples from Chromium v134+\r\n\r\n### 8.1. Content Settings Factory\r\n\r\n```cpp\r\n// Simplified version of HostContentSettingsMapFactory\r\nclass HostContentSettingsMapFactory : public RefcountedBrowserContextKeyedServiceFactory {\r\n public:\r\n  static HostContentSettingsMap* GetForProfile(Profile* profile) {\r\n    return static_cast<HostContentSettingsMap*>(\r\n        GetInstance()->GetServiceForBrowserContext(profile, true).get());\r\n  }\r\n  \r\n  static HostContentSettingsMapFactory* GetInstance() {\r\n    static base::NoDestructor<HostContentSettingsMapFactory> instance;\r\n    return instance.get();\r\n  }\r\n  \r\n private:\r\n  HostContentSettingsMapFactory()\r\n      : RefcountedBrowserContextKeyedServiceFactory(\r\n            \"HostContentSettingsMap\",\r\n            BrowserContextDependencyManager::GetInstance()) {\r\n    DependsOn(PrefServiceSyncableFromProfile::GetInstance());\r\n  }\r\n  \r\n  scoped_refptr<RefcountedKeyedService> BuildServiceInstanceFor(\r\n      content::BrowserContext* context) const override {\r\n    Profile* profile = Profile::FromBrowserContext(context);\r\n    \r\n    auto map = base::MakeRefCounted<HostContentSettingsMapImpl>(\r\n        profile->GetPrefs(),\r\n        profile->IsOffTheRecord(),\r\n        profile->IsGuestSession(),\r\n        profile->IsExtensionProfile());\r\n    \r\n    // Configure for modern privacy features\r\n    if (base::FeatureList::IsEnabled(features::kPrivacySandboxSettings)) {\r\n      map->EnablePrivacySandboxSupport();\r\n    }\r\n    \r\n    return map;\r\n  }\r\n};\r\n```\r\n\r\n### 8.2. Media Device Factory\r\n\r\n```cpp\r\n// Factory for media device access with permissions\r\nclass MediaDeviceFactory {\r\n public:\r\n  static void CreateMediaDeviceService(\r\n      RenderFrameHost* frame_host,\r\n      mojo::PendingReceiver<blink::mojom::MediaDevicesDispatcherHost> receiver) {\r\n    \r\n    if (!frame_host || !frame_host->IsRenderFrameLive()) {\r\n      receiver.ResetWithReason(1, \"Invalid frame\");\r\n      return;\r\n    }\r\n    \r\n    // Check permissions\r\n    auto* permission_controller = \r\n        frame_host->GetBrowserContext()->GetPermissionController();\r\n    \r\n    auto mic_status = permission_controller->GetPermissionStatus(\r\n        ContentSettingsType::MEDIASTREAM_MIC,\r\n        frame_host->GetLastCommittedOrigin(),\r\n        frame_host->GetLastCommittedOrigin());\r\n    \r\n    auto camera_status = permission_controller->GetPermissionStatus(\r\n        ContentSettingsType::MEDIASTREAM_CAMERA,\r\n        frame_host->GetLastCommittedOrigin(),\r\n        frame_host->GetLastCommittedOrigin());\r\n    \r\n    // Create service with appropriate capabilities\r\n    auto service = std::make_unique<MediaDevicesDispatcherHostImpl>(\r\n        frame_host->GetProcess()->GetID(),\r\n        frame_host->GetRoutingID(),\r\n        mic_status == blink::mojom::PermissionStatus::GRANTED,\r\n        camera_status == blink::mojom::PermissionStatus::GRANTED);\r\n    \r\n    mojo::MakeSelfOwnedReceiver(std::move(service), std::move(receiver));\r\n  }\r\n};\r\n```\r\n\r\n---\r\n\r\n## 9. Factory Pattern Summary (v134+)\r\n\r\n### Key Advantages\r\n- **Flexibility**: Easy to swap implementations based on runtime conditions\r\n- **Testability**: Simplified dependency injection and mocking\r\n- **Maintainability**: Centralized object creation logic\r\n- **Security**: Controlled instantiation with proper validation\r\n- **Performance**: Object pooling and lazy initialization support\r\n\r\n### Modern Considerations\r\n- **Memory Safety**: Use smart pointers and RAII principles\r\n- **Error Handling**: Leverage `base::expected` for graceful error propagation\r\n- **Async Support**: Modern async patterns with coroutines and callbacks\r\n- **Type Safety**: Template metaprogramming and concepts for compile-time validation\r\n- **Service Integration**: Seamless Mojo service creation and capability management\r\n\r\n### Best Practices\r\n1. **Always validate inputs** before object creation\r\n2. **Use `base::expected`** for error-aware factory methods\r\n3. **Implement proper cleanup** and resource management\r\n4. **Consider object pooling** for frequently created objects\r\n5. **Document factory contracts** and expected behavior\r\n6. **Test factory behavior** with comprehensive unit tests\r\n7. **Follow security guidelines** for capability-restricted components\r\n\r\nThe Factory pattern remains essential in modern Chromium architecture, enabling flexible, secure, and maintainable object creation across the complex browser ecosystem.\r\n"
  },
  {
    "path": "architecture/design-patterns/delegate-pattern",
    "title": "Delegate Pattern in Modern Chromium (v134+)",
    "content": "# Delegate Pattern in Modern Chromium (v134+)\r\n\r\nThe **Delegate Pattern** is a cornerstone architectural pattern in modern Chromium, enabling sophisticated component decoupling, dependency injection, and extensibility throughout the browser's complex service-oriented architecture. In v134+, this pattern has evolved to support advanced features like Mojo interfaces, capability-based security, and cross-process communication.\r\n\r\n---\r\n\r\n## Modern Delegate Pattern Overview (v134+)\r\n\r\nThe Delegate Pattern in Chromium v134+ represents a sophisticated evolution of traditional delegation, incorporating modern C++20/23 features, type safety, and integration with the browser's advanced service architecture.\r\n\r\n### Enhanced Key Features:\r\n- **Type-Safe Delegation**: Modern C++ templates and concepts for compile-time safety\r\n- **Mojo Integration**: Seamless integration with Chromium's IPC system\r\n- **Capability-Based Security**: Delegates respect process boundaries and security policies\r\n- **Service-Oriented Architecture**: Delegates work across Chromium's microservice ecosystem\r\n- **Async/Await Support**: Modern asynchronous programming patterns\r\n- **Memory Safety**: Smart pointer usage and RAII principles\r\n\r\n---\r\n\r\n## Modern Chromium Architecture Integration (v134+)\r\n\r\nChromium's delegate pattern has evolved to support the browser's sophisticated multi-process, service-oriented architecture:\r\n\r\n### Service Manager Integration\r\n```cpp\r\n// Modern service-aware delegate pattern\r\nclass ServiceAwareDelegate {\r\n public:\r\n  virtual ~ServiceAwareDelegate() = default;\r\n  \r\n  // Capability-based access to services\r\n  virtual void OnServiceConnected(\r\n      mojo::PendingReceiver<mojom::SomeService> receiver) {}\r\n  \r\n  // Handle service disconnection gracefully\r\n  virtual void OnServiceDisconnected() {}\r\n  \r\n  // Modern async patterns with callbacks\r\n  virtual void ProcessRequestAsync(\r\n      mojom::RequestPtr request,\r\n      base::OnceCallback<void(mojom::ResponsePtr)> callback) = 0;\r\n};\r\n```\r\n\r\n### Cross-Process Delegate Communication\r\nModern delegates can operate across process boundaries using Mojo interfaces:\r\n\r\n```cpp\r\n// Mojo-based delegate for cross-process communication\r\nclass CrossProcessDelegate : public mojom::ProcessDelegate {\r\n public:\r\n  // Mojo interface implementation\r\n  void HandleCrossProcessRequest(\r\n      mojom::CrossProcessRequestPtr request,\r\n      HandleCrossProcessRequestCallback callback) override {\r\n    \r\n    // Process request with modern async patterns\r\n    ProcessRequestInBackground(\r\n        std::move(request),\r\n        base::BindOnce(&CrossProcessDelegate::OnRequestProcessed,\r\n                       weak_ptr_factory_.GetWeakPtr(),\r\n                       std::move(callback)));\r\n  }\r\n\r\n private:\r\n  void OnRequestProcessed(\r\n      HandleCrossProcessRequestCallback callback,\r\n      mojom::CrossProcessResponsePtr response) {\r\n    std::move(callback).Run(std::move(response));\r\n  }\r\n\r\n  base::WeakPtrFactory<CrossProcessDelegate> weak_ptr_factory_{this};\r\n};\r\n```\r\n\r\n---\r\n\r\n## Advanced Download Manager Example (v134+)\r\n\r\nThe modern Download Manager showcases sophisticated delegate patterns with enhanced security, performance, and integration:\r\n\r\n### Enhanced Download Manager Delegate\r\n```cpp\r\n// Modern download manager delegate with comprehensive capabilities\r\nclass DownloadManagerDelegate {\r\n public:\r\n  virtual ~DownloadManagerDelegate() = default;\r\n\r\n  // Security-enhanced path selection with sandbox integration\r\n  virtual base::FilePath DetermineDownloadTarget(\r\n      const GURL& url,\r\n      const std::string& suggested_filename,\r\n      const std::string& mime_type,\r\n      const std::optional<std::string>& content_disposition,\r\n      DownloadSecurity::ThreatLevel threat_level) = 0;\r\n\r\n  // Modern async validation with comprehensive security checks\r\n  virtual void ValidateDownloadAsync(\r\n      const base::FilePath& path,\r\n      const DownloadMetadata& metadata,\r\n      base::OnceCallback<void(DownloadValidationResult)> callback) = 0;\r\n\r\n  // Enhanced progress tracking with performance metrics\r\n  virtual void OnDownloadProgress(\r\n      const DownloadProgressInfo& progress,\r\n      const PerformanceMetrics& metrics) {}\r\n\r\n  // Integration with modern privacy controls\r\n  virtual bool ShouldBlockDownload(\r\n      const DownloadSecurityInfo& security_info,\r\n      const PrivacySettings& privacy_settings) = 0;\r\n\r\n  // Support for modern download features\r\n  virtual void HandleParallelDownload(\r\n      const ParallelDownloadConfig& config) {}\r\n  \r\n  // Integration with cloud services and sync\r\n  virtual void OnDownloadSyncRequest(\r\n      const DownloadSyncInfo& sync_info) {}\r\n};\r\n```\r\n\r\n### Production Implementation\r\n```cpp\r\n// Production-ready delegate with modern security and performance\r\nclass ProductionDownloadDelegate : public DownloadManagerDelegate {\r\n public:\r\n  explicit ProductionDownloadDelegate(\r\n      Profile* profile,\r\n      scoped_refptr<SafeBrowsingService> safe_browsing_service,\r\n      std::unique_ptr<QuarantineService> quarantine_service)\r\n      : profile_(profile),\r\n        safe_browsing_service_(std::move(safe_browsing_service)),\r\n        quarantine_service_(std::move(quarantine_service)) {}\r\n\r\n  base::FilePath DetermineDownloadTarget(\r\n      const GURL& url,\r\n      const std::string& suggested_filename,\r\n      const std::string& mime_type,\r\n      const std::optional<std::string>& content_disposition,\r\n      DownloadSecurity::ThreatLevel threat_level) override {\r\n    \r\n    // Modern path selection with security validation\r\n    auto sanitized_filename = SanitizeFilename(suggested_filename);\r\n    auto download_path = profile_->GetDownloadPath();\r\n    \r\n    // Apply threat-level specific restrictions\r\n    if (threat_level >= DownloadSecurity::ThreatLevel::DANGEROUS) {\r\n      return quarantine_service_->GetQuarantinePath(sanitized_filename);\r\n    }\r\n    \r\n    return download_path.Append(sanitized_filename);\r\n  }\r\n\r\n  void ValidateDownloadAsync(\r\n      const base::FilePath& path,\r\n      const DownloadMetadata& metadata,\r\n      base::OnceCallback<void(DownloadValidationResult)> callback) override {\r\n    \r\n    // Modern async validation chain\r\n    safe_browsing_service_->CheckDownloadAsync(\r\n        path, metadata,\r\n        base::BindOnce(&ProductionDownloadDelegate::OnSafeBrowsingCheck,\r\n                       weak_ptr_factory_.GetWeakPtr(),\r\n                       path, std::move(callback)));\r\n  }\r\n\r\n private:\r\n  void OnSafeBrowsingCheck(\r\n      const base::FilePath& path,\r\n      base::OnceCallback<void(DownloadValidationResult)> callback,\r\n      SafeBrowsingResult result) {\r\n    \r\n    if (result.is_safe()) {\r\n      // Proceed with additional validation\r\n      quarantine_service_->ScanFileAsync(\r\n          path,\r\n          base::BindOnce(&ProductionDownloadDelegate::OnQuarantineScan,\r\n                         weak_ptr_factory_.GetWeakPtr(),\r\n                         std::move(callback)));\r\n    } else {\r\n      std::move(callback).Run(\r\n          DownloadValidationResult::CreateBlocked(result.threat_type()));\r\n    }\r\n  }\r\n\r\n  void OnQuarantineScan(\r\n      base::OnceCallback<void(DownloadValidationResult)> callback,\r\n      QuarantineResult result) {\r\n    std::move(callback).Run(\r\n        result.is_clean() \r\n            ? DownloadValidationResult::CreateAllowed()\r\n            : DownloadValidationResult::CreateQuarantined());\r\n  }\r\n\r\n  raw_ptr<Profile> profile_;\r\n  scoped_refptr<SafeBrowsingService> safe_browsing_service_;\r\n  std::unique_ptr<QuarantineService> quarantine_service_;\r\n  base::WeakPtrFactory<ProductionDownloadDelegate> weak_ptr_factory_{this};\r\n};\r\n```\r\n\r\n### Modern UML Architecture\r\n```text\r\n┌─────────────────────┐    delegates to    ┌──────────────────────────┐\r\n│   DownloadManager   │ ──────────────────► │  DownloadManagerDelegate │\r\n│                     │                     │                          │\r\n│ + StartDownload()   │                     │ + DetermineDownloadTarget│\r\n│ + PauseDownload()   │                     │ + ValidateDownloadAsync  │\r\n│ + CancelDownload()  │                     │ + OnDownloadProgress     │\r\n│ + SetDelegate()     │                     │ + ShouldBlockDownload    │\r\n└─────────────────────┘                     └──────────────────────────┘\r\n         │                                              △\r\n         │                                              │\r\n         ▼                                              │\r\n┌─────────────────────┐                     ┌──────────────────────────┐\r\n│   Mojo IPC Layer    │                     │ ProductionDownloadDelegate│\r\n│                     │                     │                          │\r\n│ + SendProgress()    │                     │ + Integration with:      │\r\n│ + HandleErrors()    │                     │   - SafeBrowsingService  │\r\n│ + CrossProcess()    │                     │   - QuarantineService    │\r\n└─────────────────────┘                     │   - Privacy Controls     │\r\n                                            │   - Cloud Sync           │\r\n                                            └──────────────────────────┘\r\n```\r\n\r\n---\r\n\r\n## Modern Testing Patterns (v134+)\r\n\r\nAdvanced testing delegates leverage modern C++ features and Chromium's testing infrastructure:\r\n\r\n### Enhanced Test Delegate\r\n```cpp\r\n// Modern test delegate with comprehensive mocking capabilities\r\nclass MockDownloadManagerDelegate : public DownloadManagerDelegate {\r\n public:\r\n  MOCK_METHOD(base::FilePath, DetermineDownloadTarget,\r\n              (const GURL& url,\r\n               const std::string& suggested_filename,\r\n               const std::string& mime_type,\r\n               const std::optional<std::string>& content_disposition,\r\n               DownloadSecurity::ThreatLevel threat_level), (override));\r\n\r\n  MOCK_METHOD(void, ValidateDownloadAsync,\r\n              (const base::FilePath& path,\r\n               const DownloadMetadata& metadata,\r\n               base::OnceCallback<void(DownloadValidationResult)> callback),\r\n              (override));\r\n\r\n  MOCK_METHOD(bool, ShouldBlockDownload,\r\n              (const DownloadSecurityInfo& security_info,\r\n               const PrivacySettings& privacy_settings), (override));\r\n\r\n  // Helper methods for test setup\r\n  void SetupSuccessfulValidation() {\r\n    ON_CALL(*this, ValidateDownloadAsync)\r\n        .WillByDefault([](const base::FilePath&,\r\n                         const DownloadMetadata&,\r\n                         base::OnceCallback<void(DownloadValidationResult)> callback) {\r\n          std::move(callback).Run(DownloadValidationResult::CreateAllowed());\r\n        });\r\n  }\r\n\r\n  void SetupSecurityBlocking() {\r\n    ON_CALL(*this, ShouldBlockDownload)\r\n        .WillByDefault(Return(true));\r\n  }\r\n};\r\n```\r\n\r\n### Modern Test Implementation\r\n```cpp\r\n// Advanced test case with modern patterns\r\nclass DownloadManagerTest : public testing::Test {\r\n public:\r\n  void SetUp() override {\r\n    // Modern dependency injection with mock services\r\n    auto mock_delegate = std::make_unique<MockDownloadManagerDelegate>();\r\n    mock_delegate_ = mock_delegate.get();\r\n    \r\n    download_manager_ = std::make_unique<DownloadManager>(\r\n        &profile_, std::move(mock_delegate));\r\n  }\r\n\r\n  void TearDown() override {\r\n    // Modern RAII cleanup\r\n    download_manager_.reset();\r\n  }\r\n\r\n protected:\r\n  base::test::TaskEnvironment task_environment_;\r\n  TestingProfile profile_;\r\n  std::unique_ptr<DownloadManager> download_manager_;\r\n  raw_ptr<MockDownloadManagerDelegate> mock_delegate_;\r\n};\r\n\r\nTEST_F(DownloadManagerTest, HandlesSecureDownloadWithModernValidation) {\r\n  // Setup modern expectations\r\n  mock_delegate_->SetupSuccessfulValidation();\r\n  \r\n  EXPECT_CALL(*mock_delegate_, DetermineDownloadTarget)\r\n      .WillOnce(Return(base::FilePath(FILE_PATH_LITERAL(\"/safe/downloads/file.pdf\"))));\r\n  \r\n  EXPECT_CALL(*mock_delegate_, ShouldBlockDownload)\r\n      .WillOnce(Return(false));\r\n\r\n  // Execute with modern async patterns\r\n  base::RunLoop run_loop;\r\n  download_manager_->StartDownload(\r\n      GURL(\"https://example.com/secure-file.pdf\"),\r\n      \"secure-file.pdf\",\r\n      base::BindLambdaForTesting([&](DownloadResult result) {\r\n        EXPECT_EQ(result.status(), DownloadStatus::SUCCESS);\r\n        run_loop.Quit();\r\n      }));\r\n  \r\n  run_loop.Run();\r\n}\r\n```\r\n\r\n---\r\n\r\n## Advanced Delegate Patterns in v134+\r\n\r\n### Service-Oriented Delegates\r\nModern Chromium uses delegates extensively in its service architecture:\r\n\r\n```cpp\r\n// Network service delegate with modern capabilities\r\nclass NetworkServiceDelegate : public mojom::NetworkServiceClient {\r\n public:\r\n  // Modern SSL certificate handling\r\n  void OnCertificateRequested(\r\n      const std::optional<base::UnguessableToken>& window_id,\r\n      uint32_t process_id,\r\n      uint32_t routing_id,\r\n      const scoped_refptr<net::SSLCertRequestInfo>& cert_info,\r\n      mojo::PendingRemote<mojom::ClientCertificateResponder> responder) override;\r\n\r\n  // Advanced privacy controls\r\n  void OnCanSendReportingReports(\r\n      const std::vector<url::Origin>& origins,\r\n      base::OnceCallback<void(const std::vector<url::Origin>&)> callback) override;\r\n\r\n  // Modern cookie management with privacy sandbox\r\n  void OnCookiesRead(\r\n      const GURL& url,\r\n      const GURL& site_for_cookies,\r\n      const net::CookieAccessResultList& cookie_list,\r\n      OnCookiesReadCallback callback) override;\r\n};\r\n```\r\n\r\n### GPU Process Delegates\r\nAdvanced graphics delegates for the Viz compositor:\r\n\r\n```cpp\r\n// Modern GPU process delegate with Viz integration\r\nclass GpuProcessDelegate : public mojom::GpuHost {\r\n public:\r\n  // Advanced GPU memory management\r\n  void DidCreateContextSuccessfully() override;\r\n  \r\n  // Modern graphics diagnostics\r\n  void DidCreateOffscreenContext(const GURL& url) override;\r\n  \r\n  // Enhanced GPU process monitoring\r\n  void DidLoseContext(bool offscreen,\r\n                     gpu::error::ContextLostReason reason,\r\n                     const GURL& active_url) override;\r\n  \r\n  // Viz compositor integration\r\n  void SetChildSurface(gpu::SurfaceHandle parent,\r\n                      gpu::SurfaceHandle child) override;\r\n};\r\n```\r\n\r\n---\r\n\r\n## Modern Benefits & Best Practices (v134+)\r\n\r\n### Enhanced Architectural Benefits\r\n1. **Type Safety**: Modern C++ templates and concepts ensure compile-time correctness\r\n2. **Memory Safety**: RAII and smart pointers prevent memory leaks and use-after-free bugs\r\n3. **Async Programming**: Integration with Chromium's modern async patterns\r\n4. **Service Integration**: Seamless integration with Chromium's microservice architecture\r\n5. **Security**: Capability-based delegation respects process boundaries\r\n6. **Performance**: Zero-cost abstractions and efficient IPC integration\r\n\r\n### Modern Best Practices\r\n```cpp\r\n// Best practice: Modern delegate interface design\r\nclass ModernDelegate {\r\n public:\r\n  virtual ~ModernDelegate() = default;\r\n\r\n  // Use strong types instead of primitive parameters\r\n  virtual void ProcessRequest(\r\n      const TypedRequest& request,\r\n      base::OnceCallback<void(TypedResponse)> callback) = 0;\r\n\r\n  // Prefer span<> for array parameters\r\n  virtual void ProcessBatch(\r\n      base::span<const RequestItem> items) = 0;\r\n\r\n  // Use std::optional for optional parameters\r\n  virtual bool Configure(\r\n      const Config& config,\r\n      std::optional<SecurityLevel> security_level = std::nullopt) = 0;\r\n\r\n  // Modern error handling with base::expected\r\n  virtual base::expected<ProcessResult, ProcessError> TryProcess(\r\n      const Request& request) = 0;\r\n};\r\n```\r\n\r\n### Performance Considerations\r\n- **Minimal Virtual Function Calls**: Use templates where appropriate\r\n- **Efficient Memory Management**: Leverage move semantics and perfect forwarding\r\n- **Cache-Friendly Design**: Consider memory layout and access patterns\r\n- **IPC Optimization**: Minimize cross-process delegate calls\r\n\r\n---\r\n\r\n## Integration with Modern Chromium Features (v134+)\r\n\r\n### Privacy Sandbox Integration\r\n```cpp\r\nclass PrivacySandboxDelegate {\r\n public:\r\n  // Topics API integration\r\n  virtual void OnTopicsCalculated(\r\n      const std::vector<Topic>& topics,\r\n      const PrivacyBudget& budget) = 0;\r\n\r\n  // FLEDGE auction support\r\n  virtual void OnAuctionComplete(\r\n      const AuctionResult& result,\r\n      const std::vector<InterestGroup>& winning_groups) = 0;\r\n\r\n  // Attribution reporting\r\n  virtual void OnAttributionReportScheduled(\r\n      const AttributionReport& report) = 0;\r\n};\r\n```\r\n\r\n### WebGPU Integration\r\n```cpp\r\nclass WebGPUDelegate {\r\n public:\r\n  // Modern GPU resource management\r\n  virtual void OnGPUResourceCreated(\r\n      const WebGPUResource& resource,\r\n      const SecurityContext& context) = 0;\r\n\r\n  // Compute shader delegation\r\n  virtual void OnComputeShaderExecution(\r\n      const ComputeShaderInfo& shader_info,\r\n      const ExecutionMetrics& metrics) = 0;\r\n};\r\n```\r\n\r\n---\r\n\r\n## Migration Guide: Legacy to Modern Delegates\r\n\r\n### Legacy Pattern (Pre-v134)\r\n```cpp\r\n// Old-style delegate with raw pointers and synchronous methods\r\nclass LegacyDelegate {\r\n public:\r\n  virtual bool Process(const char* data, int size) = 0;\r\n  virtual void SetCallback(Callback* callback) = 0;  // Raw pointer!\r\n};\r\n```\r\n\r\n### Modern Pattern (v134+)\r\n```cpp\r\n// Modern delegate with type safety and async patterns\r\nclass ModernDelegate {\r\n public:\r\n  virtual ~ModernDelegate() = default;\r\n  \r\n  virtual void ProcessAsync(\r\n      base::span<const uint8_t> data,\r\n      base::OnceCallback<void(ProcessResult)> callback) = 0;\r\n      \r\n  virtual base::expected<void, ProcessError> ProcessSync(\r\n      base::span<const uint8_t> data) = 0;\r\n};\r\n```\r\n\r\n---\r\n\r\n## Conclusion\r\n\r\nThe Delegate Pattern in Chromium v134+ represents a sophisticated evolution of traditional design patterns, incorporating modern C++ features, type safety, and deep integration with the browser's advanced architecture. This pattern enables:\r\n\r\n- **Scalable Architecture**: Support for Chromium's massive, service-oriented codebase\r\n- **Security**: Respect for process boundaries and capability-based access\r\n- **Performance**: Efficient implementations with modern C++ optimizations\r\n- **Maintainability**: Clear separation of concerns and testable interfaces\r\n- **Extensibility**: Easy customization for different browser configurations\r\n\r\nBy mastering modern delegate patterns, developers can effectively contribute to and extend Chromium's sophisticated browser architecture while maintaining the high standards of security, performance, and reliability that modern web browsers demand.\r\n\r\n**Key Takeaways**:\r\n- Modern delegates integrate deeply with Chromium's service architecture\r\n- Type safety and memory safety are paramount in v134+ implementations\r\n- Async patterns are preferred for non-blocking operations\r\n- Security considerations are built into the delegate design\r\n- Testing is enhanced through modern mocking and dependency injection\r\n\r\n**Next Steps**:\r\n- Explore [Mojo IPC Integration](../ipc-internals.md) for cross-process delegate communication\r\n- Study [Service Architecture](../browser-components.md) for advanced delegate usage patterns\r\n- Review [Security Model](../../security/security-model.md) for security-aware delegate design\r\n"
  }
]